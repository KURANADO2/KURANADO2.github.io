<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.kuranado.com</id>
    <title>KURANADO</title>
    <updated>2021-03-28T09:27:34.563Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.kuranado.com"/>
    <link rel="self" href="http://blog.kuranado.com/atom.xml"/>
    <subtitle>笔记/博客</subtitle>
    <logo>http://blog.kuranado.com/images/avatar.png</logo>
    <icon>http://blog.kuranado.com/favicon.ico</icon>
    <rights>All rights reserved 2021, KURANADO</rights>
    <entry>
        <title type="html"><![CDATA[简单工厂模式.md]]></title>
        <id>http://blog.kuranado.com/post/jian-dan-gong-han-mo-shi-md/</id>
        <link href="http://blog.kuranado.com/post/jian-dan-gong-han-mo-shi-md/">
        </link>
        <updated>2021-03-28T09:22:46.000Z</updated>
        <summary type="html"><![CDATA[<p>[TOC]</p>
<p>现如今各家云厂商都推出了自己的对象存储产品，AWS S3、阿里云 OSS、腾讯云 COS、金山云 KS3 等等，数不胜数，开发者不再需要将文件存储到本地磁盘，也不再需要 FastDFS 等文件系统，直接使用对象存储提供的强大 SDK，就可以更高效、安全的管理文件。作为一家致力服务于汽车 OTA 升级的公司，每家车厂提供的对象存储资源都不同，如生产海外车型的 A 车厂会选用 S3，而做国内车型的 B 车厂则可能会选用 OSS。一套代码，如何优雅的接入不同对象存储便是我们今天要探讨的问题！</p>
]]></summary>
        <content type="html"><![CDATA[<p>[TOC]</p>
<p>现如今各家云厂商都推出了自己的对象存储产品，AWS S3、阿里云 OSS、腾讯云 COS、金山云 KS3 等等，数不胜数，开发者不再需要将文件存储到本地磁盘，也不再需要 FastDFS 等文件系统，直接使用对象存储提供的强大 SDK，就可以更高效、安全的管理文件。作为一家致力服务于汽车 OTA 升级的公司，每家车厂提供的对象存储资源都不同，如生产海外车型的 A 车厂会选用 S3，而做国内车型的 B 车厂则可能会选用 OSS。一套代码，如何优雅的接入不同对象存储便是我们今天要探讨的问题！</p>
<!-- more -->
<h2 id="栗子">栗子🌰</h2>
<p>作如下假设：</p>
<ul>
<li>A 车厂需要使用 S3 对象存储</li>
<li>B 车厂需要使用 OSS 对象存储</li>
<li>C 车厂需要使用 COS 对象存储</li>
</ul>
<p>编写代码如下：</p>
<h3 id="文件操作接口">文件操作接口</h3>
<pre><code>import java.io.InputStream;

/**
 * 文件操作接口
 *
 * @author Xinling Jing
 * @date 2021-03-28 14:25
 */
public interface FileApi {

    /**
     * 上传文件
     *
     * @param inputStream 文件输入流
     * @param objectKey 文件路径
     */
    void uploadFile(InputStream inputStream, String objectKey);

    /**
     * 获取文件下载 Url
     *
     * @param objectKey 文件路径
     * @return 下载 Url
     */
    String getUrl(String objectKey);
}
</code></pre>
<h3 id="s3-文件操作实现类">S3 文件操作实现类</h3>
<pre><code>import java.io.InputStream;

/**
 * AWS S3 对象存储文件操作实现
 *
 * @author Xinling Jing
 * @date 2021-03-28 14:31
 */
public class S3FileApiImpl implements FileApi {

    @Override
    public void uploadFile(InputStream inputStream, String objectKey) {
        System.out.println(&quot;文件已成功上传到 S3&quot;);
    }

    @Override
    public String getUrl(String objectKey) {
        return &quot;https://bucket.s3-website.us-west-2.amazonaws.com/&quot; + objectKey;
    }
}
</code></pre>
<p>为了示例简单，此处并没有真的把文件上传到对象存储，下同</p>
<h3 id="oss-文件操作实现类">OSS 文件操作实现类</h3>
<pre><code>import java.io.InputStream;

/**
 * 阿里 OSS 对象存储文件操作实现
 *
 * @author Xinling Jing
 * @date 2021-03-28 14:26
 */
public class OssFileApiImpl implements FileApi {

    @Override
    public void uploadFile(InputStream inputStream, String objectKey) {
        System.out.println(&quot;文件已成功上传到 OSS&quot;);
    }

    @Override
    public String getUrl(String objectKey) {
        return &quot;https://bucket.oss-cn-shanghai.aliyuncs.com/&quot; + objectKey;
    }
}
</code></pre>
<h3 id="cos-文件操作实现类">COS 文件操作实现类</h3>
<pre><code>import java.io.InputStream;

/**
 * 腾讯云 COS 对象存储文件操作实现
 *
 * @author Xinling Jing
 * @date 2021-03-28 14:32
 */
public class CosFileApiImpl implements FileApi {

    @Override
    public void uploadFile(InputStream inputStream, String objectKey) {
        System.out.println(&quot;文件已成功上传到 COS&quot;);
    }

    @Override
    public String getUrl(String objectKey) {
        return &quot;https://bucket.cos.ap-shanghai.myqcloud.com/&quot; + objectKey;
    }
}
</code></pre>
<h3 id="客户端测试">客户端测试</h3>
<pre><code>/**
 * 测试客户端
 *
 * @author Xinling Jing
 * @date 2021-03-28 14:34
 */
public class Client {

    public static void main(String[] args) {

        // 对象存储类型
        String type = &quot;OSS&quot;;

        FileApi fileApi = null;
        switch (type.toUpperCase()) {
            case &quot;S3&quot;:
                fileApi = new S3FileApiImpl();
                break;
            case &quot;OSS&quot;:
                fileApi = new OssFileApiImpl();
                break;
            case &quot;COS&quot;:
                fileApi = new CosFileApiImpl();
                break;
            default:
                break;
        }

        if (fileApi == null) {
            System.out.println(&quot;文件操作实现类创建失败&quot;);
            return;
        }

        String path = &quot;user/avatar/1234.png&quot;;
        fileApi.uploadFile(null, path);
        String downloadUrl = fileApi.getUrl(path);
        System.out.println(&quot;文件下载 url: &quot; + downloadUrl);
    }
}
</code></pre>
<p>这里的对象存储类型 type，在实际开发中可以放到配置文件中，然后通过 <code>@Value</code> 注解注入，对于文章一开始的假设，为 A 车厂部署的代码，配置文件中就配置为 S3，B 车厂配置为 OSS，C 车厂则配置为 COS。</p>
<p>输出结果：</p>
<pre><code>文件已成功上传到 OSS
文件下载 url: https://bucket.oss-cn-shanghai.aliyuncs.com/user/avatar/1234.png
</code></pre>
<p>这样一来，代码就完成啦！</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1616923542.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>先别高兴的太早。实际业务中往往不止一处地方需要获得文件操作接口，所以下面这段代码可能会重复出现多次：</p>
<pre><code>FileApi fileApi = null;
switch (type.toUpperCase()) {
    case &quot;S3&quot;:
        fileApi = new S3FileApiImpl();
        break;
    case &quot;OSS&quot;:
        fileApi = new OssFileApiImpl();
        break;
    case &quot;COS&quot;:
        fileApi = new CosFileApiImpl();
        break;
    default:
        break;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1616923555.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>别着急嘛！使用简单工厂模式就可以轻松解决这个问题。既然称之为“简单”工厂模式，以大家的聪明才智，那肯定就是一学就会！</p>
<h2 id="简单工厂模式">简单工厂模式</h2>
<blockquote>
<p>提供一个创建对象实例的功能，而无需关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类</p>
</blockquote>
<p>在 Java 中，接口的思想是封装隔离，模块外部的客户端却违背了这一点，因为客户端知道了所有的实现类。我们的代码只用到了接口的<strong>多态</strong>特性，接口最重要的<strong>封装隔离</strong>并没有体现出来。<br>
既然<strong>模块外部不应该知道模块内部的细节，那我们就在模块内部新建一个简单工厂类</strong>，将原先位于客户端中的创建实例方法移动到简单工厂类当中，这样模块外部的客户端通过简单工厂类返回的接口对象，就可以拥有想要的功能。客户端将选择实现类的工作交给了简单工厂类，自己不再需要知道模块内部细节，也就不脱离封装隔离思想了</p>
<h3 id="简单工厂结构图">简单工厂结构图</h3>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1616923566.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h3 id="简单工厂类">简单工厂类</h3>
<pre><code>/**
 * 文件操作实现类工厂
 *
 * @author Xinling Jing
 * @date 2021-03-28 14:33
 */
public class FileFactory {

    private FileFactory() {
    }

    /**
     * 根据外部传入的存储类型，决定创建何种对象存储文件操作实现类
     *
     * @param type 存储类型
     * @return 具体的对象存储实现类
     */
    public static FileApi createFileApi(String type) {
        switch (type.toUpperCase()) {
            case &quot;S3&quot;:
                return new S3FileApiImpl();
            case &quot;OSS&quot;:
                return new OssFileApiImpl();
            case &quot;COS&quot;:
                return new CosFileApiImpl();
            default:
                return null;
        }
    }
}
</code></pre>
<h3 id="客户端测试-2">客户端测试</h3>
<pre><code>/**
 * 测试客户端
 *
 * @author Xinling Jing
 * @date 2021-03-28 14:34
 */
public class Client {

    public static void main(String[] args) {

        // 对象存储类型
        String type = &quot;OSS&quot;;
        FileApi fileApi = FileFactory.createFileApi(type);

        if (fileApi == null) {
            System.out.println(&quot;文件操作实现类创建失败&quot;);
            return;
        }

        String path = &quot;user/avatar/1234.png&quot;;
        fileApi.uploadFile(null, path);
        String downloadUrl = fileApi.getUrl(path);
        System.out.println(&quot;文件下载 url: &quot; + downloadUrl);
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>文件已成功上传到 OSS
文件下载 url: https://bucket.oss-cn-shanghai.aliyuncs.com/user/avatar/1234.png
</code></pre>
<p>到此代码就改造完成了，即便有多个地方需要进行文件操作，都只需要执行 <code>FileApi fileApi = FileFactory.createFileApi(type);</code> 就可以获得具体实例，这样模块外部才算真正做到<strong>面向接口编程</strong></p>
<h3 id="类结构图">类结构图</h3>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1616923578.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="参考">参考</h2>
<ul>
<li>《研磨设计模式》</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[状态模式.md]]></title>
        <id>http://blog.kuranado.com/post/zhuang-tai-mo-shi-md/</id>
        <link href="http://blog.kuranado.com/post/zhuang-tai-mo-shi-md/">
        </link>
        <updated>2021-03-27T12:26:10.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<p>物联网设备在整个 OTA 的升级过程中，会将自身当前状态上报给 OTA 管理平台，管理员从平台可以查询到所有设备的历史状态和当前状态。在代码开发前，产品需要定义好设备应该具有哪些状态，比如说初期可以定义如下几个状态：</p>
<ol>
<li>未检测</li>
<li>检测无新版本</li>
<li>检测有新版本</li>
<li>下载中</li>
</ol>
<p>有了状态，还要定义状态之间的<strong>扭转关系</strong>，比如设备当前状态为未检测状态，在设备执行检测动作后，设备状态可以变更为检测无新版本或者是检测有新版本，而不能变成下载中。针对上面四个状态，假设存在如下扭转关系：</p>
<ul>
<li>未检测 -&gt; 检测无新版本</li>
<li>未检测 -&gt; 检测有新版本</li>
<li>检测无新版本 -&gt; 检测有新版本</li>
<li>检测有新版本 -&gt; 下载中</li>
<li>检测有新版本 -&gt; 检测无新版本</li>
<li>下载中 -&gt; 检测无新版本</li>
<li>下载中 -&gt; 检测有新版本</li>
</ul>
<p>用一张图概括：<br>
<img src="http://image.kuranado.com/blog/1616848124.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></p>
<p>OK，至此，产品已经定义好了业务逻辑，接下来就该程序员出马了！<br>
首先定义状态接口：</p>
<pre><code>/**
 * 设备状态接口
 *
 * @author Xinling Jing
 * @date 2021-03-27 14:13
 */
public interface DeviceState {

    int UN_CHECK_STATE = 1;
    int CHECK_NO_NEW_STATE = 2;
    int CHECK_HAS_NEW_STATE = 3;
    int DOWNLOADING_STATE = 4;

    /**
     * 未检测
     */
    void unCheck();

    /**
     * 未检测到新版本
     */
    void checkNoNew();

    /**
     * 检测有新版本
     */
    void checkHasNew();

    /**
     * 下载中
     */
    void downloading();
}
</code></pre>
<p>状态接口实现类：</p>
<pre><code>/**
 * 设备状态接口实现类
 *
 * @author Xinling Jing
 * @date 2021-03-27 14:15
 */
public class DeviceStateImpl implements DeviceState {

    /**
     * 设备当前状态
     */
    private int state;

    public DeviceStateImpl(int state) {
        this.state = state;
    }

    @Override
    public void unCheck() {
        switch (state) {
            case UN_CHECK_STATE:
                // do nothing
                System.out.println(&quot;未检测&quot;);
                break;
            case CHECK_NO_NEW_STATE:
                // do nothing
                System.out.println(&quot;检测无新版本 -X-&gt; 未检测&quot;);
                break;
            case CHECK_HAS_NEW_STATE:
                // do nothing
                System.out.println(&quot;检测有新版本 -X-&gt; 未检测&quot;);
                break;
            case DOWNLOADING_STATE:
                // do nothing
                System.out.println(&quot;下载中 -X-&gt; 未检测&quot;);
                break;
            default:
                break;
        }
    }

    @Override
    public void checkNoNew() {
        switch (state) {
            case UN_CHECK_STATE:
                System.out.println(&quot;未检测 -&gt; 检测无新版本&quot;);
                this.state = CHECK_NO_NEW_STATE;
                break;
            case CHECK_NO_NEW_STATE:
                // do nothing
                System.out.println(&quot;检测无新版本&quot;);
                break;
            case CHECK_HAS_NEW_STATE:
                // do nothing
                System.out.println(&quot;检测有新版本 -X-&gt; 检测无新版本&quot;);
                break;
            case DOWNLOADING_STATE:
                System.out.println(&quot;下载中 -&gt; 检测无新版本&quot;);
                state = CHECK_NO_NEW_STATE;
                break;
            default:
                break;
        }
    }

    @Override
    public void checkHasNew() {
        switch (state) {
            case UN_CHECK_STATE:
                System.out.println(&quot;未检测 -&gt; 检测有新版本&quot;);
                this.state = CHECK_HAS_NEW_STATE;
                break;
            case CHECK_NO_NEW_STATE:
                System.out.println(&quot;检测无新版本 -&gt; 检测有新版本&quot;);
                this.state = CHECK_HAS_NEW_STATE;
                break;
            case CHECK_HAS_NEW_STATE:
                // do nothing
                System.out.println(&quot;检测有新版本&quot;);
                break;
            case DOWNLOADING_STATE:
                System.out.println(&quot;下载中 -&gt; 检测有新版本&quot;);
                state = CHECK_HAS_NEW_STATE;
                break;
            default:
                break;
        }
    }

    @Override
    public void downloading() {
        switch (state) {
            case UN_CHECK_STATE:
                // do nothing
                System.out.println(&quot;未检测 -X-&gt; 下载中&quot;);
                break;
            case CHECK_NO_NEW_STATE:
                // do nothing
                System.out.println(&quot;检测无新版本 -X-&gt; 下载中&quot;);
                break;
            case CHECK_HAS_NEW_STATE:
                System.out.println(&quot;检测有新版本 -&gt; 下载中&quot;);
                state = DOWNLOADING_STATE;
                break;
            case DOWNLOADING_STATE:
                // do nothing
                System.out.println(&quot;下载中&quot;);
                break;
            default:
                break;
        }
    }
}
</code></pre>
<p>测试：</p>
<pre><code>/**
 * 非状态模式下的状态扭转
 *
 * @author Xinling Jing
 * @date 2021-03-27 14:08
 */
public class Client {

    public static void main(String[] args) {

        // 设置初使状态为未检测
        DeviceState deviceState = new DeviceStateImpl(DeviceState.UN_CHECK_STATE);

        // 设备开始上报自身状态
        // 过渡到检测无新版本状态
        deviceState.checkNoNew();

        // 过渡到检测有新版本状态
        deviceState.checkHasNew();

        // 过渡到未检测状态（应该过渡失败）
        deviceState.unCheck();

        // 过渡到下载中状态
        deviceState.downloading();
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>未检测 -&gt; 检测无新版本
检测无新版本 -&gt; 检测有新版本
检测有新版本 -X-&gt; 未检测
检测有新版本 -&gt; 下载中
</code></pre>
<p>重点便在于上面的状态实现类 DeviceStateImpl，该类定义了设备能否从当前状态转换为设备上报的最新状态。举例说：设备当前状态为检测有新版本，如果设备上报最新状态为下载中，则将设备当前状态切换成下载中，并处理相关的业务逻辑。为了示例简单，此处用打印输出省去了相关的业务处理。</p>
<p>显而易见，上面的实现方式存在如下缺点：</p>
<ul>
<li>所有业务逻辑都集中在 DeviceStateImpl 类中，不易维护</li>
<li>存在大量 switch 或 if 判断，代码臃肿</li>
<li>当产品要求增加状态时，需修改 DeviceState 接口增加方法，DeviceStateImpl 增加对应方法实现，同时，对于每个方法中的 switch 都需要增加对应的 case 或 if 判断。如随着公司业务的发展，需要定义更多的状态，就可能演变成下图这种情况：<br>
<img src="http://image.kuranado.com/blog/1616848145.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></li>
</ul>
<p>这。。。代码每次修改起来简直是一场噩梦！<br>
<img src="http://image.kuranado.com/blog/1616848154.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></p>
<p>为了解决上述问题，我们需要引入状态模式</p>
<blockquote>
<p>当一个对象内在状态改变时，状态的变更引起了行为的变更，从外部看起来就好像这个对象对应的类发生了改变一样</p>
</blockquote>
<h2 id="状态模式各个角色">状态模式各个角色</h2>
<h3 id="state-抽象状态角色">State 抽象状态角色</h3>
<ul>
<li>接口或者是抽象类，负责定义状态</li>
<li>封装上下文对象，通过上下文对象实现状态切换</li>
</ul>
<h3 id="concretestate-具体状态角色">ConcreteState 具体状态角色</h3>
<ul>
<li>继承抽象状态角色（或实现抽象状态接口）</li>
<li>定义本状态要做哪些事情，以及本状态如何<strong>过渡</strong>到其它状态</li>
</ul>
<h3 id="statecontext-上下文对象">StateContext 上下文对象</h3>
<ul>
<li>定义客户端需要的接口</li>
<li>负责具体状态的切换</li>
</ul>
<p>状态模式结构：<br>
<img src="http://image.kuranado.com/blog/1616848164.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></p>
<h2 id="实战">实战</h2>
<h3 id="设备状态抽象类">设备状态抽象类</h3>
<pre><code>/**
 * @version 1.0.0
 * @author: Xinling Jing
 * @date: 2021-03-16 22:25
 */
public abstract class DeviceState {

    protected StateContext stateContext;

    public void setStateContext(StateContext stateContext) {
        this.stateContext = stateContext;
    }

    /**
     * 未检测
     */
    public abstract void unCheck();

    /**
     * 未检测到新版本
     */
    public abstract void checkNoNew();

    /**
     * 检测有新版本
     */
    public abstract void checkHasNew();

    /**
     * 下载中
     */
    public abstract void downloading();

}
</code></pre>
<p>设备状态抽象类持有状态上下文（StateContext）引用，以便具体子类可以使用 StateContext 对象更新状态。<br>
<strong>小 Tip：</strong><br>
此处也可以把 StateContext 从 DeviceState 抽象类中拿走，通过方法参数将 StateContext 对象传递给子类使用：</p>
<pre><code>public abstract class DeviceState {

    /**
     * 未检测
     */
    public abstract void unCheck(StateContext stateContext);

    /**
     * 未检测到新版本
     */
    public abstract void checkNoNew(StateContext stateContext);

    /**
     * 检测有新版本
     */
    public abstract void checkHasNew(StateContext stateContext);

    /**
     * 下载中
     */
    public abstract void downloading(StateContext stateContext);

}
</code></pre>
<h3 id="设备状态上下文">设备状态上下文</h3>
<pre><code>/**
 * @version 1.0.0
 * @author: Xinling Jing
 * @date: 2021-03-16 22:26
 */
public class StateContext {

    public final static DeviceState UN_CHECK_STATE = new UnCheckState();
    public final static DeviceState CHECK_NO_NEW_STATE = new CheckNoNewState();
    public final static DeviceState CHECK_HAS_NEW_STATE = new CheckHasNewState();
    public final static DeviceState DOWNLOADING_STATE = new DownloadingState();

    private DeviceState deviceState;

    public void setDeviceState(DeviceState deviceState) {
        this.deviceState = deviceState;
        this.deviceState.setStateContext(this);
    }

    public void unCheck() {
        deviceState.unCheck();
    }

    public void checkNoNew() {
        deviceState.checkNoNew();
    }

    public void checkHasNew() {
        deviceState.checkHasNew();
    }

    public void downloading() {
        deviceState.downloading();
    }
}
</code></pre>
<p>状态上下文提供了相关状态切换方法，也就是状态切换的入口。同时，<strong>状态上下文持有设备状态引用，以通过具体的设备状态子类完成状态切换</strong>（看到这里，会发现状态模式的结构和策略模式如出一辙，策略模式也是策略上下文持有策略接口）。</p>
<p>上面提到 DeviceState 中可以将 StateContext 通过方法参数的形式传递给子类使用，与之对应，StateContext 需要改造如下，具体使用哪种方式大家自己斟酌：</p>
<pre><code>public class StateContext {

    public final static DeviceState UN_CHECK_STATE = new UnCheckState();
    public final static DeviceState CHECK_NO_NEW_STATE = new CheckNoNewState();
    public final static DeviceState CHECK_HAS_NEW_STATE = new CheckHasNewState();
    public final static DeviceState DOWNLOADING_STATE = new DownloadingState();

    private DeviceState deviceState;

    public void setDeviceState(DeviceState deviceState) {
        this.deviceState = deviceState;
    }

    public void unCheck() {
        deviceState.unCheck(this);
    }

    public void checkNoNew() {
        deviceState.checkNoNew(this);
    }

    public void checkHasNew() {
        deviceState.checkHasNew(this);
    }

    public void downloading() {
        deviceState.downloading(this);
    }
}
</code></pre>
<h3 id="具体设备状态类">具体设备状态类</h3>
<p>具体的状态子类，实际上就是将原先 switch 或 if 的代码拆到具体的类中<br>
未检测状态：</p>
<pre><code>/**
 * @version 1.0.0
 * @author: Xinling Jing
 * @date: 2021-03-16 22:26
 */
public class UnCheckState extends DeviceState {

    @Override
    public void unCheck() {
        // do nothing
        System.out.println(&quot;未检测&quot;);
    }

    @Override
    public void checkNoNew() {
        System.out.println(&quot;未检测 -&gt; 检测无新版本&quot;);
        super.stateContext.setDeviceState(StateContext.UN_CHECK_STATE);
    }

    @Override
    public void checkHasNew() {
        System.out.println(&quot;未检测 -&gt; 检测有新版本&quot;);
        stateContext.setDeviceState(StateContext.CHECK_HAS_NEW_STATE);
    }

    @Override
    public void downloading() {
        // do nothing
        System.out.println(&quot;未检测 -X-&gt; 下载中&quot;);
    }
}
</code></pre>
<p>检测无新版本状态：</p>
<pre><code>/**
 * @version 1.0.0
 * @author: Xinling Jing
 * @date: 2021-03-16 22:26
 */
public class CheckNoNewState extends DeviceState {

    @Override
    public void unCheck() {
        // do nothing
        System.out.println(&quot;检测无新版本 -X-&gt; 未检测&quot;);
    }

    @Override
    public void checkNoNew() {
        // do nothing
        System.out.println(&quot;检测无新版本&quot;);
    }

    @Override
    public void checkHasNew() {
        System.out.println(&quot;检测无新版本 -&gt; 检测有新版本&quot;);
        stateContext.setDeviceState(StateContext.CHECK_HAS_NEW_STATE);
    }

    @Override
    public void downloading() {
        // do nothing
        System.out.println(&quot;检测无新版本 -X-&gt; 检测有新版本&quot;);
    }
}
</code></pre>
<p>检测有新版本状态：</p>
<pre><code>/**
 * @version 1.0.0
 * @author: Xinling Jing
 * @date: 2021-03-16 22:26
 */
public class CheckHasNewState extends DeviceState {

    @Override
    public void unCheck() {
        // do nothing
        System.out.println(&quot;检测有新版本 -X-&gt; 未检测&quot;);
    }

    @Override
    public void checkNoNew() {
        System.out.println(&quot;检测有新版本 -X-&gt; 检测无新版本&quot;);
        stateContext.setDeviceState(StateContext.CHECK_NO_NEW_STATE);
    }

    @Override
    public void checkHasNew() {
        // do nothing
        System.out.println(&quot;检测有新版本&quot;);
    }

    @Override
    public void downloading() {
        System.out.println(&quot;检测有新版本 -&gt; 下载中&quot;);
        stateContext.setDeviceState(StateContext.DOWNLOADING_STATE);
    }
}
</code></pre>
<p>下载中状态：</p>
<pre><code>/**
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-03-15 16:02
 */
public class DownloadingState extends DeviceState {

    @Override
    public void unCheck() {
        // do nothing
        System.out.println(&quot;下载中 -X-&gt; 未检测&quot;);
    }

    @Override
    public void checkNoNew() {
        System.out.println(&quot;下载中 -&gt; 检测无新版本&quot;);
        stateContext.setDeviceState(StateContext.CHECK_NO_NEW_STATE);
    }

    @Override
    public void checkHasNew() {
        System.out.println(&quot;下载中 -&gt; 检测有新版本&quot;);
        stateContext.setDeviceState(StateContext.CHECK_HAS_NEW_STATE);
    }

    @Override
    public void downloading() {
        // do nothing
        System.out.println(&quot;下载中&quot;);
    }

}
</code></pre>
<h3 id="客户端测试">客户端测试</h3>
<pre><code>/**
 * @version 1.0.0
 * @author: Xinling Jing
 * @date: 2021-03-16 22:24
 */
public class Client {

    public static void main(String[] args) {
        // 初使状态为未检测
        //StateContext stateContext = new StateContext(new UnCheckState());
        StateContext stateContext = new StateContext();

        // 设置初使状态
        stateContext.setDeviceState(StateContext.UN_CHECK_STATE);

        // 过渡到检测无新版本状态
        stateContext.checkNoNew();

        // 过渡到检测有新版本状态
        stateContext.checkHasNew();

        // 过渡到未检测状态（应该过渡失败）
        stateContext.unCheck();

        // 过渡到下载中状态
        stateContext.downloading();
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>未检测 -&gt; 检测无新版本
未检测 -&gt; 检测有新版本
检测有新版本 -X-&gt; 未检测
检测有新版本 -&gt; 下载中
</code></pre>
<p>到此我们就通过状态模式完成了代码改造，类图如下：<br>
<img src="http://image.kuranado.com/blog/1616848179.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></p>
<p>这时候可能就有人要问了，如果要增加状态，那不还是要修改代码吗？？？<br>
<img src="http://image.kuranado.com/blog/1616848190.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></p>
<p>说的没错，如果要增加状态，修改代码确实是不可避免的。但不使用状态模式的情况下，修改代码需要修改原有方法下的 switch 或 if 判断；使用状态模式的情况下，只需要增加对应的状态子类以及增加相应的方法就可以了，虽然在增加方法时，也需要改动原有的状态类，但原有方法并不需要做任何改动，也就是说，状态模式符合<strong>开闭原则</strong>。</p>
<h2 id="状态模式缺点">状态模式缺点</h2>
<p>每增加一种状态，就需要增加一个状态类，类膨胀也会让代码看起来更杂乱。常见的解决方法是将状态全部存到数据库中，比如工作流框架 Activiti 就是将状态存入数据库中，然后根据状态执行相应等操作。</p>
<h2 id="状态模式与状态机">状态模式与状态机</h2>
<p>说完了状态模式，就不得不提一下有限状态机。<br>
状态模式需要针对业务场景编写具体代码，而状态机则更通用，只需要引入状态机框架，然后定义好状态和事件就可以做到状态扭转了，比自己手写状态模式更快捷。Spring 也提供了状态机实现，引入相关依赖，就可以快速开发业务代码。<a href="https://spring.io/projects/spring-statemachine#learn">Spring StateMachine 文档</a>。在这里也比较推荐大家使用状态机。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://www.360doc.com/content/17/1113/19/15077656_703518498.shtml">有限状态机与状态模式</a></li>
<li>《设计模式之禅》</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[外观模式.md]]></title>
        <id>http://blog.kuranado.com/post/wai-guan-mo-shi-md/</id>
        <link href="http://blog.kuranado.com/post/wai-guan-mo-shi-md/">
        </link>
        <updated>2021-02-20T00:21:54.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在看《研磨设计模式》，看到外观模式时觉得在 23 种设计模式中应该算得上最简单的模式了。本文以香油制作流程为例讲解外观模式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在看《研磨设计模式》，看到外观模式时觉得在 23 种设计模式中应该算得上最简单的模式了。本文以香油制作流程为例讲解外观模式。</p>
<!-- more -->
<p>[TOC]</p>
<p>首先来看看传统的香油制作办法：</p>
<ol>
<li>淘洗芝麻，去除芝麻里的沙土</li>
<li>将芝麻放到旋转的炒锅里炒至出烟，约 40 分钟左右</li>
<li>炒好的芝麻中筛选掉劣质的芝麻</li>
<li>芝麻放到石磨上进行磨酱，磨好的酱倒进大锅里</li>
<li>将开水倒进有香油酱的大锅里进行搅拌出油</li>
<li>把香油装在桶里进行沉淀，准备出售</li>
</ol>
<p>总结一下上面的制作流程，主要流程就是炒芝麻 -&gt; 磨酱 -&gt; 搅拌，用程序表示如下：</p>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2018/8/20 0020 下午 6:54
 */
public interface SesameOil {

    void execute();
}
</code></pre>
<pre><code>/**
 * 炒芝麻
 * @Author: Xinling Jing
 * @Date: 2018/8/20 0020 下午 6:54
 */
public class Fry implements SesameOil {

    @Override
    public void execute() {
        System.out.println(&quot;将芝麻放到旋转的炒锅里炒至出烟，约 40 分钟左右&quot;);
    }
}
</code></pre>
<pre><code>/**
 * 磨酱
 * @Author: Xinling Jing
 * @Date: 2018/8/20 0020 下午 6:55
 */
public class Grind implements SesameOil {

    @Override
    public void execute() {
        System.out.println(&quot;芝麻放到石墨上进行磨酱，磨好的酱倒进大锅里&quot;);
    }
}
</code></pre>
<pre><code>/**
 * 搅拌
 * @Author: Xinling Jing
 * @Date: 2018/8/20 0020 下午 6:56
 */
public class Stir implements SesameOil {

    @Override
    public void execute() {
        System.out.println(&quot;将开水倒进有香油酱的大锅里进行搅拌出油&quot;);
    }
}
</code></pre>
<p>客户端调用如下：</p>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2018/8/20 0020 下午 6:54
 */
public class Client {

    public static void main(String[] args) {
        new Fry().execute();
        new Grind().execute();
        new Stir().execute();
    }
}
</code></pre>
<p>程序打印结果：</p>
<pre><code>将芝麻放到旋转的炒锅里炒上 40 分钟，直至芝麻出烟
芝麻放到石墨上进行磨酱，磨好的酱倒进大锅里
将开水倒进有香油酱的大锅里进行搅拌出油
</code></pre>
<p>但对于一个外行来说自己制作香油还需要了解这么多道工序显然是非常麻烦的，如果有一台机器只要把芝麻倒进机器中，就可以自动制作出香油就好了，此时外观模式就应运而生了</p>
<p>我们定义一个 <code>Facade</code> 类如下：</p>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2018/8/21 0021 上午 10:53
 */
public class Facade {

    public void powerOn() {
        new Fry().execute();
        new Grind().execute();
        new Stir().execute();
    }
}
</code></pre>
<p>该 <code>Facade</code> 类就是一个外观类，所谓外观类就是对复杂的业务逻辑进行封装，外观类与客户端直接交互使客户端只需要调用外观类的特定方法就能完成一系列复杂的业务操作，而客户端完全不需要知道外观类的执行过程。换句话说，这里的外观类就是一台可以自动制作香油的机器，只要按下电源键，这台机器就可以代替人工自动进行炒芝麻、磨酱和搅拌等一系列工序，而自己完全不需要知道这台机器是如何工作的</p>
<p>客户端调用如下：</p>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2018/8/20 0020 下午 6:54
 */
public class Client {

    public static void main(String[] args) {
        // 打开开关开始制作香油
        new Facade().powerOn();
    }
}
</code></pre>
<p>此时结构如图：</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1613780620.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>到此相信你已经完全了解外观模式了，是不是很简单？下面对外观模式做一个简单的总结</p>
<h2 id="总结">总结</h2>
<h3 id="外观模式的目的">外观模式的目的</h3>
<ul>
<li>外观模式的目的不是给子系统添加新的功能接口，而是为了让外部减少与子系统内多个模块的交互，松散耦合，让外部能够更简单的使用子系统。虽然完全可以在外观类中增加新功能，但不建议这么做，因为外观模式就是用来对已有的功能进行组合、包装，而不是用来添加新的实现</li>
</ul>
<h3 id="外观模式调用">外观模式调用</h3>
<ul>
<li>编写了外观模式并不代表只能使用外观模式，当只需要使用外观模式封装的其中某个模块时，完全可以单独调用该模块，而不需要经过外观模式</li>
</ul>
<h3 id="外观模式的实现">外观模式的实现</h3>
<ul>
<li>将外观类中的方法实现为静态方法，将外观类当成一个辅助工具类使用</li>
</ul>
<pre><code>public class Facade {

    private Facade() {}

    public static void powerOn() {
        new Fry().execute();
        new Grind().execute();
        new Stir().execute();
    }
}
</code></pre>
<h3 id="外观模式的优缺点">外观模式的优缺点</h3>
<ul>
<li>松散耦合：外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块更容易扩展和维护</li>
<li>简单易用：外观模式让子系统更加易用，客户端不需要了解子系统的内部实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观模式交互就可以了，相当于外观类为客户端使用子系统提供了一条龙服务</li>
<li>更好地划分访问的层次：合理的使用外观模式，可以更好的划分子系统的访问层次，把需要暴露给外部的功能集中到外观中，既方便客户端调用，也隐藏了内部的实现细节</li>
<li>过多或者不合理的使用外观模式容易让人迷惑，不知是使用外观模式好还是直接调用模块好</li>
</ul>
<h3 id="对设计原则的体现">对设计原则的体现</h3>
<p>外观模式是<code>迪米特法则</code>（也称最少知识原则）的体现，即不和陌生人说话，只和你的直接朋友通信</p>
<h3 id="相关模式">相关模式</h3>
<h4 id="外观模式与单例模式">外观模式与单例模式</h4>
<p>通常一个子系统只需要一个外观实例，所以可以将外观模式和单例模式组合，将 Facade 类实现成为单例。当然前面介绍的将 Facade 类的方法设置为 <code>static</code>，并将 Facade 的构造方法私有化也可以当作为简单的单例</p>
<h2 id="参考">参考</h2>
<ul>
<li>《研磨设计模式》</li>
</ul>
<h2 id="源码">源码</h2>
<ul>
<li><a href="https://github.com/KURANADO2/DesignPatterns">https://github.com/KURANADO2/DesignPatterns</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[策略模式.md]]></title>
        <id>http://blog.kuranado.com/post/ce-lue-mo-shi/</id>
        <link href="http://blog.kuranado.com/post/ce-lue-mo-shi/">
        </link>
        <updated>2021-02-19T09:20:04.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<p>针对不同的业务情况，使用 if-else 做不同的处理，相信很多人都见过或写过类似下面这样的代码：</p>
<pre><code>import lombok.Getter;

/**
 * 计算价格类
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 16:28
 */
public class Price {

    /**
     * 根据用户类型计算商品折扣后的价格
     *
     * @param originalPrice 商品原价
     * @param customType 用户类型
     * @return 折扣后的价格
     */
    public double calcDiscountPrice(double originalPrice, CustomType customType) {

        if (CustomType.NORMAL.equals(customType)) {
            // 普通客户原价
            return originalPrice;
        } else if (CustomType.POOR_MONTH_VIP.equals(customType)) {
            // 活动送的月度会员打 95 折
            return originalPrice * 0.95;
        } else if (CustomType.MONTH_VIP.equals(customType)) {
            // 月度会员打 9 折
            return originalPrice * 0.9;
        } else if (CustomType.YEAR_VIP.equals(customType)) {
            // 年度会员打 8 折
            return originalPrice * 0.8;
        }
        // 其它类型客户原价
        return originalPrice;
    }

    @Getter
    enum CustomType {

        /**
         * 普通客户
         */
        NORMAL(&quot;普通用户&quot;),
        /**
         * 活动送的会员
         */
        POOR_MONTH_VIP(&quot;活动送的月度会员&quot;),
        /**
         * 月度会员
         */
        MONTH_VIP(&quot;月度会员&quot;),
        /**
         * 年度会员
         */
        YEAR_VIP(&quot;年度会员&quot;);

        private final String type;

        CustomType(String type) {
            this.type = type;
        }
    }

    public static void main(String[] args) {
        double originalPrice = 100;
        Price price = new Price();
        double result = price.calcDiscountPrice(originalPrice, CustomType.NORMAL);
        System.out.println(&quot;普通用户折扣后价格：&quot; + result);

        result = price.calcDiscountPrice(originalPrice, CustomType.POOR_MONTH_VIP);
        System.out.println(&quot;活动送的月度会员折扣后价格：&quot; + result);

        result = price.calcDiscountPrice(originalPrice, CustomType.MONTH_VIP);
        System.out.println(&quot;月度会员折扣后价格：&quot; + result);

        result = price.calcDiscountPrice(originalPrice, CustomType.YEAR_VIP);
        System.out.println(&quot;年度会员折扣后价格：&quot; + result);
    }
}
</code></pre>
<p>输出：</p>
<pre><code>普通用户折扣后价格：100.0
活动送的月度会员折扣后价格：95.0
月度会员折扣后价格：90.0
年度会员折扣后价格：80.0
</code></pre>
<p>这只是一个非常简单的例子，实际工作场景中，针对十几种情况，对应连续使用十几个 if-else 做判断，也正是笔者所在公司当前所采用的代码形式。结构丑陋，不易维护是其最大的缺点，针对这种情况，使用策略模式优化是一个很好的选择。<br>
<img src="http://image.kuranado.com/blog/1613726575.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
<img src="http://image.kuranado.com/blog/1613726585.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></p>
<h2 id="策略模式-模版代码">策略模式-模版代码</h2>
<blockquote>
<p>策略模式的思想就是：<strong>每种 if-else 判断都抽取成一个类，在类中实现具体的算法策略。然后定义一个策略上下文类，该上下文类可以持有具体的算法策略，最后再由客户端选择具体的算法策略，交给上下文类处理即可</strong>，总结成如下四步：</p>
</blockquote>
<ol>
<li>创建策略接口</li>
<li>创建若干个具体策略算法类，实现策略接口</li>
<li>创建策略上下文类，用于持有具体的策略算法类</li>
<li>客户端选择具体的策略算法，传给上下文处理</li>
</ol>
<p>同样是文章开头根据客户类型计算折扣价格的例子，使用策略模式改造过程如下</p>
<h3 id="策略接口">策略接口</h3>
<pre><code>/**
 * 策略接口
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 16:25
 */
public interface Strategy {

    /**
     * 计算折扣后的价格
     *
     * @param originalPrice 原价
     * @return 折扣后价格
     */
    double calcDiscountPrice(double originalPrice);
}
</code></pre>
<h3 id="具体的策略算法实现类">具体的策略算法实现类</h3>
<p>每个具体的策略类都对应一个原来的 if-else 判断</p>
<pre><code>/**
 * 普通会员的折扣策略
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 19:29
 */
public class NormalStrategy implements Strategy {

    @Override
    public double calcDiscountPrice(double originalPrice) {
        return originalPrice;
    }
}
</code></pre>
<pre><code>/**
 * 活动送的月度会员的折扣策略
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 19:30
 */
public class PoorMonthVipStrategy implements Strategy {

    @Override
    public double calcDiscountPrice(double originalPrice) {
        return originalPrice * 0.95;
    }
}
</code></pre>
<pre><code>/**
 * 月度会员的折扣策略
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 19:30
 */
public class MonthVipStrategy implements Strategy {

    @Override
    public double calcDiscountPrice(double originalPrice) {
        return originalPrice * 0.9;
    }
}
</code></pre>
<pre><code>/**
 * 年度会员的折扣策略
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 19:31
 */
public class YearVipStrategy implements Strategy {

    @Override
    public double calcDiscountPrice(double originalPrice) {
        return originalPrice * 0.8;
    }
}
</code></pre>
<p>如果后面还有其他种类的会员折扣策略，只需要照葫芦画瓢，再创建一个策略实现类即可，其他已有的策略实现类，策略接口，策略上下文都不需要做任何改动</p>
<h3 id="策略上下文">策略上下文</h3>
<pre><code>/**
 * 策略上下文
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 19:36
 */
public class StrategyContext {

    private final Strategy strategy;

    public StrategyContext(Strategy strategy) {
        this.strategy = strategy;
    }

    public double calcPrice(double originalPrice) {
        return this.strategy.calcDiscountPrice(originalPrice);
    }
}
</code></pre>
<h3 id="客户端">客户端</h3>
<pre><code>/**
 * 客户端测试
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 16:26
 */
public class Client {

    public static void main(String[] args) {

        Strategy strategy = new NormalStrategy();
        StrategyContext strategyContext = new StrategyContext(strategy);
        double result = strategyContext.calcPrice(100);
        System.out.println(&quot;普通用户折扣后价格：&quot; + result);

        strategy = new PoorMonthVipStrategy();
        strategyContext = new StrategyContext(strategy);
        result = strategyContext.calcPrice(100);
        System.out.println(&quot;活动送的月度会员折扣后价格：&quot; + result);

        strategy = new MonthVipStrategy();
        strategyContext = new StrategyContext(strategy);
        result = strategyContext.calcPrice(100);
        System.out.println(&quot;月度会员折扣后价格：&quot; + result);

        strategy = new YearVipStrategy();
        strategyContext = new StrategyContext(strategy);
        result = strategyContext.calcPrice(100);
        System.out.println(&quot;年度会员折扣后价格：&quot; + result);
    }
}
</code></pre>
<p>输出：</p>
<pre><code>普通用户折扣后价格：100.0
活动送的月度会员折扣后价格：95.0
月度会员折扣后价格：90.0
年度会员折扣后价格：80.0
</code></pre>
<h3 id="结构图">结构图</h3>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1613726599.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>以上就是最基本的策略模式</p>
<h2 id="策略模式-实现公共功能">策略模式-实现公共功能</h2>
<p>如果不同的策略算法存在公共功能，如对于上面的例子，如果要求不管那种类型的会员，在计算折扣价格钱，都增加消费积分，积分数量等于原价，则可以通过以下三种方式抽取公共功能：</p>
<ol>
<li>在策略上下文类中实现公共功能</li>
<li>将策略接口改成抽象类，在策略抽象类中实现公共功能</li>
<li>定义一个抽象类实现策略接口，在该抽象类中实现公共功能，然后让所有的策略算法类不再实现策略接口，转为继承该抽象类</li>
</ol>
<p>上面三种方法逐一示例如下：</p>
<h3 id="方法一策略上下文类中实现公共功能">方法一：策略上下文类中实现公共功能</h3>
<p>StrategyContext 类修改如下：</p>
<pre><code>/**
 * 策略上下文
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 19:36
 */
public class StrategyContext {

    private final Strategy strategy;

    public StrategyContext(Strategy strategy) {
        this.strategy = strategy;
    }

    public double calcPrice(double originalPrice) {
        System.out.println(&quot;增加消费积分：&quot; + originalPrice);
        return this.strategy.calcDiscountPrice(originalPrice);
    }
}
</code></pre>
<p>执行客户端，输出结果：</p>
<pre><code>增加消费积分：100.0
普通用户折扣后价格：100.0
增加消费积分：100.0
活动送的月度会员折扣后价格：95.0
增加消费积分：100.0
月度会员折扣后价格：90.0
增加消费积分：100.0
年度会员折扣后价格：80.0
</code></pre>
<h3 id="方法二策略接口改成抽象类">方法二：策略接口改成抽象类</h3>
<p>Strategy 接口该成抽象类：</p>
<pre><code>/**
 * 策略抽象类
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 16:25
 */
public abstract class Strategy {

    protected double calcPrice(double originalPrice) {
        System.out.println(&quot;增加消费积分：&quot; + originalPrice);
        return calcDiscountPrice(originalPrice);
    }

    /**
     * 计算折扣后的价格
     *
     * @param originalPrice 原价
     * @return 折扣后价格
     */
    protected abstract double calcDiscountPrice(double originalPrice);
}
</code></pre>
<p>这里增加了一个 calcPrice 方法，用于处理公共逻辑，处理完成之后，再调用原来的 calcDiscountPrice 方法，这里的 calcDiscountPrice 被定义成抽象方法，子类继承 Strategy 抽象类时，需要实现该抽象方法。</p>
<p>各个算法策略实现类由实现 Strategy 接口改为继承 Strategy 抽象类，即将 <code>implements</code> 改为 <code>extends</code>，如普通会员折扣策略代码修改如下，其他策略算法实现类也是做同样处理，不再赘述：</p>
<pre><code>/**
 * 普通会员的折扣策略
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 19:29
 */
public class NormalStrategy extends Strategy {

    @Override
    public double calcDiscountPrice(double originalPrice) {
        return originalPrice;
    }
}
</code></pre>
<p>策略上下文类由调用 calcDiscountPrice 方法修改为调用 calcPrice 方法：</p>
<pre><code>/**
 * 策略上下文
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 19:36
 */
public class StrategyContext {

    private final Strategy strategy;

    public StrategyContext(Strategy strategy) {
        this.strategy = strategy;
    }

    public double calcPrice(double originalPrice) {
        return this.strategy.calcPrice(originalPrice);
    }
}
</code></pre>
<p>客户端无需做改动。执行客户端，输出结果和第一种方法完全一致</p>
<h3 id="方法三定义一个抽象类实现策略接口">方法三：定义一个抽象类实现策略接口</h3>
<p>这种方法其实就是模板方法模式（后续文章中会讲到）<br>
定义一个抽象类实现策略接口：</p>
<pre><code>/**
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-02-19 14:31
 */
public abstract class StrategyTemplate implements Strategy {

    @Override
    public double calcDiscountPrice(double originalPrice) {
        System.out.println(&quot;增加消费积分：&quot; + originalPrice);
        return calcPrice(originalPrice);
    }

    protected abstract double calcPrice(double originalPrice);
}
</code></pre>
<p>各个算法策略类由实现 Strategy 接口改为继承抽象类，以普通会员为例，其他策略算法类不再赘述：</p>
<pre><code>/**
 * 普通会员的折扣策略
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-01-28 19:29
 */
public class NormalStrategy extends StrategyTemplate {

    @Override
    public double calcPrice(double originalPrice) {
        return originalPrice;
    }
}
</code></pre>
<p>策略上下文类和客户端无需做任何改动。执行客户端，输出结果和第一种方法完全一致</p>
<h2 id="策略模式-参数传递">策略模式-参数传递</h2>
<p>实际业务中，往往不同算法策略需要的参数是不同的，这就导致在定义策略接口时，很难确定参数。<br>
举个🌰：如今出行有众多交通工具可供选择，一般的交通工具只要出示身份证即可，比如火车。下面就使用策略模式快速实现这个例子：</p>
<h3 id="策略类">策略类</h3>
<pre><code>/**
 * 交通工具策略
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-02-19 15:29
 */
public interface VehicleStrategy {

    void take(VehicleContext vehicleContext);
}
</code></pre>
<h3 id="上下文类">上下文类</h3>
<pre><code>import lombok.Getter;

/**
 * 交通工具上下文
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-02-19 15:30
 */
@Getter
public class VehicleContext {

    /**
     * 用户名
     */
    private final String username;
    /**
     * 身份证号
     */
    private final String idNo;
    /**
     * 起始地
     */
    private final String origin;
    /**
     * 目的地
     */
    private final String destination;

    private final VehicleStrategy vehicleStrategy;

    public VehicleContext(String username, String idNo, String origin, String destination,
        VehicleStrategy vehicleStrategy) {
        this.username = username;
        this.idNo = idNo;
        this.origin = origin;
        this.destination = destination;
        this.vehicleStrategy = vehicleStrategy;
    }

    public void take() {
        this.vehicleStrategy.take(this);
    }
}
</code></pre>
<p>这里通过上下文<strong>携带了一些参数，以让具体的策略实现类可以回调这些参数</strong>。</p>
<h3 id="火车策略实现类">火车策略实现类</h3>
<pre><code>/**
 * 火车策略
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-02-19 16:20
 */
public class TrainStrategy implements VehicleStrategy {

    @Override
    public void take(VehicleContext vehicleContext) {
        System.out.println(vehicleContext.getUsername() + &quot;使用身份证：&quot; + vehicleContext.getIdNo() + &quot; 乘火车从：&quot;
            + vehicleContext.getOrigin() + &quot;到：&quot; + vehicleContext.getDestination());
    }
}
</code></pre>
<h3 id="客户端-2">客户端</h3>
<pre><code>/**
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-02-19 16:11
 */
public class Client {

    public static void main(String[] args) {

        VehicleStrategy vehicleStrategy = new TrainStrategy();
        VehicleContext vehicleContext = new VehicleContext(&quot;林克&quot;, &quot;1001&quot;, &quot;上海&quot;, &quot;北京&quot;, vehicleStrategy);
        vehicleContext.take();
    }
}
</code></pre>
<p>客户端输出结果如下：</p>
<pre><code>林克使用身份证：1001 乘火车从：上海到：北京
</code></pre>
<h3 id="如何扩展">如何扩展？</h3>
<p>接下里，我们添加一个乘坐飞机的策略实现类，在添加之前，注意到乘坐飞机不仅需要出示身份证，而且还需要出示登机牌，但当前的上下文类并没有携带登机牌这个参数，那该怎么办呢？</p>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1613726619.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>解决方法有如下三个：</p>
<ol>
<li>直接在现有的上下文类中添加登机牌参数，并在构造方法中初始化该参数</li>
<li>再创建一个新的上下文类，让新上下文类继承原来的上下文类，在新上下文类中添加登机牌参数，并在构造方法中初始化该参数</li>
<li>在飞机策略实现类中添加登机牌参数，并在构造方法中初始化该参数</li>
</ol>
<p>接下来一一讲解这三种方法及其优缺点：</p>
<h4 id="方法一直接在现有的上下文类中添加参数">方法一：直接在现有的上下文类中添加参数</h4>
<p>需要修改现有的上下文类，违背开闭原则，直接 Pass</p>
<h4 id="方法二创建一个新的上下文类">方法二：创建一个新的上下文类</h4>
<p>创建新的上下文类：</p>
<pre><code>import lombok.Getter;

/**
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-02-19 16:33
 */
@Getter
public class VehicleContext2 extends VehicleContext {

    /**
     * 登机牌号
     */
    private final String boardingNo;

    public VehicleContext2(String username, String idNo, String origin, String destination,
        VehicleStrategy vehicleStrategy, String boardingNo) {
        super(username, idNo, origin, destination, vehicleStrategy);
        this.boardingNo = boardingNo;
    }
}
</code></pre>
<p>飞机策略类：</p>
<pre><code>/**
 * 飞机策略
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-02-19 16:30
 */
public class PlaneStrategy implements VehicleStrategy {

    @Override
    public void take(VehicleContext vehicleContext) {
        VehicleContext2 vehicleContext2 = (VehicleContext2) vehicleContext;
        System.out.println(vehicleContext.getUsername() + &quot;使用身份证：&quot; + vehicleContext.getIdNo() + &quot; 和登机牌：&quot;
            + vehicleContext2.getBoardingNo() + &quot; 乘飞机从：&quot; + vehicleContext.getOrigin() + &quot;到：&quot; + vehicleContext.getDestination());
    }
}
</code></pre>
<p>客户端：</p>
<pre><code>/**
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-02-19 16:11
 */
public class Client {

    public static void main(String[] args) {

        VehicleStrategy vehicleStrategy = new TrainStrategy();
        VehicleContext vehicleContext = new VehicleContext(&quot;林克&quot;, &quot;1001&quot;, &quot;上海&quot;, &quot;北京&quot;, vehicleStrategy);
        vehicleContext.take();

        vehicleStrategy = new PlaneStrategy();
        vehicleContext = new VehicleContext2(&quot;塞尔达&quot;, &quot;1002&quot;, &quot;浦东国际机场&quot;, &quot;日本成田机场&quot;, vehicleStrategy, &quot;1234&quot;);
        vehicleContext.take();
    }
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>林克使用身份证：1001 乘火车从：上海到：北京
塞尔达使用身份证：1002 和登机牌：1234 乘飞机从：浦东国际机场到：日本成田机场
</code></pre>
<h4 id="方法三在飞机策略实现类中添加参数">方法三：在飞机策略实现类中添加参数</h4>
<p>飞机策略类：</p>
<pre><code>/**
 * 飞机策略
 *
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-02-19 16:30
 */
public class PlaneStrategy implements VehicleStrategy {

    /**
     * 登机牌号
     */
    private final String boardingNo;

    public PlaneStrategy(String boardingNo) {
        this.boardingNo = boardingNo;
    }

    @Override
    public void take(VehicleContext vehicleContext) {
        System.out.println(vehicleContext.getUsername() + &quot;使用身份证：&quot; + vehicleContext.getIdNo() + &quot; 和登机牌：&quot;
            + this.boardingNo + &quot; 乘飞机从：&quot; + vehicleContext.getOrigin() + &quot;到：&quot; + vehicleContext.getDestination());
    }
}
</code></pre>
<p>客户端：</p>
<pre><code>/**
 * @author Xinling Jing
 * @version 1.0.0
 * @date 2021-02-19 16:11
 */
public class Client {

    public static void main(String[] args) {

        VehicleStrategy vehicleStrategy = new TrainStrategy();
        VehicleContext vehicleContext = new VehicleContext(&quot;林克&quot;, &quot;1001&quot;, &quot;上海&quot;, &quot;北京&quot;, vehicleStrategy);
        vehicleContext.take();

        vehicleStrategy = new PlaneStrategy(&quot;1234&quot;);
        vehicleContext = new VehicleContext(&quot;塞尔达&quot;, &quot;1002&quot;, &quot;浦东国际机场&quot;, &quot;日本成田机场&quot;, vehicleStrategy);
        vehicleContext.take();
    }
}
</code></pre>
<p>输出结果和方法二相同</p>
<p>对比方法二和方法三，比较如下：</p>
<ul>
<li>方法二：使用了继承，如果后续添加的新算法较多，容易形成复杂的上下文对象层次</li>
<li>方法三：实现简单，但策略实现类但一部分数据来自于上下文，一部分来自于自身，导致和其他策略实现类风格不统一</li>
</ul>
<h2 id="总结">总结</h2>
<ul>
<li>策略模式的重点不是如何来实现算法，而是如何组织算法，让程序结构更灵活，具有更好的维护和扩展性</li>
<li>因为需要客户端选择具体的算法策略，所以需要客户端对策略作出正确选择</li>
<li>需要把每种算法策略都封装成一个类，如果策略较多，则类的数目也会很可观</li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>《研磨设计模式》</li>
</ul>
<h2 id="源码">源码</h2>
<ul>
<li><a href="https://github.com/KURANADO2/DesignPatterns">https://github.com/KURANADO2/DesignPatterns</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[观察者模式.md]]></title>
        <id>http://blog.kuranado.com/post/guan-cha-zhe-mo-shi/</id>
        <link href="http://blog.kuranado.com/post/guan-cha-zhe-mo-shi/">
        </link>
        <updated>2021-01-28T07:01:39.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="什么是观察者模式">什么是观察者模式</h2>
<blockquote>
<p>观察者模式又称订阅模式，用于定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖它的对象都将得到通知并被自动更新</p>
</blockquote>
<h2 id="观察者模式结构">观察者模式结构</h2>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1611817500.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="观察者模式各个角色作用">观察者模式各个角色作用</h2>
<ul>
<li>Subject:观察者所观察的<strong>目标</strong>，通常具有如下功能
<ul>
<li>一个目标可以被多个观察者观察</li>
<li>目标负责对观察者的注册和退订维护</li>
<li>当目标的状态发生改变时，目标负责通知所已注册的、有效的观察者</li>
</ul>
</li>
<li>Observer:定义观察的接口，提供收到目标通知时对应的更新方法，这个更新方法进行相应的业务处理，可以在这个方法里回调目标对象，以获取目标对象的数据</li>
<li>ConcreateSubject:具体的目标实现对象，用来维护目标状态，当目标对象的状态发生改变时，通知所有已注册的、有效的观察者，让观察者执行相应的处理</li>
<li>ConcreateObserver:观察者的具体实现对象，用来接收目标通知，并进行相应的后续处理</li>
</ul>
<h2 id="模板代码">模板代码</h2>
<h3 id="subject">Subject</h3>
<pre><code>import java.util.ArrayList;
import java.util.List;

/**
 * 目标对象，负责注册、删除和通知观察者
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-22 21:06
 */
public class Subject {

    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();

    /**
     * 注册观察者对象
     * @param observer 观察者对象
     */
    public void register(Observer observer) {
        observers.add(observer);
    }

    /**
     * 删除观察者对象
     * @param observer 观察者对象
     */
    public void delete(Observer observer) {
        observers.remove(observer);
    }

    /**
     * 通知所有已注册观察者
     */
    public void notifyObservers() {
        observers.forEach(observer -&gt; observer.update(this));
    }
}
</code></pre>
<h3 id="observer">Observer</h3>
<pre><code>/**
 * 观察者接口，定义一个更新的接口给那些在目标发生改变时被通知的对象
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-22 21:07
 */
public interface Observer {

    /**
     * 用于更新
     *
     * @param subject 目标对象
     */
    void update(Subject subject);
}
</code></pre>
<h3 id="concreatesubject">ConcreateSubject</h3>
<pre><code>/**
 * 具体的目标对象，负责把有关状态存入到相应的观察者对象，并在自身状态发生改变时通知各个观察者
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-22 21:14
 */
public class ConcreateSubject extends Subject {

    /**
     * 目标对象状态
     */
    private String subjectState;

    public String getSubjectState() {
        return subjectState;
    }

    public void setSubjectState(String subjectState) {
        this.subjectState = subjectState;
        // 状态改变，通知所有观察者
        this.notifyObservers();
    }
}
</code></pre>
<h3 id="concreateobserver">ConcreateObserver</h3>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2019-07-22 21:27
 */
public class ConcreateObserver implements Observer {

    /**
     * 观察者的状态
     */
    private String observerState;

    @Override
    public void update(Subject subject) {
        // 具体更新实现
    }
}
</code></pre>
<h2 id="简单示例">简单示例</h2>
<p>最经典的例子就是读者订阅报纸，在这个例子中，报纸是被观察者，读者就是观察者，读者订阅报纸，当报纸内容更新时，通知所有已订阅的读者</p>
<h3 id="subject-2">Subject</h3>
<pre><code>package com.kuranado.observer.observer2;

import java.util.ArrayList;
import java.util.List;

/**
 * 目标对象，被观察者，仅定义基本的注册观察者、取消注册、通知观察者方法，具体的更新报纸等动作放在具体的子类中
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-23 21:13
 */
public class Subject {

    private final List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();

    /**
     * 注册 读者订阅报纸
     *
     * @param observer 读者（观察者）
     */
    public void subscribe(Observer observer) {
        observers.add(observer);
    }

    /**
     * 取消注册 读者取消订阅
     *
     * @param observer 读者（观察者）
     */
    public void unsubscribe(Observer observer) {
        observers.remove(observer);
    }

    /**
     * 通知每位已订阅的读者
     */
    public void notifyObserver() {
        // 把目标对象自身通过 update 方法传递给观察者，当观察者需要获取数据时，可以通过目标对象的引用来获取
        observers.forEach(observer -&gt; observer.update(this));
    }
}
</code></pre>
<h3 id="newspaper">NewsPaper</h3>
<p>对应 ConcreateSubject</p>
<pre><code>package com.kuranado.observer.observer2;

/**
 * 报纸对象，继承 Subject
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-23 21:18
 */
public class NewsPaper extends Subject {

    /**
     * 报纸内容
     */
    private String content;

    /**
     * 获取抱着内容
     *
     * @return 报纸内容
     */
    public String getContent() {
        return content;
    }

    /**
     * 更新报纸内容，同时通知读者（观察者）
     *
     * @param content 报纸内容
     */
    public void setContent(String content) {
        this.content = content;
        super.notifyObserver();
    }
}
</code></pre>
<h3 id="observer-2">Observer</h3>
<pre><code>package com.kuranado.observer.observer2;

/**
 * 观察者接口
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-23 21:13
 */
public interface Observer {

    /**
     * 接收通知的方法
     *
     * @param subject 具体的目标对象
     */
    void update(Subject subject);
}
</code></pre>
<h3 id="reader">Reader</h3>
<p>对应 ConcreateObserver</p>
<pre><code>package com.kuranado.observer.observer2;

import lombok.Data;

/**
 * 读者 具体的观察者，实现观察者接口
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-23 21:20
 */
@Data
public class Reader implements Observer {

    /**
     * 读者姓名
     */
    private String name;
    // 可增加读者的其它属性 ...，此处省略

    @Override
    public void update(Subject subject) {
        // 拉模式
        System.out.println(name + &quot;收到新报纸，内容为：&quot; + ((NewsPaper) subject).getContent());
    }
}
</code></pre>
<h3 id="client-测试类">Client 测试类</h3>
<pre><code>package com.kuranado.observer.observer2;

/**
 * @Author: Xinling Jing
 * @Date: 2019-07-23 21:25
 */
public class Client {

    public static void main(String[] args) {

        // 纽约时报报纸
        NewsPaper newYorkTimes = new NewsPaper();

        Reader reader = new Reader();
        reader.setName(&quot;小李&quot;);
        Reader reader2 = new Reader();
        reader2.setName(&quot;小王&quot;);
        Reader reader3 = new Reader();
        reader3.setName(&quot;小赵&quot;);

        // 读者订阅报纸
        newYorkTimes.subscribe(reader);
        newYorkTimes.subscribe(reader2);
        newYorkTimes.subscribe(reader3);

        // 纽约时报报纸更新内容
        newYorkTimes.setContent(&quot;任达华 3 厘米刀伤&quot;);

        // 小李取消订阅
        newYorkTimes.unsubscribe(reader);

        // 纽约时报报纸更新内容
        newYorkTimes.setContent(&quot;民航局:春节期间机票可免费退改&quot;);
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>小李收到新报纸，内容为：任达华 3 厘米刀伤
小王收到新报纸，内容为：任达华 3 厘米刀伤
小赵收到新报纸，内容为：任达华 3 厘米刀伤
小王收到新报纸，内容为：民航局:春节期间机票可免费退改
小赵收到新报纸，内容为：民航局:春节期间机票可免费退改
</code></pre>
<h2 id="实际业务示例">实际业务示例</h2>
<p>实际开发中产品有这样一个需求：<br>
管理平台上有两个模块，分别是<strong>版本管理</strong>和<strong>PN 管理</strong>。<br>
<strong>版本管理</strong>模块下每个版本会关联若干个 PN，对版本执行增、删、改操作时，也可以对版本下的 PN 进行增、删、改（这里的 <code>版本</code> 和 <code>PN</code> 都是业务上的概念，无需深究）。<br>
<strong>PN 管理</strong>模块则将<strong>版本管理</strong>模块的所有版本下的 PN 汇总去重后展示<br>
现在产品要求：在增、删、改 版本时，PN 管理下的列表数据也要对应更新</p>
<p>这里可以应用观察者模式，版本管理作为目标，PN 管理作为观察者，当版本管理发生改变时（执行了增、删、改），通知 PN 管理模块更新数据库数据。为了方便，我们这里可以直接使用 Java 提供的观察者模式，让版本管理模块（目标、被观察者）继承 <code>java.util.Observable</code> 类，PN 管理模块（观察者）实现 <code>java.util.Observer</code> 接口<br>
上代码：</p>
<h3 id="版本管理模块被观察者">版本管理模块（被观察者）</h3>
<p>被观察者需要继承 <code>java.util.Observable</code> 类：</p>
<pre><code>/**
 * @author Xinling Jing
 * @date 2020/10/24 21:19
 * @since 1.0.0
 */
@Service(value = &quot;versionService&quot;)
@RequiredArgsConstructor
@Slf4j
public class VersionServiceImpl extends Observable implements VersionService {

    private final VersionConverter versionConverter;

    private final BaseVersionConverterDecorator baseVersionConverterDecorator;

    private final VersionEntityExtraMapper versionEntityExtraMapper;

    private final VersionPnEntityExtraMapper versionPnEntityExtraMapper;

    private final ModelEntityExtraMapper modelEntityExtraMapper;

    private final ModelEcuEntityExtraMapper modelEcuEntityExtraMapper;

    private static final Integer ECU_NAME_LENGTH = 20;
    private static final Integer VERSION_NAME_LENGTH = 30;
    private static final Integer MODULE_ID_LENGTH = 2;
    private static final Integer PART_NUMBER_LENGTH = 20;

    ...
    @Override
    @Transactional(rollbackFor = Exception.class)
    public &lt;T&gt; boolean save(T dto) {
        AddVersionDTO addVersionDTO = (AddVersionDTO) dto;
        VersionEntity versionEntity = baseVersionConverterDecorator.addVersionDto2VersionEntity(addVersionDTO);
        versionEntityExtraMapper.insert(versionEntity);
        List&lt;VersionPnEntity&gt; versionPnEntityList =
            baseVersionConverterDecorator.addVersionPnDtoList2VersionPnEntityList(addVersionDTO.getVersionPnDTOList());
        ...
        // 状态改变
        this.setChanged();
        // 通知观察者
        this.notifyObservers(versionConverter.addVersionDto2QueryVersionDto(addVersionDTO));
        return true;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public &lt;T&gt; boolean updateById(T dto, Long id) {
        UpdateVersionDTO updateVersionDTO = (UpdateVersionDTO) dto;
        VersionVO versionVO = getVersionVO(id, OperationTypeEnum.UPDATE);

        QueryVersionDTO param = QueryVersionDTO.builder().carSeries(versionVO.getCarSeries())
            .modelYear(versionVO.getModelYear()).ecuName(versionVO.getEcuName()).build();
        ...
        this.setChanged();
        this.notifyObservers(param);
        return true;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public &lt;T&gt; boolean deleteById(Long id) {
        VersionVO versionVO = getVersionVO(id, OperationTypeEnum.DELETE);
        QueryVersionDTO param = QueryVersionDTO.builder().carSeries(versionVO.getCarSeries())
            .modelYear(versionVO.getModelYear()).ecuName(versionVO.getEcuName()).build();
        versionEntityExtraMapper.deleteById(id);
        versionPnEntityExtraMapper.deleteByEcuVersionId(id);
        this.setChanged();
        this.notifyObservers(param);
        return true;
    }
    ...
}
</code></pre>
<p>可以看到在增、删、改版本后，都执行了下面两行代码：</p>
<pre><code>// 目标状态改变
this.setChanged();
// 通知观察者，param 为发送给观察者的具体内容
this.notifyObservers(param);
</code></pre>
<p>这里第一行代码是必需的，用于表示目标状态发生改变，否则只执行第二行代码并不能通知到观察者</p>
<h3 id="pn-管理模块观察者">PN 管理模块（观察者）</h3>
<p>观察者需要实现 <code>java.util.Observer</code> 接口：</p>
<pre><code>/**
 * @author Xinling Jing
 * @date 2020/10/28 17:00
 * @since 1.0.0
 */
@Service(value = &quot;pnService&quot;)
@RequiredArgsConstructor
@Slf4j
public class PnServiceImpl implements PnService, Observer {

    @Value(&quot;${fdfs.down_location}&quot;)
    private String downUrl;

    private final PnEntityExtraMapper pnEntityExtraMapper;

    private final VersionService versionService;

    private final VersionEntityExtraMapper versionEntityExtraMapper;

    private final VersionPnEntityExtraMapper versionPnEntityExtraMapper;

    private final PnConverter pnConverter;

    private final BasePnConverterDecorator basePnConverterDecorator;

    private final FastDFSClientWrapper fastDFSClientWrapper;

    private final IdService idService;
    ...
    /**
     * Bean 创建后执行
     */
    @PostConstruct
    public void init() {
        // 观察者进行订阅
        if (versionService instanceof VersionServiceImpl) {
            ((VersionServiceImpl) versionService).addObserver(this);
        }
    }

    /**
     * 维护更新 PN 管理列表，所必须的三个参数：
     * &lt;ul&gt;
     * &lt;li&gt;车系&lt;/li&gt;
     * &lt;li&gt;车型年&lt;/li&gt;
     * &lt;li&gt;EcuName&lt;/li&gt;
     * &lt;/ul&gt;
     * 被观察者在对版本增、删、改时发布消息，观察者接收到消息后需要维护 PN 管理列表
     *
     * @param o 被观察者（即发布者）
     * @param arg 被观察者（即发布者）所发布的内容（被观察者在对版本增、删、改时发布内容）
     */
    @Override
    public void update(Observable o, Object arg) {
        if (!(arg instanceof QueryVersionDTO)) {
            return;
        }
        QueryVersionDTO queryVersionDTO = (QueryVersionDTO) arg;
        // 维护更新 PN 管理对应数据表下的数据
        ...
    }
    ...
}
</code></pre>
<p>通过利用观察者模式，有效的解耦了版本管理和 PN 管理两个业务模块的数据更新，如果后面有新模块需要在版本管理发生变动时，数据随之改动，同样可以让新模块作为观察者订阅版本管理模块</p>
<p>对于 Java 提供的 <code>java.util.Observable</code> 类和 <code>java.util.Observer</code> 接口，大家也不妨自行阅读源码，会发现和我们自己实现的 <code>Subject</code> 类和 <code>Observer</code> 接口并没有太大区别，很容易理解</p>
<h2 id="总结">总结</h2>
<h3 id="观察者模式的本质">观察者模式的本质</h3>
<p>触发联动。当修改目标对象的状态时，就会触发相应通知，通知所有已注册的观察者对象，调用这些观察者对象的更新方法</p>
<h3 id="优缺点">优缺点</h3>
<h4 id="优点">优点</h4>
<ul>
<li>业务解耦</li>
<li>动态联动</li>
<li>支持广播通信，但要防止广播产生死循环:A 对象状态发生改变，广播通知到 B，B 更新后，有可能反过来广播通知 A，然后 A 状态再次发生改变，广播通知 B......</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>可能产生对不需要更新的观察者产生误更新，所以在通知前，对于不需要收到通知的观察者，应及时将其从观察者列表中剔除掉</li>
</ul>
<h3 id="目标和观察者之间的关系">目标和观察者之间的关系</h3>
<ul>
<li>一个目标可以被多个观察者观察</li>
<li>一个目标也可以只被一个观察者观察，我们上面的业务例子就是如此</li>
<li>一个观察者可以只观察一个目标</li>
<li>一个目标也可以观察多个目标，对于这种情况，观察者接口为每个目标提供不同的回调方法，以按需对不同目标的通知执行不同的后续操作</li>
</ul>
<h3 id="单向依赖">单向依赖</h3>
<p>观察者始终依赖于目标，整个过程中，只有目标知道什么时候需要通知观察者，观察者始终是被动的等待通知到来。对目标而言，目标可以对观察者区别对待，比如某些状态变化，只通知部分观察者，并不通知所有观察者</p>
<h3 id="通知顺序">通知顺序</h3>
<p>目标状态发生改变循环遍历通知观察者时，一般通知的顺序是不确定的，所以观察者实现的功能，绝对不能依赖于通知的顺序。也就是说，多个观察者之间的功能是平行的，相互不应该有先后的依赖关系</p>
<h3 id="命名建议">命名建议</h3>
<ul>
<li>目标类以 Subject 结尾</li>
<li>观察者接口以 Observer 结尾</li>
<li>观察者接口中的更新方法，名称定为 update</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>《研磨设计模式》</li>
<li><a href="https://mrdear.cn/2018/04/20/experience/design_patterns--observer/">学长博客-设计模式--观察者模式的思考</a></li>
</ul>
<h2 id="源码">源码</h2>
<ul>
<li><a href="https://github.com/KURANADO2/DesignPatterns">https://github.com/KURANADO2/DesignPatterns</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搬砖工具 - 人生第一块静电容键盘 NIZ 宁芝 micro 82]]></title>
        <id>http://blog.kuranado.com/post/ban-zhuan-gong-ju-ren-sheng-di-yi-kuai-jing-dian-rong-jian-pan-niz-ning-zhi-micro-82/</id>
        <link href="http://blog.kuranado.com/post/ban-zhuan-gong-ju-ren-sheng-di-yi-kuai-jing-dian-rong-jian-pan-niz-ning-zhi-micro-82/">
        </link>
        <updated>2020-11-11T07:53:20.000Z</updated>
        <content type="html"><![CDATA[<p>最近一直想换块布局紧凑的键盘，个人对于键盘布局的要求很简单：<br>
- 紧凑小巧<br>
- 必须要有方向键和 F1~F12<br>
- 有 ⌘ 键和 ⌥ 键，以适用 Mac，不然为了保持和 Mac 键盘布局一致，必须通过 Karabiner 或其它软件实现 Alt 键和 Win 键的位置对调<br>
晚上在京东刷到了宁芝的 82 键静电容键盘，键盘布局刚好符合我的要求，虽然默认是适应于 Windows 的 Alt 和 Win，但会附赠一套 ⌘ 和 ⌥ 键帽用于替换，而且可以通过设置切换 Mac 系统和 Win 系统，再也不需要通过 Karabiner 对调按键了<br>
只是从来没用过静电容键盘，手感是否适合自己就不太确定了。在 B 站看了几段开箱评测视频，感觉应该不会有什么大问题。而且静电容键盘一般比机械键盘贵上不少，想必手感也不会比机械键盘差吧🤔<br>
至于价格的话，双模版八百多块，因为后天就是双十一，今天买的话，即便双十一降价了，也可以申请价保，所以还是用上了之前的京东卡下单了这款键盘<br>
另外也有粗略浏览了下传说中的 HHKB，首先价格就不在我的承受范围之内</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1605081464.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>第二键帽布局上面，缺少方向键和 F1~F12，虽然可以通过加 FN 键弥补，但却意味着大量的快捷键都需要加按 FN，实在是令人难以忍受</p>
<p>第二天吃完晚饭，拿到了键盘，上几张图片：</p>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1605425206.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>轴体（不知道是不是应该叫轴体）和机械键盘完全不同：</p>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1605081550.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>和老键盘（ikbc c104）的对比：</p>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1605081562.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>说下自己简单使用中的感受吧！<br>
- 相较机械键盘，静电容键盘长时间使用起来会更轻松一些，按压力度真的很小，打起字来挺舒服（现在的日记内容全是用这块新键盘写出来的），包装附赠的一些增大压力的小弹簧个人觉得没有必要使用<br>
- 声音沉闷，不会发出机械键盘那样咔哒咔哒的吵闹声，而是有种沙沙沙的感觉<br>
- 键盘布局方面很小巧、紧凑，按键虽少，但对于我来说很重要的方向键、HOME、END 却一个没少<br>
- 蓝牙延迟方面，系统自带蓝牙和附赠的蓝牙接收器都试了一下，肉眼可见的延迟，最终还是插上了附赠的 USB-TypeC 连接线，瞬间延迟消失，所以如果注重无线使用的话，个人并不推荐这款键盘<br>
跟了我我 4 年的 ikbc 终于可以光荣退休了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3 2D 转换.md]]></title>
        <id>http://blog.kuranado.com/post/css3-2d-zhuan-huan-md/</id>
        <link href="http://blog.kuranado.com/post/css3-2d-zhuan-huan-md/">
        </link>
        <updated>2020-10-28T07:48:18.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<blockquote>
<p>CSS3 trasform 属性可实现元素的位移、旋转、缩放等效果</p>
</blockquote>
<h2 id="translate-移动">translate 移动</h2>
<ul>
<li>transform:
<ul>
<li>translate(x, y) 沿着 x 轴和 y 轴移动位置，单位可以为像素、百分比（移动距离为相对于自身元素的百分比，而不是父元素的百分比）</li>
<li>translateX(x) 沿着 x 轴移动位置，等价于 translate(x, 0)</li>
<li>translateY(y) 沿着 y 轴移动位置，等价于 translate(0, y)</li>
</ul>
</li>
</ul>
<pre><code>div {
    width: 200px;
    height: 200px;
    background-color: skyblue;
    transform: translate(30%, 0);
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<p>沿 x 轴方向移动 200px * 30% = 60px</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1603871371.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>对行内元素没有效果</li>
<li>translate 最大的优点是<strong>不会影响其它元素的位置</strong></li>
</ul>
<pre><code>div:first-child {
    width: 200px;
    height: 200px;
    background-color: skyblue;
    transform: translate(100px, 100px);
}
div:last-child {
    width: 200px;
    height: 200px;
    background-color: pink;
}
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1603871383.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h3 id="traslate-实现盒子水平垂直居中">traslate 实现盒子水平/垂直居中</h3>
<p>方法一：<br>
也就是以前实现盒子在父元素内水平垂直剧中的方法</p>
<pre><code>* {
    margin: 0;
    padding: 0;
}
div {
    position: relative;
    width: 200px;
    height: 200px;
    background-color: skyblue;
}
p {
    position: absolute;
    top: 50%;
    left: 50%;
    /* 该值为自身元素高度的一半，如果自身高度改变，则需要重新修改该值 */
    margin-top: -50px;
    /* 该值为自身元素宽度的一半，如果自身宽度改变，则需要重新修改该值 */
    margin-left: -50px;
    width: 100px;
    height: 100px;
    background-color: pink;
}
&lt;div&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>方法二：使用 traslate 的写法：</p>
<pre><code>* {
    margin: 0;
    padding: 0;
}
div {
    position: relative;
    width: 200px;
    height: 200px;
    background-color: skyblue;
}
p {
    position: absolute;
    top: 50%;
    left: 50%;
    /* 即便自身宽度或高度变化，也无需做任何修改，盒子仍然保持水平/垂直居中 */
    transform: translate(-50%, -50%);
    width: 100px;
    height: 100px;
    background-color: pink;
}
&lt;div&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>两种方法的实现效果完全相同，但推荐使用第二种方法：</p>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1603871399.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="rotate-旋转">rotate 旋转</h2>
<ul>
<li>transform:
<ul>
<li>rotate(度数) 单位 deg，如 rotate(45deg)，度数大于零顺时针旋转，度数小于零逆时针旋转。默认旋转的中心点是元素的中心点</li>
</ul>
</li>
<li>transform-origin: x y; 设置旋转的中心点
<ul>
<li>x y 可以是像素，可以是百分比，还可以是方位名词
<ul>
<li>像素 如：trasform-origin: 50px 50px; 以元素左上角向右 50px 和向下 50px 的点为旋转中心</li>
<li>百分比 如：trasform-origin: 50% 50%; 以元素中心点为旋转中心</li>
<li>方位名词 可取值：top right left bottom center，如：transform-origin: center center; 表示以元素中心点为旋转中心；transform-origin: left bottom; 表示以元素左下角为旋转中心</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>img {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    border: 10px solid skyblue;
    transition: all 10s;
}
img:hover {
    transform: rotate(9960deg);
}
&lt;img src=&quot;./images/pvp.png&quot; alt=&quot;&quot;&gt;
</code></pre>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1603871414.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<pre><code>div {
    overflow: hidden;
    margin: 0 auto;
    width: 100px;
    height: 100px;
    background-color: skyblue;
}
div::before {
    content: '旋转动画效果';
    display: block;
    width: 100%;
    height: 100%;
    background-color: pink;
    transform: rotate(90deg);
    transform-origin: left bottom;
    transition: all .3s;
}
div:hover::before {
    /* 复原为 0deg */
    transform: rotate(0deg);
    transform-origin: left bottom;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="5"><img src="http://image.kuranado.com/blog/1603871426.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h3 id="rotate-实现三角箭头">rotate 实现三角箭头</h3>
<p>很多时候用到下图这种三角箭头都是使用字体图标：</p>
<figure data-type="image" tabindex="6"><img src="http://image.kuranado.com/blog/1603871436.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>其实使用 rotate 也完全可以实现，这需要定义一个正方形，只设置右边框和下边框，然后顺时针旋转 45deg 就可以了：</p>
<pre><code>div {
    position: relative;
    width: 249px;
    height: 30px;
    border: 1px solid black;
}
div::after {
    position: absolute;
    top: 9px;
    right: 20px;
    content: '';
    width: 10px;
    height: 10px;
    border-bottom: 1px solid black;
    border-right: 1px solid black;
    transform: rotate(45deg);
    transition: all .1s;
}
div:hover::after {
    /* 45deg + 180deg = 225deg，让箭头翻转为向上 */
    transform: rotate(225deg);
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="7"><img src="http://image.kuranado.com/blog/1603871445.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="scale-缩放">scale 缩放</h2>
<ul>
<li>transform:
<ul>
<li>scale 值为缩放倍数，倍数为 1 表示不变，大于 1 表示放大，小于 1 表示缩小。默认缩放的中心点是元素的中心点；
<ul>
<li>transform: scale(宽度缩放倍数, 高度缩放倍数); 如：transform: scale(0.5，0.8); 表示宽度变为原来的 0.5 倍（一半），高度变为原来的 0.8 倍</li>
<li>transform: scale(等比例缩放倍数); 如：transform: scale(2); 表示宽度变为原来的 2 倍，高度也变为原来的两倍，等价于 transform: scale(2，2);</li>
</ul>
</li>
</ul>
</li>
<li>transform-origin: x y; 设置缩放的中心点
<ul>
<li>x y 可以是像素，可以是百分比，还可以是方位名词
<ul>
<li>像素 如：trasform-origin: 50px 50px; 以元素左上角向右 50px 和向下 50px 的点为缩放中心</li>
<li>百分比 如：trasform-origin: 50% 50%; 以元素中心点为缩放中心</li>
<li>方位名词 可取值：top right left bottom center，如：transform-origin: center center; 表示以元素中心点为缩放中心；transform-origin: left bottom; 表示以元素左下角为缩放中心</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>scale 最大的优点是<strong>不会影响其它元素的位置</strong></li>
</ul>
<h3 id="scale-图片悬浮案例">scale 图片悬浮案例</h3>
<pre><code>div {
    float: left;
    margin-right: 20px;
    overflow: hidden;
    width: 300px;
    height: 280px;
}
div img {
    width: 100%;
    height: 100%;
    transition: all .4s;
}
div img:hover{
    transform: scale(1.1);
}
&lt;div&gt;
    &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./images/happy.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./images/happy.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./images/happy.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="8"><img src="http://image.kuranado.com/blog/1603871457.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h3 id="scale-分页按钮案例">scale 分页按钮案例</h3>
<pre><code>.page ul li {
    float: left;
    margin: 0 10px;
    list-style: none;
    width: 30px;
    height: 30px;
    text-align: center;
    line-height: 30px;
    border: 1px solid skyblue;
    border-radius: 50%;
    transition: all .1s;
}
.page ul li a {
    text-decoration: none;
    color: black
}
.page ul li:hover {
    transform: scale(1.2);
}
&lt;div class=&quot;page&quot;&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;6&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;7&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;8&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;9&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="9"><img src="http://image.kuranado.com/blog/1603871467.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="transform-综合写法注意事项">transform 综合写法注意事项</h2>
<p>transform 属性可同时使用多个转换，如：transform: translate() rotate() scale，这种情况下请注意属性值的先后顺序将会影响转换效果<br>
如：</p>
<pre><code>transform: rotate(180deg) translate(150px, 50px);
</code></pre>
<p>和：</p>
<pre><code>transform: translate(150px, 50px) rotate(180deg);
</code></pre>
<p>的效果是完全不同的，前者先顺时针旋转 180deg，然后在旋转后的基础上向右移动 150px，向下移动 50px；而后者是先向右移动 150px，向下移动 50px，再顺时针旋转 180deg<br>
所以，当我们同时有位移和其它属性时，记得要将位移放到最前面</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 365. 水壶问题]]></title>
        <id>http://blog.kuranado.com/post/leetcode-365-shui-hu-wen-ti/</id>
        <link href="http://blog.kuranado.com/post/leetcode-365-shui-hu-wen-ti/">
        </link>
        <updated>2020-10-27T15:30:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="365-水壶问题"><a href="https://leetcode-cn.com/problems/water-and-jug-problem/">365. 水壶问题</a> 2020年3月21日星期六</h2>
<p>月度打卡题<br>
提交了 5 次，代码 50 行左右，'除零异常、超时（死循环）、解答错误，晚上 11 点多，看了题解，是个数学问题，几行代码搞定。感受到智商被碾压，服气，很服气！！！</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1603812653.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>首先看两个示例：<br>
示例 1：x = 3, y = 5, z = 4<br>
示例 2：x = 3, y = 11, z = 13<br>
对于示例 1：可以满足题目条件，具体操作步骤为：</p>
<ol>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 0 + 3 = 3L</li>
<li>A 装满水，倒到 B 中，因为 A 剩下的容量为 y - 3 = 2L，所以 A 只能向 B 中倒入 2L 水，剩下 1L 留在 A 中。此时 A 中水量为 1L，B 中水量为 5L</li>
<li>B 中水全部倒掉，A 中的 1L 水倒入 B 中。此时 A 中水量为 0L，B 中水量为 1L</li>
<li>A 装满水。此时 A 中水量为 3L，B 中水量为 1L，加在一块等于 4L，也就是等于 z，示例一数据满足条件</li>
</ol>
<p>对于示例 2：可以满足题目条件，具体操作步骤为：</p>
<ol>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 0 + 3 = 3L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 3 + 3 = 6L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 6 + 3 = 9L</li>
<li>A 装满水，倒到 B 中，因为 A 剩下的容量为 y - 9 = 2L，所以 A 只能向 B 中倒入 2L 水，剩下 1L 留在 A 中。此时 A 中水量为 1L，B 中水量为 11L</li>
<li>B 中水全部倒掉，A 中的 1L 水倒入 B 中。此时 A 中水量为 0L，B 中水量为 1L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 1 + 3 = 4L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 4 + 3 = 7L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 7 + 3 = 10L</li>
<li>A 装满水，倒到 B 中，因为 A 剩下的容量为 y - 10 = 1L，所以 A 只能向 B 中倒入 1L 水，剩下 2L 留在 A 中。此时 A 中水量为 2L，B 中水量为 11L，加在一块等于 13L，也就是等于 z，示例二数据满足条件</li>
</ol>
<p>从上面的模拟可以发现，我们的每一步操作，都只会给水的总量带来 x 或 y 的变化，即要么增加或减少 xL 水，要么增加或减少 yL 水<br>
如对于示例一的每一步操作，两壶水的总量变化如下：</p>
<ol>
<li>A 中水量为 0L，B 中水量为 3L，总水量 = 0 + 3 = 3L</li>
<li>A 中水量为 1L，B 中水量为 5L，总水量 = 1 + 5 = 6L</li>
<li>A 中水量为 0L，B 中水量为 1L，总水量为 0 + 1 = 1L</li>
<li>A 中水量为 3L，B 中水量为 1L，总水量为 3 + 1 = 4L</li>
</ol>
<p>确实是每一步操作都只会对两壶水的总量带来 x 或 y 的变化，对于示例一，变化过程为 0 + x + x - y + x = 0 + 3 + 3 - 5 + 3 = 4<br>
同样对于示例二，也是满足这个规律的，此处就不再赘述了<br>
也就是说，只要能够找到一对整数 a、b，满足 ax + by = z，就说明是满足条件的，例如对于示例一，a = 3，b = -1<br>
根据<a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&amp;fromid=5185441">裴蜀定理</a>：<br>
<strong>ax + by = z 有解当且仅当 z 是 x，y 的最大公约数的倍数</strong>，也就是 z % gcd(x, y) == 0</p>
<p>以上就是本题的解题思路，此外还需要注意，如果 z == 0 是直接满足条件的，不需要进行任何计算。另外这里求最大公约数的算法为欧几里得算法。最终代码如下：</p>
<h3 id="最终代码-0ms">最终代码 0ms</h3>
<pre><code class="language-java">class Solution {
    public boolean canMeasureWater(int x, int y, int z) {
        return z == 0 || (x + y &gt;= z &amp;&amp; z % gcd(x, y) == 0);
    }

    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 3. 无重复字符的最长子串]]></title>
        <id>http://blog.kuranado.com/post/leetcode-3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</id>
        <link href="http://blog.kuranado.com/post/leetcode-3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/">
        </link>
        <updated>2020-10-26T12:40:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="3-无重复字符的最长子串"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a> 2020年3月20日星期五 - 2020年3月21日星期六</h2>
<p>做完最小的 k 个数完成打卡，紧接着看了这一题，先用 Set 实现了一遍，执行用时 131 ms，第二天，在 iPad 上画了点草稿，使用双层循环又实现了一遍，执行用时 6ms</p>
<h3 id="解法一-131ms">解法一 131ms</h3>
<p>代码简单明了，但用时很多</p>
<pre><code class="language-java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        int max = -1;
        Set&lt;Character&gt; set = new HashSet&lt;&gt;();
        int j = 0;
        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            boolean add = set.add(c);
            if (!add) {
                if (set.size() &gt; max) {
                    max = set.size();
                }
                set.clear();
                while (j &lt; i) {
                    if (s.charAt(j) == c) {
                        i = j;
                        j++;
                        break;
                    }
                    j++;
                }
            }
        }
        return Math.max(set.size(), max);
    }
}
</code></pre>
<h3 id="解法二-6ms">解法二 6ms</h3>
<p>代码其实也不难，需要定义一个变量跳索引，用于跳过已经判断过的符号。第一次提交时，没有判断输入是空字符串的情况，导致判题返回解答错误</p>
<pre><code class="language-java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (&quot;&quot;.equals(s)) {
            return
                0;
        }
        int max = -1;
        int tmp = 0;
        int length = 1;
        for (int i = 0; i &lt; s.length(); i++) {
            for (int j = tmp; j &lt; i; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    length = i - tmp;
                    tmp = j + 1;
                    break;
                }
                if (j == s.length() - 2) {
                    length = s.length() - tmp;
                }
            }
            if (length &gt; max) {
                max = length;
            }
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 409. 最长回文串]]></title>
        <id>http://blog.kuranado.com/post/leetcode-409-zui-chang-hui-wen-chuan/</id>
        <link href="http://blog.kuranado.com/post/leetcode-409-zui-chang-hui-wen-chuan/">
        </link>
        <updated>2020-10-24T03:28:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="409-最长回文串"><a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a> 2020年3月19日星期四</h2>
<p>月度打卡题</p>
<p>仔细研究了下规律，得到如下结论：</p>
<ul>
<li>字母个数如果是偶数，则必然满足，直接把个数相加</li>
<li>如果只有一个字母的个数是奇数，则必然满足，直接把该字母对应个数（奇数）直接相加</li>
<li>如果存在 &gt; 1 个字母的个数是奇数，则其中任意一个字母个数（奇数）直接相加，其他字母个数 - 1 后再相加</li>
</ul>
<p>综上，其实最终结论就是：只要是字母对应个数是偶数，直接相加，如果是奇数，第一个奇数也直接相加，剩余的奇数 - 1 后再相加</p>
<h3 id="最终代码-3ms">最终代码 3ms</h3>
<pre><code class="language-java">class Solution {
    public int longestPalindrome(String s) {
        int[] arr = new int[52];

        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
                arr[c - 'A']++;
            }
            if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
                arr[c - 71]++;
            }
        }
        int sum = 0;
        boolean firstOdd = true;
        int odd = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            if (arr[i] == 0) {
                continue;
            }
            if (arr[i] % 2 == 0) {
                sum += arr[i];
            } else {
                sum += arr[i] - 1;
                odd = 1;
            }
        }
        sum += odd;
        return sum;
    }
}
</code></pre>
<p>LeetCode 上 1ms 的执行范例：</p>
<pre><code class="language-java">class Solution {
    public int longestPalindrome(String s) {
        if (s == null) return 0;
        
        int[] f = new int[75];
        for (char ch : s.toCharArray()) {
            f[ch - '0']++;
        }
        int res = 0, odd = 0;
        for (int num : f) {
            if (num == 0) continue;
            res += num / 2 * 2;
            
            if (num % 2 == 1) {
                odd = 1;    
            } 
        }
        res += odd;
        return res;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>