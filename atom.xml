<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.kuranado.com</id>
    <title>KURANADO</title>
    <updated>2020-10-14T08:49:07.091Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.kuranado.com"/>
    <link rel="self" href="http://blog.kuranado.com/atom.xml"/>
    <subtitle>笔记/博客</subtitle>
    <logo>http://blog.kuranado.com/images/avatar.png</logo>
    <icon>http://blog.kuranado.com/favicon.ico</icon>
    <rights>All rights reserved 2020, KURANADO</rights>
    <entry>
        <title type="html"><![CDATA[CSS3 盒子模型.md]]></title>
        <id>http://blog.kuranado.com/post/css3-he-zi-mo-xing-md/</id>
        <link href="http://blog.kuranado.com/post/css3-he-zi-mo-xing-md/">
        </link>
        <updated>2020-10-14T08:26:55.000Z</updated>
        <content type="html"><![CDATA[<p>CSS3 通过 box-sizing 属性指定盒子模型</p>
<ul>
<li>box-sizing: content-box 盒子宽为 width + padding + border，高位 height + padding + border + magin 也就是默认的盒子模型。PC 端如果需要完全兼容，就用该传统模式</li>
</ul>
<pre><code>div {
    /* 盒子会被 padding 和 border 撑大 */
    box-sizing: content-box;
    width: 200px;
    height: 200px;
    background-color: skyblue;
    padding: 20px;
    border: 20px solid pink;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602664045.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<ul>
<li>box-sizing: border-box <strong>重点</strong>，盒子宽就是 width（前提是设置的 padding 和 brorder 不会超过 width），高就是 height（前提是设置的 padding 和 brorder 不会超过 height）。PC 端如果不要求兼容，则使用该盒子模型；因为移动端浏览器都是比较新的内核，所以移动端全部使用该盒子模型</li>
</ul>
<pre><code>div {
    /* 盒子不会被 padding 和 border 撑大 */
    box-sizing: border-box;
    width: 200px;
    height: 200px;
    background-color: skyblue;
    padding: 20px;
    border: 20px solid pink;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1602664056.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3 选择器.md]]></title>
        <id>http://blog.kuranado.com/post/css3-xuan-ze-qi-md/</id>
        <link href="http://blog.kuranado.com/post/css3-xuan-ze-qi-md/">
        </link>
        <updated>2020-10-13T11:16:58.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="属性选择器">属性选择器</h2>
<pre><code>/* 选择所有拥有 type 属性的元素 */
input[type]
/* 选择所有拥有 type 属性，且该属性值为 password 的元素 */
input[type=&quot;password&quot;]
/* 选择所有以具有 class 属性，且属性值以 icon 开头的 div 标签 */
div[class^=&quot;icon&quot;]
/* 选择所有以具有 class 属性，且属性值以 icon 结尾的 div 标签 */
div[class$=&quot;icon&quot;]
/* 选择所有以具有 class 属性，且属性值中包含 icon 的 div 标签 */
div[class*=&quot;icon&quot;]
</code></pre>
<h2 id="结构伪类选择器">结构伪类选择器</h2>
<pre><code>/* 选择 ul 下的第一个子元素 */
ul :first-child
/* 选择 ul 下的第一个子元素，且该子元素必须是 li */
ul li:first-child
/* 选择 ul 下的第一个子元素，且该子元素必须是 li */
ul li:last-child
/* 选择 ul 下的第 3 （n 从 1 开始）个子元素，且该子元素必须是 li */
ul li:nth-child(3)
/* 选择 ul 下所有偶数位子元素（2、4、6...），且该子元素必须是 li */
ul li:nth-child(even)
/* 选择 ul 下所有偶数位子元素（1、3、5...），且该子元素必须是 li */
ul li:nth-child(odd)
/* 选择 ul 下所有 li 子元素（只能是字母 n，不能是其他字母），n 从 0 开始，每匹配一个元素后，n 自增 1（刚开始为 0，一个元素也匹配不到，自增为 1 后，菜开始匹配到元素） */
ul li:nth-child(n)
/* 选择 ul 下所有偶数位子元素（2、4、6...），且该子元素必须是 li（2 * 0、2 * 1、2 * 2、2 * 3...）*/
ul li:nth-child(2n)
/* 选择 ul 下所有奇数位子元素（1、3、5...），且该子元素必须是 li（2 * 0 + 1、2 * 1 + 1、2 * 2 + 1...）*/
ul li:nth-child(2n)
/* 选择 ul 下所有 5 的倍数位子元素（5、10、15...），且该子元素必须是 li */
ul li:nth-child(5n)
/* 选择 ul 下从第 5 个开始（包含第 5 个）后面的子元素（5、6、7...），且该子元素必须是 li（0 + 5、1 + 5、2 + 5） */
ul li:nth-child(n+5)
/* 选择 ul 下前 5 （包含第 5 个）子元素（1、2、3、4、5），且该子元素必须是 li（-0 + 5、-1 + 5、-2 + 5、-3 + 5、-4 + 5）*/
ul li:nth-child(-n+5)
</code></pre>
<p>nth-child() 和 nth-of-type() 用法完全相同，都可以在括号中填数字，关键字（even、odd）和公式（如 n、2n、5n 等等），但 nth-child 和 nth-of-type 有如下区别：<br>
nth-child()：</p>
<pre><code>/* 没有选中任何元素，因为 nth-child 会先把所有的盒子都排列成序号，然后再看元素是否匹配，这里第一个 p 标签序号为 1，第一个 div 标签选好为 2，第二个 div 标签序号为 3，所以 nth-child(1) 先找到第一个 1 标签，然后校验该标签是否是 div 标签，因为第一个标签是 p 而不是 div，所以没有任何效果 */
section div:nth-child(1) {
    background-color: red;
}
&lt;section&gt;
    &lt;p&gt;光头强&lt;/p&gt;
    &lt;div&gt;熊大&lt;/div&gt;
    &lt;div&gt;熊二&lt;/div&gt;
&lt;/section&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602587848.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>nth-of-type()：</p>
<pre><code>/* 成功选中第一个 div，因为 nth-of-type 会对指定的盒子进行编号，这里制定了盒子必须是 div */
section div:nth-of-type(1) {
    background-color: red;
}
&lt;section&gt;
    &lt;p&gt;光头强&lt;/p&gt;
    &lt;div&gt;熊大&lt;/div&gt;
    &lt;div&gt;熊二&lt;/div&gt;
&lt;/section&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1602587861.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="伪元素选择器">伪元素选择器</h2>
<p>帮助我们使用 CSS 创建新标签，而不需要显示去写 HTML 标签，从而简化 HTML 结构</p>
<table>
<thead>
<tr>
<th>选择符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>::before</td>
<td>在父元素内容的前面创建元素</td>
</tr>
<tr>
<td>::after</td>
<td>在父元素内容的后面创建元素</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>::before 和 ::after 创建的伪元素属于行内元素（根据需要将其转换为块级元素或行内块元素）</li>
<li>新创建的这个元素在 DOM 树中是找不到的，所以称之为伪元素</li>
<li>before 和 after <strong>必须有 content 属性</strong>，即便内容为空</li>
</ul>
<pre><code>div {
    width: 200px;
    height: 100px;
    background-color: skyblue;
}
div::before {
    content: &quot;我&quot;;
}
div::after {
    content: &quot;小猪佩奇&quot;;
}
&lt;div&gt;
    是
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1602587871.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 浏览器私有前缀.md]]></title>
        <id>http://blog.kuranado.com/post/css-liu-lan-qi-si-you-qian-zhui-md/</id>
        <link href="http://blog.kuranado.com/post/css-liu-lan-qi-si-you-qian-zhui-md/">
        </link>
        <updated>2020-10-11T03:33:57.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<blockquote>
<p>浏览器私有前缀是为了兼容老版本的浏览器，如果 CSS 代码只运行在较新版本的浏览器上则无需添加</p>
</blockquote>
<h2 id="私有前缀">私有前缀</h2>
<ul>
<li><code>-moz-</code> Firefox 的私有前缀</li>
<li><code>-ms-</code> IE 的私有前缀</li>
<li><code>-webkit-</code> Safari 和 Chrome 的私有前缀</li>
<li><code>-o-</code> Opera 的私有前缀</li>
</ul>
<p>国产浏览器基本也全是使用上面四种前缀中的一种</p>
<h2 id="提倡写法">提倡写法</h2>
<p>先写私有前缀，再写不带前缀，例如：</p>
<pre><code>-moz-border-radius: 10px;
-webkit-border-radius: 10px;
-o-border-radius: 10px;
border-radius: 10px;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS margin 负值的巧妙应用.md]]></title>
        <id>http://blog.kuranado.com/post/css-margin-fu-zhi-de-qiao-miao-ying-yong-md/</id>
        <link href="http://blog.kuranado.com/post/css-margin-fu-zhi-de-qiao-miao-ying-yong-md/">
        </link>
        <updated>2020-10-10T11:21:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="margin-负值的巧妙运用">margin 负值的巧妙运用</h2>
<p>先看如下代码：</p>
<pre><code>ul li {
    float: left;
    list-style: none;
    width: 100px;
    height: 100px;
    border: 1px solid skyblue;
}
&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602328932.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>可以看到相邻 li 之间的 border 左右贴在一块，像素数为 2，而我们一般不需要这种效果，所以向左浮动时，可以让每个 li margin-left = -1，即每个 li 向左多走一个像素，这样就能让相邻的 border 上下重叠：</p>
<pre><code>ul li {
    float: left;
    margin-left: -1px;
    list-style: none;
    width: 100px;
    height: 100px;
    border: 1px solid skyblue;
}
&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1602328945.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>效果是实现了，如果现在要求鼠标悬浮在某个 li 上面时，将其边框改成红色，相信大家很容易写出如下代码：</p>
<pre><code>ul li:hover {
    border: 1px solid red;
}
</code></pre>
<p>鼠标悬浮在最后一个 li 上，它的四个边框确实都变成了红色，但是鼠标移到前三个 li 上时，边框却是如下效果：</p>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1602329410.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>这就是因为 margin-left: -1px; 导致左边 li 的右边框被右边 li 的左边框给压住了<br>
为了解决这个问题，可以在鼠标悬浮时为 li 添加一个 relative 定位，因为 relative 定位占有原先的位置（不脱标）且会压住浮动的盒子：</p>
<pre><code>ul li:hover {
    position: relative;
    border: 1px solid red;
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1602328967.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>那如果每个 li 中上面都有一些元素，比如按钮，就需要每个 li 都是相对定位，li 上面的元素使用绝对定位，这时候在鼠标悬浮到某个 li 时，只要给当前鼠标悬浮的 li 设置一个更大的 z-index 就可以正常压住其他 li 的边框了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 1160. 拼写单词]]></title>
        <id>http://blog.kuranado.com/post/leetcode-1160-pin-xie-dan-ci/</id>
        <link href="http://blog.kuranado.com/post/leetcode-1160-pin-xie-dan-ci/">
        </link>
        <updated>2020-10-09T10:52:02.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1160-拼写单词"><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/">1160. 拼写单词</a> 2020年3月17日星期二</h2>
<p>月度打卡题<br>
首先能想到的肯定是要对 chars 打表</p>
<h3 id="解法一-46-ms">解法一 46 ms</h3>
<p>在刚看到这题时，白天是想到了要用数组的，晚上真正回家做的时候竟全然忘记数组，使用了 Map，不过使用数组还是 Map 都大差不差，这一题的主要解题差距还是在于遍历问题，解法一是多遍历了一层的方法，比较耗时</p>
<pre><code class="language-java">class Solution {
    public int countCharacters(String[] words, String chars) {
        Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(26);
        for (int i = 0; i &lt; chars.length(); i++) {
            String s = chars.substring(i, i + 1);
            Integer sum = map.get(s);
            if (sum == null) {
                sum = 1;
            } else {
                sum++;
            }
            map.put(s, sum);
        }
        int result = 0;
        for (int i = 0; i &lt; words.length; i++) {
            Map&lt;String, Integer&gt; mapCopy = new HashMap&lt;&gt;(map);
            String word = words[i];
            boolean flag = true;
            for (int j = 0; j &lt; word.length(); j++) {
                String s = word.substring(j, j + 1);
                Integer sum = mapCopy.get(s);
                if (sum == null || sum == 0) {
                    flag = false;
                    break;
                } else {
                    sum--;
                    mapCopy.put(s, sum);
                }
            }
            if (flag) {
                result += word.length();
            }
        }
        return result;
    }
}
</code></pre>
<h3 id="时间复杂度">时间复杂度</h3>
<p>O(n<sup>2</sup>)</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>O(n)</p>
<h3 id="解法二-6-ms">解法二 6 ms</h3>
<p>相较解法一，少了一层遍历，</p>
<pre><code class="language-java">class Solution {
    public int countCharacters(String[] words, String chars) {
        int[] table = new int[26];
        for (int i = 0; i &lt; chars.length(); i++) {
            table[chars.charAt(i) - 'a'] ++;
        }
        int result = 0;
        for (int i = 0; i &lt; words.length; i++) {
            String word = words[i];
            boolean flag = true;
            int[] tmp = new int[26];
            for (int j = 0; j &lt; word.length(); j++) {
                int index = word.charAt(j) - 'a';
                if (tmp[index] == table[index]) {
                    flag = false;
                    break;
                }
                tmp[index]++;
            }
            if (flag) {
                result += word.length();
            }
        }
        return result;
    }
}
</code></pre>
<h4 id="时间复杂度-2">时间复杂度</h4>
<p>O(n)</p>
<h4 id="空间复杂度-2">空间复杂度</h4>
<p>O(n)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 文本溢出显示省略号.md]]></title>
        <id>http://blog.kuranado.com/post/css-wen-ben-yi-chu-xian-shi-sheng-lue-hao-md/</id>
        <link href="http://blog.kuranado.com/post/css-wen-ben-yi-chu-xian-shi-sheng-lue-hao-md/">
        </link>
        <updated>2020-10-09T10:48:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="单行文本溢出显示省略号">单行文本溢出显示省略号</h2>
<p>单行文本溢出显示省略号必须满足如下三个条件：</p>
<ol>
<li>先强制一行内显示文本，禁止自动换行</li>
<li>超出部分隐藏</li>
<li>使用省略号代替隐藏的超出部分</li>
</ol>
<p>默认自动换行：</p>
<pre><code>div {
    width: 100px;
    height: 50px;
    background-color: skyblue;
}
&lt;div&gt;
    单行文本溢出显示省略号
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602240539.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<pre><code>div {
    width: 100px;
    height: 50px;
    /* 1. 禁止自动换行，white-space 默认值为 normal，表示自动换行 */
    white-space: nowrap;
    /* 2. 隐藏溢出部分 */
    overflow: hidden;
    /* 3.  文字溢出时，使用省略号代替显示隐藏的溢出部分 */
    text-overflow: ellipsis;
    background-color: skyblue;
}
&lt;div&gt;
    单行文本溢出显示省略号
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1602240551.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="多行文本溢出显示省略号">多行文本溢出显示省略号</h2>
<p>如下方法有较大的兼容性问题，适合于 WebKit 内核浏览器或移动端浏览器（移动端浏览器大部分是 WebKit 内核）</p>
<pre><code>div {
    width: 100px;
    height: 65px;
    /* 1. 隐藏溢出部分 */
    overflow: hidden;
    /* 2. 文字溢出时，使用省略号代替显示隐藏的超出部分 */
    text-overflow: ellipsis;
    background-color: skyblue;
    /* 弹性伸缩盒子模型显示 */
    display: -webkit-box;
    /* 限制在一个块内元素显示文本的行数，想让第几行末尾显示省略号，该属性值就等于几 */
    -webkit-line-clamp: 3;
    /* 设置或检索伸缩和对象的子元素的排列方式 */
    -webkit-box-orient: vertical;
}
&lt;div&gt;
    多行文本溢出显示省略号，不需要记代码，用时直接复制即可
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1602240571.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[装饰器模式.md]]></title>
        <id>http://blog.kuranado.com/post/zhuang-shi-qi-mo-shi/</id>
        <link href="http://blog.kuranado.com/post/zhuang-shi-qi-mo-shi/">
        </link>
        <updated>2020-10-08T03:23:26.000Z</updated>
        <content type="html"><![CDATA[<p>装饰器模式也称为包装器模式，往往以 Decorator 或 Wrapper 结尾的类都是使用的装饰器模式</p>
<h2 id="什么是装饰器模式">什么是装饰器模式？</h2>
<blockquote>
<p>装饰器模式又称装饰模式、包装模式。用于动态的给一个对象添加一些额外的职责。就增加功能来说，装饰器模式比生成子类更为灵活</p>
</blockquote>
<h2 id="装饰模式结构">装饰模式结构</h2>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602130112.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<ul>
<li>Component 组件对象的接口，可以给这些对象动态的添加职责</li>
<li>ConcreteComponent 具体的组件对象，实现组件对象接口，通常就是被装饰器装饰的原始对象，可以给这个对象添加职责</li>
<li>Decorator 所有装饰器的抽象父类，需要定义一个与组件接口一致的接口，并持有一个 Component 对象，也就是持有一个被装饰的对象（注意这个被装饰的对象不一定是最原始的那个对象了，有可能是被其它装饰器装饰过后的对象）</li>
<li>ConcreateDecorator 实际的装饰器对象，实现具体要向被装饰对象添加的功能</li>
</ul>
<h2 id="装饰器模式实现简单示例">装饰器模式实现简单示例</h2>
<h3 id="1-定义组件接口">1. 定义组件接口</h3>
<pre><code class="language-java">import lombok.Data;

/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 15:59
 */
@Data
public abstract class BasePerson {

    private String name;

    public abstract String show();
}
</code></pre>
<h3 id="2-定义具体组件类该组件类的对象将被装饰器装饰">2. 定义具体组件类，该组件类的对象将被装饰器装饰</h3>
<p>所有人开始都是一丝不挂</p>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:01
 */
public class ConcretPerson extends BasePerson {

    @Override
    public String show() {
        return this.getName() + &quot;裸体&quot;;
    }
}
</code></pre>
<h3 id="3-定义装饰器接口需要和被装饰的对象实现同样的接口">3. 定义装饰器接口，需要和被装饰的对象实现同样的接口</h3>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:01
 */
public abstract class BaseDecorator extends BasePerson {

    private BasePerson person;

    public BaseDecorator(BasePerson person) {
        this.person = person;
    }

    @Override
    public String show() {
        return person.show();
    }
}
</code></pre>
<h3 id="4-定义具体装饰器类">4. 定义具体装饰器类</h3>
<h4 id="穿内裤的装饰器">穿内裤的装饰器</h4>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:14
 */
public class PantsDecorator extends BaseDecorator {

    public PantsDecorator(BasePerson person) {
        super(person);
    }

    @Override
    public String show() {
        return String.join(&quot; -&gt; &quot;, super.show(), &quot;穿上了红胖次&quot;);
    }
}
</code></pre>
<h4 id="穿裤子的装饰器">穿裤子的装饰器</h4>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:21
 */
public class TrousersDecorator extends BaseDecorator {

    public TrousersDecorator(BasePerson person) {
        super(person);
    }

    @Override
    public String show() {
        return String.join(&quot; -&gt; &quot;, super.show(), &quot;穿上了裤子&quot;);
    }
}
</code></pre>
<h4 id="穿-t-恤的装饰器">穿 T 恤的装饰器</h4>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:23
 */
public class TShirtDecorator extends BaseDecorator {

    public TShirtDecorator(BasePerson person) {
        super(person);
    }

    @Override
    public String show() {
        return String.join(&quot; -&gt; &quot;, super.show(), &quot;穿上了 T 恤&quot;);
    }
}
</code></pre>
<h4 id="梳头发的装饰器">梳头发的装饰器</h4>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:25
 */
public class HairstyleDecorator extends BaseDecorator {

    public HairstyleDecorator(BasePerson person) {
        super(person);
    }

    @Override
    public String show() {
        return String.join(&quot; -&gt; &quot;, super.show(), &quot;梳了一个性感的发型&quot;);
    }
}
</code></pre>
<h3 id="5-客户端调用">5. 客户端调用</h3>
<p>客户端首先创建被装饰的组件对象，然后创建一种或多种装饰器对象，然后把装饰器对象组合起来：</p>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:26
 */
public class Client {

    public static void main(String[] args) {
        
        // 小明家很穷，出门只能穿得起一条内裤
        PantsDecorator decorator = new PantsDecorator(new ConcretPerson(&quot;小明&quot;));
        System.out.println(decorator.show());

        // 康康不仅穿了内裤，还穿了裤子和 T 恤
        TShirtDecorator decorator2 = new TShirtDecorator(new TrousersDecorator(new PantsDecorator(new ConcretPerson(
            &quot;康康&quot;))));
        System.out.println(decorator2.show());

        // 西瓜个头比较小，只需要穿条内裤，然后梳理下发型就可以了
        HairstyleDecorator decorator3 = new HairstyleDecorator(new PantsDecorator(new ConcretPerson(&quot;西瓜&quot;)));
        System.out.println(decorator3.show());
    }
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>小明裸体 -&gt; 穿上了红胖次
康康裸体 -&gt; 穿上了红胖次 -&gt; 穿上了裤子 -&gt; 穿上了 T 恤
西瓜裸体 -&gt; 穿上了红胖次 -&gt; 梳了一个性感的发型
</code></pre>
<p>结构如下：</p>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1602130129.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="常见装饰器模式实现">常见装饰器模式实现</h2>
<h3 id="io-流">IO 流</h3>
<p>结构如下：</p>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1602130138.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>各个类在装饰器中扮演的角色如下：</p>
<ul>
<li><code>InputStream</code> 对应 <code>Component</code></li>
<li><code>FileInputStream</code> 对应 <code>ConcretComponent</code></li>
<li><code>FilterInputStream</code> 对应 <code>Decorator</code></li>
<li><code>DataInputStream</code>、<code>BufferedInputStream</code>、<code>PushbackInputStream</code> 均是具体的装饰器实现</li>
</ul>
<p>示例代码：</p>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 18:21
 */
public class IOTest {

    public static void main(String[] args) {

        DataInputStream dataInputStream = null;
        try {
            dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(&quot;/Users/jing/Desktop&quot; +
                &quot;/IOTest.txt&quot;)));
            byte[] buff = new byte[dataInputStream.available()];
            dataInputStream.read(buff);
            System.out.println(new String(buff));
        } catch (IOException e) {
             e.printStackTrace();
        } finally {
            try {
                if (dataInputStream != null) {
                    dataInputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<h2 id="总结">总结</h2>
<p>下面开始装饰器模式的技术总结：</p>
<ul>
<li>装饰器模式的本质是<strong>动态组合</strong></li>
<li>装饰器用来装饰组件，装饰器一定要实现和组件类一致的接口，保证它们是同一个类型，并且具有同一个外观，这样组合完成的装饰才能递归调用下去</li>
<li>各个装饰器之间最好是完全独立的功能，不要有依赖，以在装饰组合的时候，可以随心所欲，不受先后顺序的限制，也就是说先装饰谁和后装饰谁都应该是一样的，否则会大大降低装饰器组合的灵活性。虽然在实际应用中，可以根据具体的功能要求而有顺序的限制，但应该尽量避免这种情况</li>
</ul>
<h3 id="优点">优点</h3>
<ul>
<li>装饰模式比继承更灵活。继承是静态的，一旦继承，所有子类都有一样的功能，然而有时候有些子类可能并不需要这些继承而来的功能；装饰模式把功能分离到多个装饰器中，然后通过对象组合的方式，在运行时动态的组合功能，每个被装饰的对象最终拥有哪些功能，是由运行时期动态组合的功能来决定的</li>
<li>功能容易复用。一个对象可以使用多个装饰器，一个装饰器也可以用来装饰多个对象，从而实现功能复用</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>会产生很多细粒度的对象。装饰模式是把一系列复杂的功能分散到多个装饰器当中，一般每个装饰器只实现一个功能，这样会产生很多细粒度的对象，而且功能越复杂，需要的细粒度对象也就越多，大量小对象占据内存，一定程度上会影响性能</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>《研磨设计模式》</li>
</ul>
<h2 id="源码">源码</h2>
<ul>
<li><a href="https://github.com/KURANADO2/DesignPatterns">https://github.com/KURANADO2/DesignPatterns</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 面试题 01.06. 字符串压缩]]></title>
        <id>http://blog.kuranado.com/post/leetcode-mian-shi-ti-0106-zi-fu-chuan-ya-suo/</id>
        <link href="http://blog.kuranado.com/post/leetcode-mian-shi-ti-0106-zi-fu-chuan-ya-suo/">
        </link>
        <updated>2020-10-08T03:17:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="面试题-0106-字符串压缩"><a href="https://leetcode-cn.com/problems/compress-string-lcci/">面试题 01.06. 字符串压缩</a> 2020年3月16日星期一</h2>
<p>月度打卡题<br>
因为没注意看题目描述（题目要求：若“压缩”后的字符串<strong>没有变短</strong>，则返回原先的字符串），把 <code>if (result.length() &gt;= S.length())</code> 写成了 <code>if (result.length() &gt; S.length())</code> ，导致提交错误了一次</p>
<p>题目还是比较简单的，不再赘述了</p>
<h3 id="完整代码-6ms">完整代码 6ms</h3>
<pre><code class="language-java">class Solution {
    public String compressString(String S) {
        if (&quot;&quot;.equals(S)) {
            return S;
        }
        int sum = 1;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; S.length() - 1; i ++) {
            char m = S.charAt(i);
            char n = S.charAt(i + 1);
            if (n == m) {
                sum++;
            } else {
                sb.append(m).append(sum);
                sum = 1;
            }
        }
        sb.append(S.charAt(S.length() - 1)).append(sum);
        String result = sb.toString();
        if (result.length() &gt;= S.length()) {
            return S;
        }
        return sb.toString();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 2 两数相加]]></title>
        <id>http://blog.kuranado.com/post/leetcode-2-liang-shu-xiang-jia/</id>
        <link href="http://blog.kuranado.com/post/leetcode-2-liang-shu-xiang-jia/">
        </link>
        <updated>2020-10-07T02:13:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="2-两数相加"><a href="https://leetcode-cn.com/problems/add-two-numbers/">2 两数相加</a> 2020年3月16日星期一</h2>
<p>太久没做过算法题，题目看了好久愣是没搞懂什么意思，昨天晚上想了好久，今天又在平板上画了好多遍，最后直接一边写代码一边思考独立做出来了，使用了递归，最后提交结果用时 2ms，战胜 99.98% 的 Java 提交记录，还是蛮有成就感的，嘻嘻😬</p>
<p>下面为我的思路：</p>
<p>根据题目可以大概知道需要处理以下几个问题：</p>
<ol>
<li>进位问题</li>
<li>两个链表长度不相等问题</li>
</ol>
<p>第一步，不考虑进位，并且假设输入数据的两个链表长度是相同的，可简单写出如下代码：</p>
<pre><code class="language-java">    public static ListNode addTwoNumbers2(ListNode l1, ListNode l2) {
        int x = l1.val + l2.val;
        ListNode r = new ListNode(x % 10);
        if (l1.next != null) {
            r.next = addTwoNumbers2(l1.next, l2.next);
        }
        return r;
    }
</code></pre>
<p>第二步，如果两个链表的长度是不相同的，只要其中一个链表还没有被遍历完，就继续递归，并为另一个已遍历完的链表创建下一节点，只不过把节点值设置为 0，就可以将两个链表变为相同长度链表：</p>
<pre><code class="language-java">    public static ListNode addTwoNumbers2(ListNode l1, ListNode l2) {
        if (l1 == null) {
            l1 = new ListNode(0);
        }
        if (l2 == null) {
            l2 = new ListNode(0);
        }
        int x = l1.val + l2.val;
        ListNode r = new ListNode(x % 10);
        if (l1.next != null || l2.next != null) {
            r.next = addTwoNumbers2(l1.next, l2.next);
        }
        return r;
    }
</code></pre>
<p>最后再考虑进位问题，下面为完整代码：</p>
<h3 id="完整代码2ms">完整代码：2ms</h3>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
       if (l1 == null) {
            l1 = new ListNode(0);
        }
        if (l2 == null) {
            l2 = new ListNode(0);
        }
        int x = l1.val + l2.val;
        ListNode r = new ListNode(x % 10);
        if (l1.next != null || l2.next != null) {
            if (x &gt;= 10) {
                if (l1.next != null) {
                    l1.next.val += 1;
                } else {
                    l2.next.val += 1;
                }
            }
            r.next = addTwoNumbers(l1.next, l2.next);
        } else {
            if (x &gt;= 10) {
                r.next = new ListNode(1);
            }
        }
        return r;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 制作三角.md]]></title>
        <id>http://blog.kuranado.com/post/css-zhi-zuo-san-jiao-md/</id>
        <link href="http://blog.kuranado.com/post/css-zhi-zuo-san-jiao-md/">
        </link>
        <updated>2020-10-07T02:05:20.000Z</updated>
        <content type="html"><![CDATA[<p>在很多网站，鼠标悬浮在某个按钮上，都会出现一个带有小箭头的小浮框，接下来就来讲解这样一个小箭头的实现原理：<br>
<a href="https://www.jd.com/">京东</a>：<br>
<img src="http://image.kuranado.com/blog/1602036362.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
<a href="https://www.mi.com/">小米</a><br>
<img src="http://image.kuranado.com/blog/1602036369.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
编写如下代码：</p>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-top: 50px solid red;
    border-right: 50px solid green;
    border-bottom: 50px solid blue;
    border-left: 50px solid skyblue;
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p>效果图：<br>
<img src="http://image.kuranado.com/blog/1602036385.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
生成了 4 个箭头，箭头的大小取决于 border 的粗细<br>
那如果只想生成一个小箭头，只需要将其他边框颜色设置为透明即可：</p>
<pre><code>.box {
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    /* 生成向下的箭头 */
    border: 50px solid transparent;
    border-top: 50px solid skyblue;
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036394.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
综上，想要实现京东或小米的箭头效果，只要一个相对定位的大盒子上放一个绝对定位的小箭头就可以了，遂编写如下代码：</p>
<pre><code>.box {
    position: relative;
    width: 300px;
    height: 100px;
    background-color: #A1E75A;
    border-radius: 5px;
}
.arrow {
    position: absolute;
    /** 此处为了让向右的箭头能垂直居中，所以 top 设置为大盒子的高度的一半 - 等腰三角形的底边的一半即可（等腰直角三角形高 = 底边的一半）= 100/2 - 10 = 40px **/
    top: 40px;
    left: 300px;
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border: 10px solid transparent;
    border-left: 10px solid #A1E75A;
}
&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036404.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
怎么样，是不是有点像微信的聊天框呢，哈哈哈！<br>
有时还可以看到这样的形状：<br>
<img src="http://image.kuranado.com/blog/1602036412.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
左边部分是一个梯形，根据我们上面分析问题的经验，这个梯形可以分解成一个红色矩形加一个白色的直角三角形实现，可是我们上面的代码得到的是一个普通等腰三角形，应该如何设置 border 才能得到这样一个直角三角形呢？不妨按照如下思路来一步步实现：</p>
<ol>
<li>boder-bottom 设置为 0<br>
去除下边框</li>
</ol>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-top: 50px solid red;
    border-right: 50px solid green;
    /* border-bottom: 50px solid blue; */
    border-left: 50px solid skyblue;
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036422.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
2. 增大 boder-top<br>
为了得到一个高大于地板的直角三角形，所以这里调大 border-top</p>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-top: 100px solid red;
    border-right: 50px solid green;
    /* border-bottom: 50px solid blue; */
    border-left: 50px solid skyblue;
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036431.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
3. boder-left 设置为 0<br>
去除左边框</p>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-top: 100px solid red;
    border-right: 50px solid green;
    /* border-bottom: 50px solid blue; */
    /* border-left: 50px solid skyblue; */
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036440.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
4. border-top 改为透明色</p>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-top: 100px solid transparent;
    border-right: 50px solid green;
    /* border-bottom: 50px solid blue; */
    /* border-left: 50px solid skyblue; */
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036448.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
这样我们就得到了想要的高大于底边的直角三角形，当然代码可以简写成如下形式：</p>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-style: solid;
    border-width: 100px 50px 0 0;
    border-color: transparent green transparent transparent;
}
</code></pre>
<p>有了上面的基础，现在回到京东的案例，我们只需要为该三角形设置绝对定位，将其定位到红色矩形的最右侧，然后将其颜色改为白色即可，具体代码如下：</p>
<pre><code>* {
    margin: 0;
    padding: 0;
}
.price {
    width: 160px;
    height: 24px;
    line-height: 24px;
    border: 1px solid red;
}
.price .miaosha {
    float: left;
    position: relative;
    width: 90px;
    height: 100%;
    text-align: center;
    color: white;
    font-weight: 700;
    background-color: red;
}
.price .miaosha i {
    position: absolute;
    top: 0;
    left: 80px;
    width: 0;
    height: 0;
    font-size: 0;
    line-height: 0;
    border-style: solid;
    border-width: 24px 10px 0 0;
    border-color: transparent white transparent transparent;
}
.origin {
    padding-left: 10px;
    font-size: 14px;
    color: gray;
    text-decoration: line-through;
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;price&quot;&gt;
    &lt;sapn class=&quot;miaosha&quot;&gt;
        ¥1650&lt;i&gt;&lt;/i&gt;
    &lt;/sapn&gt;
    &lt;span class=&quot;origin&quot;&gt;¥5650&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602036463.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>