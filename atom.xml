<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.kuranado.com</id>
    <title>KURANADO</title>
    <updated>2021-01-28T07:06:11.555Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.kuranado.com"/>
    <link rel="self" href="http://blog.kuranado.com/atom.xml"/>
    <subtitle>笔记/博客</subtitle>
    <logo>http://blog.kuranado.com/images/avatar.png</logo>
    <icon>http://blog.kuranado.com/favicon.ico</icon>
    <rights>All rights reserved 2021, KURANADO</rights>
    <entry>
        <title type="html"><![CDATA[观察者模式]]></title>
        <id>http://blog.kuranado.com/post/guan-cha-zhe-mo-shi/</id>
        <link href="http://blog.kuranado.com/post/guan-cha-zhe-mo-shi/">
        </link>
        <updated>2021-01-28T07:01:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是观察者模式">什么是观察者模式</h2>
<blockquote>
<p>观察者模式又称订阅模式，用于定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖它的对象都将得到通知并被自动更新</p>
</blockquote>
<h2 id="观察者模式结构">观察者模式结构</h2>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1611817500.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="观察者模式各个角色作用">观察者模式各个角色作用</h2>
<ul>
<li>Subject:观察者所观察的<strong>目标</strong>，通常具有如下功能
<ul>
<li>一个目标可以被多个观察者观察</li>
<li>目标负责对观察者的注册和退订维护</li>
<li>当目标的状态发生改变时，目标负责通知所已注册的、有效的观察者</li>
</ul>
</li>
<li>Observer:定义观察的接口，提供收到目标通知时对应的更新方法，这个更新方法进行相应的业务处理，可以在这个方法里回调目标对象，以获取目标对象的数据</li>
<li>ConcreateSubject:具体的目标实现对象，用来维护目标状态，当目标对象的状态发生改变时，通知所有已注册的、有效的观察者，让观察者执行相应的处理</li>
<li>ConcreateObserver:观察者的具体实现对象，用来接收目标通知，并进行相应的后续处理</li>
</ul>
<h2 id="模板代码">模板代码</h2>
<h3 id="subject">Subject</h3>
<pre><code>import java.util.ArrayList;
import java.util.List;

/**
 * 目标对象，负责注册、删除和通知观察者
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-22 21:06
 */
public class Subject {

    private List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();

    /**
     * 注册观察者对象
     * @param observer 观察者对象
     */
    public void register(Observer observer) {
        observers.add(observer);
    }

    /**
     * 删除观察者对象
     * @param observer 观察者对象
     */
    public void delete(Observer observer) {
        observers.remove(observer);
    }

    /**
     * 通知所有已注册观察者
     */
    public void notifyObservers() {
        observers.forEach(observer -&gt; observer.update(this));
    }
}
</code></pre>
<h3 id="observer">Observer</h3>
<pre><code>/**
 * 观察者接口，定义一个更新的接口给那些在目标发生改变时被通知的对象
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-22 21:07
 */
public interface Observer {

    /**
     * 用于更新
     *
     * @param subject 目标对象
     */
    void update(Subject subject);
}
</code></pre>
<h3 id="concreatesubject">ConcreateSubject</h3>
<pre><code>/**
 * 具体的目标对象，负责把有关状态存入到相应的观察者对象，并在自身状态发生改变时通知各个观察者
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-22 21:14
 */
public class ConcreateSubject extends Subject {

    /**
     * 目标对象状态
     */
    private String subjectState;

    public String getSubjectState() {
        return subjectState;
    }

    public void setSubjectState(String subjectState) {
        this.subjectState = subjectState;
        // 状态改变，通知所有观察者
        this.notifyObservers();
    }
}
</code></pre>
<h3 id="concreateobserver">ConcreateObserver</h3>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2019-07-22 21:27
 */
public class ConcreateObserver implements Observer {

    /**
     * 观察者的状态
     */
    private String observerState;

    @Override
    public void update(Subject subject) {
        // 具体更新实现
    }
}
</code></pre>
<h2 id="简单示例">简单示例</h2>
<p>最经典的例子就是读者订阅报纸，在这个例子中，报纸是被观察者，读者就是观察者，读者订阅报纸，当报纸内容更新时，通知所有已订阅的读者</p>
<h3 id="subject-2">Subject</h3>
<pre><code>package com.kuranado.observer.observer2;

import java.util.ArrayList;
import java.util.List;

/**
 * 目标对象，被观察者，仅定义基本的注册观察者、取消注册、通知观察者方法，具体的更新报纸等动作放在具体的子类中
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-23 21:13
 */
public class Subject {

    private final List&lt;Observer&gt; observers = new ArrayList&lt;&gt;();

    /**
     * 注册 读者订阅报纸
     *
     * @param observer 读者（观察者）
     */
    public void subscribe(Observer observer) {
        observers.add(observer);
    }

    /**
     * 取消注册 读者取消订阅
     *
     * @param observer 读者（观察者）
     */
    public void unsubscribe(Observer observer) {
        observers.remove(observer);
    }

    /**
     * 通知每位已订阅的读者
     */
    public void notifyObserver() {
        // 把目标对象自身通过 update 方法传递给观察者，当观察者需要获取数据时，可以通过目标对象的引用来获取
        observers.forEach(observer -&gt; observer.update(this));
    }
}
</code></pre>
<h3 id="newspaper">NewsPaper</h3>
<p>对应 ConcreateSubject</p>
<pre><code>package com.kuranado.observer.observer2;

/**
 * 报纸对象，继承 Subject
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-23 21:18
 */
public class NewsPaper extends Subject {

    /**
     * 报纸内容
     */
    private String content;

    /**
     * 获取抱着内容
     *
     * @return 报纸内容
     */
    public String getContent() {
        return content;
    }

    /**
     * 更新报纸内容，同时通知读者（观察者）
     *
     * @param content 报纸内容
     */
    public void setContent(String content) {
        this.content = content;
        super.notifyObserver();
    }
}
</code></pre>
<h3 id="observer-2">Observer</h3>
<pre><code>package com.kuranado.observer.observer2;

/**
 * 观察者接口
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-23 21:13
 */
public interface Observer {

    /**
     * 接收通知的方法
     *
     * @param subject 具体的目标对象
     */
    void update(Subject subject);
}
</code></pre>
<h3 id="reader">Reader</h3>
<p>对应 ConcreateObserver</p>
<pre><code>package com.kuranado.observer.observer2;

import lombok.Data;

/**
 * 读者 具体的观察者，实现观察者接口
 *
 * @Author: Xinling Jing
 * @Date: 2019-07-23 21:20
 */
@Data
public class Reader implements Observer {

    /**
     * 读者姓名
     */
    private String name;
    // 可增加读者的其它属性 ...，此处省略

    @Override
    public void update(Subject subject) {
        // 拉模式
        System.out.println(name + &quot;收到新报纸，内容为：&quot; + ((NewsPaper) subject).getContent());
    }
}
</code></pre>
<h3 id="client-测试类">Client 测试类</h3>
<pre><code>package com.kuranado.observer.observer2;

/**
 * @Author: Xinling Jing
 * @Date: 2019-07-23 21:25
 */
public class Client {

    public static void main(String[] args) {

        // 纽约时报报纸
        NewsPaper newYorkTimes = new NewsPaper();

        Reader reader = new Reader();
        reader.setName(&quot;小李&quot;);
        Reader reader2 = new Reader();
        reader2.setName(&quot;小王&quot;);
        Reader reader3 = new Reader();
        reader3.setName(&quot;小赵&quot;);

        // 读者订阅报纸
        newYorkTimes.subscribe(reader);
        newYorkTimes.subscribe(reader2);
        newYorkTimes.subscribe(reader3);

        // 纽约时报报纸更新内容
        newYorkTimes.setContent(&quot;任达华 3 厘米刀伤&quot;);

        // 小李取消订阅
        newYorkTimes.unsubscribe(reader);

        // 纽约时报报纸更新内容
        newYorkTimes.setContent(&quot;民航局:春节期间机票可免费退改&quot;);
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>小李收到新报纸，内容为：任达华 3 厘米刀伤
小王收到新报纸，内容为：任达华 3 厘米刀伤
小赵收到新报纸，内容为：任达华 3 厘米刀伤
小王收到新报纸，内容为：民航局:春节期间机票可免费退改
小赵收到新报纸，内容为：民航局:春节期间机票可免费退改
</code></pre>
<h2 id="实际业务示例">实际业务示例</h2>
<p>实际开发中产品有这样一个需求：<br>
管理平台上有两个模块，分别是<strong>版本管理</strong>和<strong>PN 管理</strong>。<br>
<strong>版本管理</strong>模块下每个版本会关联若干个 PN，对版本执行增、删、改操作时，也可以对版本下的 PN 进行增、删、改（这里的 <code>版本</code> 和 <code>PN</code> 都是业务上的概念，无需深究）。<br>
<strong>PN 管理</strong>模块则将<strong>版本管理</strong>模块的所有版本下的 PN 汇总去重后展示<br>
现在产品要求：在增、删、改 版本时，PN 管理下的列表数据也要对应更新</p>
<p>这里可以应用观察者模式，版本管理作为目标，PN 管理作为观察者，当版本管理发生改变时（执行了增、删、改），通知 PN 管理模块更新数据库数据。为了方便，我们这里可以直接使用 Java 提供的观察者模式，让版本管理模块（目标、被观察者）继承 <code>java.util.Observable</code> 类，PN 管理模块（观察者）实现 <code>java.util.Observer</code> 接口<br>
上代码：</p>
<h3 id="版本管理模块被观察者">版本管理模块（被观察者）</h3>
<p>被观察者需要继承 <code>java.util.Observable</code> 类：</p>
<pre><code>/**
 * @author Xinling Jing
 * @date 2020/10/24 21:19
 * @since 1.0.0
 */
@Service(value = &quot;versionService&quot;)
@RequiredArgsConstructor
@Slf4j
public class VersionServiceImpl extends Observable implements VersionService {

    private final VersionConverter versionConverter;

    private final BaseVersionConverterDecorator baseVersionConverterDecorator;

    private final VersionEntityExtraMapper versionEntityExtraMapper;

    private final VersionPnEntityExtraMapper versionPnEntityExtraMapper;

    private final ModelEntityExtraMapper modelEntityExtraMapper;

    private final ModelEcuEntityExtraMapper modelEcuEntityExtraMapper;

    private static final Integer ECU_NAME_LENGTH = 20;
    private static final Integer VERSION_NAME_LENGTH = 30;
    private static final Integer MODULE_ID_LENGTH = 2;
    private static final Integer PART_NUMBER_LENGTH = 20;

    ...
    @Override
    @Transactional(rollbackFor = Exception.class)
    public &lt;T&gt; boolean save(T dto) {
        AddVersionDTO addVersionDTO = (AddVersionDTO) dto;
        VersionEntity versionEntity = baseVersionConverterDecorator.addVersionDto2VersionEntity(addVersionDTO);
        versionEntityExtraMapper.insert(versionEntity);
        List&lt;VersionPnEntity&gt; versionPnEntityList =
            baseVersionConverterDecorator.addVersionPnDtoList2VersionPnEntityList(addVersionDTO.getVersionPnDTOList());
        ...
        // 状态改变
        this.setChanged();
        // 通知观察者
        this.notifyObservers(versionConverter.addVersionDto2QueryVersionDto(addVersionDTO));
        return true;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public &lt;T&gt; boolean updateById(T dto, Long id) {
        UpdateVersionDTO updateVersionDTO = (UpdateVersionDTO) dto;
        VersionVO versionVO = getVersionVO(id, OperationTypeEnum.UPDATE);

        QueryVersionDTO param = QueryVersionDTO.builder().carSeries(versionVO.getCarSeries())
            .modelYear(versionVO.getModelYear()).ecuName(versionVO.getEcuName()).build();
        ...
        this.setChanged();
        this.notifyObservers(param);
        return true;
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public &lt;T&gt; boolean deleteById(Long id) {
        VersionVO versionVO = getVersionVO(id, OperationTypeEnum.DELETE);
        QueryVersionDTO param = QueryVersionDTO.builder().carSeries(versionVO.getCarSeries())
            .modelYear(versionVO.getModelYear()).ecuName(versionVO.getEcuName()).build();
        versionEntityExtraMapper.deleteById(id);
        versionPnEntityExtraMapper.deleteByEcuVersionId(id);
        this.setChanged();
        this.notifyObservers(param);
        return true;
    }
    ...
}
</code></pre>
<p>可以看到在增、删、改版本后，都执行了下面两行代码：</p>
<pre><code>// 目标状态改变
this.setChanged();
// 通知观察者，param 为发送给观察者的具体内容
this.notifyObservers(param);
</code></pre>
<p>这里第一行代码是必需的，用于表示目标状态发生改变，否则只执行第二行代码并不能通知到观察者</p>
<h3 id="pn-管理模块观察者">PN 管理模块（观察者）</h3>
<p>观察者需要实现 <code>java.util.Observer</code> 接口：</p>
<pre><code>/**
 * @author Xinling Jing
 * @date 2020/10/28 17:00
 * @since 1.0.0
 */
@Service(value = &quot;pnService&quot;)
@RequiredArgsConstructor
@Slf4j
public class PnServiceImpl implements PnService, Observer {

    @Value(&quot;${fdfs.down_location}&quot;)
    private String downUrl;

    private final PnEntityExtraMapper pnEntityExtraMapper;

    private final VersionService versionService;

    private final VersionEntityExtraMapper versionEntityExtraMapper;

    private final VersionPnEntityExtraMapper versionPnEntityExtraMapper;

    private final PnConverter pnConverter;

    private final BasePnConverterDecorator basePnConverterDecorator;

    private final FastDFSClientWrapper fastDFSClientWrapper;

    private final IdService idService;
    ...
    /**
     * Bean 创建后执行
     */
    @PostConstruct
    public void init() {
        // 观察者进行订阅
        if (versionService instanceof VersionServiceImpl) {
            ((VersionServiceImpl) versionService).addObserver(this);
        }
    }

    /**
     * 维护更新 PN 管理列表，所必须的三个参数：
     * &lt;ul&gt;
     * &lt;li&gt;车系&lt;/li&gt;
     * &lt;li&gt;车型年&lt;/li&gt;
     * &lt;li&gt;EcuName&lt;/li&gt;
     * &lt;/ul&gt;
     * 被观察者在对版本增、删、改时发布消息，观察者接收到消息后需要维护 PN 管理列表
     *
     * @param o 被观察者（即发布者）
     * @param arg 被观察者（即发布者）所发布的内容（被观察者在对版本增、删、改时发布内容）
     */
    @Override
    public void update(Observable o, Object arg) {
        if (!(arg instanceof QueryVersionDTO)) {
            return;
        }
        QueryVersionDTO queryVersionDTO = (QueryVersionDTO) arg;
        // 维护更新 PN 管理对应数据表下的数据
        ...
    }
    ...
}
</code></pre>
<p>通过利用观察者模式，有效的解耦了版本管理和 PN 管理两个业务模块的数据更新，如果后面有新模块需要在版本管理发生变动时，数据随之改动，同样可以让新模块作为观察者订阅版本管理模块</p>
<p>对于 Java 提供的 <code>java.util.Observable</code> 类和 <code>java.util.Observer</code> 接口，大家也不妨自行阅读源码，会发现和我们自己实现的 <code>Subject</code> 类和 <code>Observer</code> 接口并没有太大区别，很容易理解</p>
<h2 id="总结">总结</h2>
<h3 id="观察者模式的本质">观察者模式的本质</h3>
<p>触发联动。当修改目标对象的状态时，就会触发相应通知，通知所有已注册的观察者对象，调用这些观察者对象的更新方法</p>
<h3 id="优缺点">优缺点</h3>
<h4 id="优点">优点</h4>
<ul>
<li>业务解耦</li>
<li>动态联动</li>
<li>支持广播通信，但要防止广播产生死循环:A 对象状态发生改变，广播通知到 B，B 更新后，有可能反过来广播通知 A，然后 A 状态再次发生改变，广播通知 B......</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>可能产生对不需要更新的观察者产生误更新，所以在通知前，对于不需要收到通知的观察者，应及时将其从观察者列表中剔除掉</li>
</ul>
<h3 id="目标和观察者之间的关系">目标和观察者之间的关系</h3>
<ul>
<li>一个目标可以被多个观察者观察</li>
<li>一个目标也可以只被一个观察者观察，我们上面的业务例子就是如此</li>
<li>一个观察者可以只观察一个目标</li>
<li>一个目标也可以观察多个目标，对于这种情况，观察者接口为每个目标提供不同的回调方法，以按需对不同目标的通知执行不同的后续操作</li>
</ul>
<h3 id="单向依赖">单向依赖</h3>
<p>观察者始终依赖于目标，整个过程中，只有目标知道什么时候需要通知观察者，观察者始终是被动的等待通知到来。对目标而言，目标可以对观察者区别对待，比如某些状态变化，只通知部分观察者，并不通知所有观察者</p>
<h3 id="通知顺序">通知顺序</h3>
<p>目标状态发生改变循环遍历通知观察者时，一般通知的顺序是不确定的，所以观察者实现的功能，绝对不能依赖于通知的顺序。也就是说，多个观察者之间的功能是平行的，相互不应该有先后的依赖关系</p>
<h3 id="命名建议">命名建议</h3>
<ul>
<li>目标类以 Subject 结尾</li>
<li>观察者接口以 Observer 结尾</li>
<li>观察者接口中的更新方法，名称定为 update</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>《研磨设计模式》</li>
</ul>
<h2 id="源码">源码</h2>
<ul>
<li><a href="https://github.com/KURANADO2/DesignPatterns">https://github.com/KURANADO2/DesignPatterns</a></li>
<li><a href="https://mrdear.cn/2018/04/20/experience/design_patterns--observer/">学长博客-设计模式--观察者模式的思考</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搬砖工具 - 人生第一块静电容键盘 NIZ 宁芝 micro 82]]></title>
        <id>http://blog.kuranado.com/post/ban-zhuan-gong-ju-ren-sheng-di-yi-kuai-jing-dian-rong-jian-pan-niz-ning-zhi-micro-82/</id>
        <link href="http://blog.kuranado.com/post/ban-zhuan-gong-ju-ren-sheng-di-yi-kuai-jing-dian-rong-jian-pan-niz-ning-zhi-micro-82/">
        </link>
        <updated>2020-11-11T07:53:20.000Z</updated>
        <content type="html"><![CDATA[<p>最近一直想换块布局紧凑的键盘，个人对于键盘布局的要求很简单：<br>
- 紧凑小巧<br>
- 必须要有方向键和 F1~F12<br>
- 有 ⌘ 键和 ⌥ 键，以适用 Mac，不然为了保持和 Mac 键盘布局一致，必须通过 Karabiner 或其它软件实现 Alt 键和 Win 键的位置对调<br>
晚上在京东刷到了宁芝的 82 键静电容键盘，键盘布局刚好符合我的要求，虽然默认是适应于 Windows 的 Alt 和 Win，但会附赠一套 ⌘ 和 ⌥ 键帽用于替换，而且可以通过设置切换 Mac 系统和 Win 系统，再也不需要通过 Karabiner 对调按键了<br>
只是从来没用过静电容键盘，手感是否适合自己就不太确定了。在 B 站看了几段开箱评测视频，感觉应该不会有什么大问题。而且静电容键盘一般比机械键盘贵上不少，想必手感也不会比机械键盘差吧🤔<br>
至于价格的话，双模版八百多块，因为后天就是双十一，今天买的话，即便双十一降价了，也可以申请价保，所以还是用上了之前的京东卡下单了这款键盘<br>
另外也有粗略浏览了下传说中的 HHKB，首先价格就不在我的承受范围之内</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1605081464.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>第二键帽布局上面，缺少方向键和 F1~F12，虽然可以通过加 FN 键弥补，但却意味着大量的快捷键都需要加按 FN，实在是令人难以忍受</p>
<p>第二天吃完晚饭，拿到了键盘，上几张图片：</p>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1605425206.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>轴体（不知道是不是应该叫轴体）和机械键盘完全不同：</p>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1605081550.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>和老键盘（ikbc c104）的对比：</p>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1605081562.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>说下自己简单使用中的感受吧！<br>
- 相较机械键盘，静电容键盘长时间使用起来会更轻松一些，按压力度真的很小，打起字来挺舒服（现在的日记内容全是用这块新键盘写出来的），包装附赠的一些增大压力的小弹簧个人觉得没有必要使用<br>
- 声音沉闷，不会发出机械键盘那样咔哒咔哒的吵闹声，而是有种沙沙沙的感觉<br>
- 键盘布局方面很小巧、紧凑，按键虽少，但对于我来说很重要的方向键、HOME、END 却一个没少<br>
- 蓝牙延迟方面，系统自带蓝牙和附赠的蓝牙接收器都试了一下，肉眼可见的延迟，最终还是插上了附赠的 USB-TypeC 连接线，瞬间延迟消失，所以如果注重无线使用的话，个人并不推荐这款键盘<br>
跟了我我 4 年的 ikbc 终于可以光荣退休了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3 2D 转换.md]]></title>
        <id>http://blog.kuranado.com/post/css3-2d-zhuan-huan-md/</id>
        <link href="http://blog.kuranado.com/post/css3-2d-zhuan-huan-md/">
        </link>
        <updated>2020-10-28T07:48:18.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<blockquote>
<p>CSS3 trasform 属性可实现元素的位移、旋转、缩放等效果</p>
</blockquote>
<h2 id="translate-移动">translate 移动</h2>
<ul>
<li>transform:
<ul>
<li>translate(x, y) 沿着 x 轴和 y 轴移动位置，单位可以为像素、百分比（移动距离为相对于自身元素的百分比，而不是父元素的百分比）</li>
<li>translateX(x) 沿着 x 轴移动位置，等价于 translate(x, 0)</li>
<li>translateY(y) 沿着 y 轴移动位置，等价于 translate(0, y)</li>
</ul>
</li>
</ul>
<pre><code>div {
    width: 200px;
    height: 200px;
    background-color: skyblue;
    transform: translate(30%, 0);
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<p>沿 x 轴方向移动 200px * 30% = 60px</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1603871371.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>对行内元素没有效果</li>
<li>translate 最大的优点是<strong>不会影响其它元素的位置</strong></li>
</ul>
<pre><code>div:first-child {
    width: 200px;
    height: 200px;
    background-color: skyblue;
    transform: translate(100px, 100px);
}
div:last-child {
    width: 200px;
    height: 200px;
    background-color: pink;
}
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1603871383.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h3 id="traslate-实现盒子水平垂直居中">traslate 实现盒子水平/垂直居中</h3>
<p>方法一：<br>
也就是以前实现盒子在父元素内水平垂直剧中的方法</p>
<pre><code>* {
    margin: 0;
    padding: 0;
}
div {
    position: relative;
    width: 200px;
    height: 200px;
    background-color: skyblue;
}
p {
    position: absolute;
    top: 50%;
    left: 50%;
    /* 该值为自身元素高度的一半，如果自身高度改变，则需要重新修改该值 */
    margin-top: -50px;
    /* 该值为自身元素宽度的一半，如果自身宽度改变，则需要重新修改该值 */
    margin-left: -50px;
    width: 100px;
    height: 100px;
    background-color: pink;
}
&lt;div&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>方法二：使用 traslate 的写法：</p>
<pre><code>* {
    margin: 0;
    padding: 0;
}
div {
    position: relative;
    width: 200px;
    height: 200px;
    background-color: skyblue;
}
p {
    position: absolute;
    top: 50%;
    left: 50%;
    /* 即便自身宽度或高度变化，也无需做任何修改，盒子仍然保持水平/垂直居中 */
    transform: translate(-50%, -50%);
    width: 100px;
    height: 100px;
    background-color: pink;
}
&lt;div&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<p>两种方法的实现效果完全相同，但推荐使用第二种方法：</p>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1603871399.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="rotate-旋转">rotate 旋转</h2>
<ul>
<li>transform:
<ul>
<li>rotate(度数) 单位 deg，如 rotate(45deg)，度数大于零顺时针旋转，度数小于零逆时针旋转。默认旋转的中心点是元素的中心点</li>
</ul>
</li>
<li>transform-origin: x y; 设置旋转的中心点
<ul>
<li>x y 可以是像素，可以是百分比，还可以是方位名词
<ul>
<li>像素 如：trasform-origin: 50px 50px; 以元素左上角向右 50px 和向下 50px 的点为旋转中心</li>
<li>百分比 如：trasform-origin: 50% 50%; 以元素中心点为旋转中心</li>
<li>方位名词 可取值：top right left bottom center，如：transform-origin: center center; 表示以元素中心点为旋转中心；transform-origin: left bottom; 表示以元素左下角为旋转中心</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>img {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    border: 10px solid skyblue;
    transition: all 10s;
}
img:hover {
    transform: rotate(9960deg);
}
&lt;img src=&quot;./images/pvp.png&quot; alt=&quot;&quot;&gt;
</code></pre>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1603871414.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<pre><code>div {
    overflow: hidden;
    margin: 0 auto;
    width: 100px;
    height: 100px;
    background-color: skyblue;
}
div::before {
    content: '旋转动画效果';
    display: block;
    width: 100%;
    height: 100%;
    background-color: pink;
    transform: rotate(90deg);
    transform-origin: left bottom;
    transition: all .3s;
}
div:hover::before {
    /* 复原为 0deg */
    transform: rotate(0deg);
    transform-origin: left bottom;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="5"><img src="http://image.kuranado.com/blog/1603871426.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h3 id="rotate-实现三角箭头">rotate 实现三角箭头</h3>
<p>很多时候用到下图这种三角箭头都是使用字体图标：</p>
<figure data-type="image" tabindex="6"><img src="http://image.kuranado.com/blog/1603871436.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>其实使用 rotate 也完全可以实现，这需要定义一个正方形，只设置右边框和下边框，然后顺时针旋转 45deg 就可以了：</p>
<pre><code>div {
    position: relative;
    width: 249px;
    height: 30px;
    border: 1px solid black;
}
div::after {
    position: absolute;
    top: 9px;
    right: 20px;
    content: '';
    width: 10px;
    height: 10px;
    border-bottom: 1px solid black;
    border-right: 1px solid black;
    transform: rotate(45deg);
    transition: all .1s;
}
div:hover::after {
    /* 45deg + 180deg = 225deg，让箭头翻转为向上 */
    transform: rotate(225deg);
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="7"><img src="http://image.kuranado.com/blog/1603871445.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="scale-缩放">scale 缩放</h2>
<ul>
<li>transform:
<ul>
<li>scale 值为缩放倍数，倍数为 1 表示不变，大于 1 表示放大，小于 1 表示缩小。默认缩放的中心点是元素的中心点；
<ul>
<li>transform: scale(宽度缩放倍数, 高度缩放倍数); 如：transform: scale(0.5，0.8); 表示宽度变为原来的 0.5 倍（一半），高度变为原来的 0.8 倍</li>
<li>transform: scale(等比例缩放倍数); 如：transform: scale(2); 表示宽度变为原来的 2 倍，高度也变为原来的两倍，等价于 transform: scale(2，2);</li>
</ul>
</li>
</ul>
</li>
<li>transform-origin: x y; 设置缩放的中心点
<ul>
<li>x y 可以是像素，可以是百分比，还可以是方位名词
<ul>
<li>像素 如：trasform-origin: 50px 50px; 以元素左上角向右 50px 和向下 50px 的点为缩放中心</li>
<li>百分比 如：trasform-origin: 50% 50%; 以元素中心点为缩放中心</li>
<li>方位名词 可取值：top right left bottom center，如：transform-origin: center center; 表示以元素中心点为缩放中心；transform-origin: left bottom; 表示以元素左下角为缩放中心</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>scale 最大的优点是<strong>不会影响其它元素的位置</strong></li>
</ul>
<h3 id="scale-图片悬浮案例">scale 图片悬浮案例</h3>
<pre><code>div {
    float: left;
    margin-right: 20px;
    overflow: hidden;
    width: 300px;
    height: 280px;
}
div img {
    width: 100%;
    height: 100%;
    transition: all .4s;
}
div img:hover{
    transform: scale(1.1);
}
&lt;div&gt;
    &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./images/happy.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./images/happy.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;./images/happy.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="8"><img src="http://image.kuranado.com/blog/1603871457.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h3 id="scale-分页按钮案例">scale 分页按钮案例</h3>
<pre><code>.page ul li {
    float: left;
    margin: 0 10px;
    list-style: none;
    width: 30px;
    height: 30px;
    text-align: center;
    line-height: 30px;
    border: 1px solid skyblue;
    border-radius: 50%;
    transition: all .1s;
}
.page ul li a {
    text-decoration: none;
    color: black
}
.page ul li:hover {
    transform: scale(1.2);
}
&lt;div class=&quot;page&quot;&gt;
    &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;1&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;2&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;3&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;4&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;5&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;6&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;7&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;8&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;9&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="9"><img src="http://image.kuranado.com/blog/1603871467.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="transform-综合写法注意事项">transform 综合写法注意事项</h2>
<p>transform 属性可同时使用多个转换，如：transform: translate() rotate() scale，这种情况下请注意属性值的先后顺序将会影响转换效果<br>
如：</p>
<pre><code>transform: rotate(180deg) translate(150px, 50px);
</code></pre>
<p>和：</p>
<pre><code>transform: translate(150px, 50px) rotate(180deg);
</code></pre>
<p>的效果是完全不同的，前者先顺时针旋转 180deg，然后在旋转后的基础上向右移动 150px，向下移动 50px；而后者是先向右移动 150px，向下移动 50px，再顺时针旋转 180deg<br>
所以，当我们同时有位移和其它属性时，记得要将位移放到最前面</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 365. 水壶问题]]></title>
        <id>http://blog.kuranado.com/post/leetcode-365-shui-hu-wen-ti/</id>
        <link href="http://blog.kuranado.com/post/leetcode-365-shui-hu-wen-ti/">
        </link>
        <updated>2020-10-27T15:30:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="365-水壶问题"><a href="https://leetcode-cn.com/problems/water-and-jug-problem/">365. 水壶问题</a> 2020年3月21日星期六</h2>
<p>月度打卡题<br>
提交了 5 次，代码 50 行左右，'除零异常、超时（死循环）、解答错误，晚上 11 点多，看了题解，是个数学问题，几行代码搞定。感受到智商被碾压，服气，很服气！！！</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1603812653.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>首先看两个示例：<br>
示例 1：x = 3, y = 5, z = 4<br>
示例 2：x = 3, y = 11, z = 13<br>
对于示例 1：可以满足题目条件，具体操作步骤为：</p>
<ol>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 0 + 3 = 3L</li>
<li>A 装满水，倒到 B 中，因为 A 剩下的容量为 y - 3 = 2L，所以 A 只能向 B 中倒入 2L 水，剩下 1L 留在 A 中。此时 A 中水量为 1L，B 中水量为 5L</li>
<li>B 中水全部倒掉，A 中的 1L 水倒入 B 中。此时 A 中水量为 0L，B 中水量为 1L</li>
<li>A 装满水。此时 A 中水量为 3L，B 中水量为 1L，加在一块等于 4L，也就是等于 z，示例一数据满足条件</li>
</ol>
<p>对于示例 2：可以满足题目条件，具体操作步骤为：</p>
<ol>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 0 + 3 = 3L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 3 + 3 = 6L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 6 + 3 = 9L</li>
<li>A 装满水，倒到 B 中，因为 A 剩下的容量为 y - 9 = 2L，所以 A 只能向 B 中倒入 2L 水，剩下 1L 留在 A 中。此时 A 中水量为 1L，B 中水量为 11L</li>
<li>B 中水全部倒掉，A 中的 1L 水倒入 B 中。此时 A 中水量为 0L，B 中水量为 1L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 1 + 3 = 4L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 4 + 3 = 7L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 7 + 3 = 10L</li>
<li>A 装满水，倒到 B 中，因为 A 剩下的容量为 y - 10 = 1L，所以 A 只能向 B 中倒入 1L 水，剩下 2L 留在 A 中。此时 A 中水量为 2L，B 中水量为 11L，加在一块等于 13L，也就是等于 z，示例二数据满足条件</li>
</ol>
<p>从上面的模拟可以发现，我们的每一步操作，都只会给水的总量带来 x 或 y 的变化，即要么增加或减少 xL 水，要么增加或减少 yL 水<br>
如对于示例一的每一步操作，两壶水的总量变化如下：</p>
<ol>
<li>A 中水量为 0L，B 中水量为 3L，总水量 = 0 + 3 = 3L</li>
<li>A 中水量为 1L，B 中水量为 5L，总水量 = 1 + 5 = 6L</li>
<li>A 中水量为 0L，B 中水量为 1L，总水量为 0 + 1 = 1L</li>
<li>A 中水量为 3L，B 中水量为 1L，总水量为 3 + 1 = 4L</li>
</ol>
<p>确实是每一步操作都只会对两壶水的总量带来 x 或 y 的变化，对于示例一，变化过程为 0 + x + x - y + x = 0 + 3 + 3 - 5 + 3 = 4<br>
同样对于示例二，也是满足这个规律的，此处就不再赘述了<br>
也就是说，只要能够找到一对整数 a、b，满足 ax + by = z，就说明是满足条件的，例如对于示例一，a = 3，b = -1<br>
根据<a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&amp;fromid=5185441">裴蜀定理</a>：<br>
<strong>ax + by = z 有解当且仅当 z 是 x，y 的最大公约数的倍数</strong>，也就是 z % gcd(x, y) == 0</p>
<p>以上就是本题的解题思路，此外还需要注意，如果 z == 0 是直接满足条件的，不需要进行任何计算。另外这里求最大公约数的算法为欧几里得算法。最终代码如下：</p>
<h3 id="最终代码-0ms">最终代码 0ms</h3>
<pre><code class="language-java">class Solution {
    public boolean canMeasureWater(int x, int y, int z) {
        return z == 0 || (x + y &gt;= z &amp;&amp; z % gcd(x, y) == 0);
    }

    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 3. 无重复字符的最长子串]]></title>
        <id>http://blog.kuranado.com/post/leetcode-3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</id>
        <link href="http://blog.kuranado.com/post/leetcode-3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/">
        </link>
        <updated>2020-10-26T12:40:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="3-无重复字符的最长子串"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a> 2020年3月20日星期五 - 2020年3月21日星期六</h2>
<p>做完最小的 k 个数完成打卡，紧接着看了这一题，先用 Set 实现了一遍，执行用时 131 ms，第二天，在 iPad 上画了点草稿，使用双层循环又实现了一遍，执行用时 6ms</p>
<h3 id="解法一-131ms">解法一 131ms</h3>
<p>代码简单明了，但用时很多</p>
<pre><code class="language-java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        int max = -1;
        Set&lt;Character&gt; set = new HashSet&lt;&gt;();
        int j = 0;
        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            boolean add = set.add(c);
            if (!add) {
                if (set.size() &gt; max) {
                    max = set.size();
                }
                set.clear();
                while (j &lt; i) {
                    if (s.charAt(j) == c) {
                        i = j;
                        j++;
                        break;
                    }
                    j++;
                }
            }
        }
        return Math.max(set.size(), max);
    }
}
</code></pre>
<h3 id="解法二-6ms">解法二 6ms</h3>
<p>代码其实也不难，需要定义一个变量跳索引，用于跳过已经判断过的符号。第一次提交时，没有判断输入是空字符串的情况，导致判题返回解答错误</p>
<pre><code class="language-java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (&quot;&quot;.equals(s)) {
            return
                0;
        }
        int max = -1;
        int tmp = 0;
        int length = 1;
        for (int i = 0; i &lt; s.length(); i++) {
            for (int j = tmp; j &lt; i; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    length = i - tmp;
                    tmp = j + 1;
                    break;
                }
                if (j == s.length() - 2) {
                    length = s.length() - tmp;
                }
            }
            if (length &gt; max) {
                max = length;
            }
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 409. 最长回文串]]></title>
        <id>http://blog.kuranado.com/post/leetcode-409-zui-chang-hui-wen-chuan/</id>
        <link href="http://blog.kuranado.com/post/leetcode-409-zui-chang-hui-wen-chuan/">
        </link>
        <updated>2020-10-24T03:28:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="409-最长回文串"><a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a> 2020年3月19日星期四</h2>
<p>月度打卡题</p>
<p>仔细研究了下规律，得到如下结论：</p>
<ul>
<li>字母个数如果是偶数，则必然满足，直接把个数相加</li>
<li>如果只有一个字母的个数是奇数，则必然满足，直接把该字母对应个数（奇数）直接相加</li>
<li>如果存在 &gt; 1 个字母的个数是奇数，则其中任意一个字母个数（奇数）直接相加，其他字母个数 - 1 后再相加</li>
</ul>
<p>综上，其实最终结论就是：只要是字母对应个数是偶数，直接相加，如果是奇数，第一个奇数也直接相加，剩余的奇数 - 1 后再相加</p>
<h3 id="最终代码-3ms">最终代码 3ms</h3>
<pre><code class="language-java">class Solution {
    public int longestPalindrome(String s) {
        int[] arr = new int[52];

        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
                arr[c - 'A']++;
            }
            if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
                arr[c - 71]++;
            }
        }
        int sum = 0;
        boolean firstOdd = true;
        int odd = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            if (arr[i] == 0) {
                continue;
            }
            if (arr[i] % 2 == 0) {
                sum += arr[i];
            } else {
                sum += arr[i] - 1;
                odd = 1;
            }
        }
        sum += odd;
        return sum;
    }
}
</code></pre>
<p>LeetCode 上 1ms 的执行范例：</p>
<pre><code class="language-java">class Solution {
    public int longestPalindrome(String s) {
        if (s == null) return 0;
        
        int[] f = new int[75];
        for (char ch : s.toCharArray()) {
            f[ch - '0']++;
        }
        int res = 0, odd = 0;
        for (int num : f) {
            if (num == 0) continue;
            res += num / 2 * 2;
            
            if (num % 2 == 1) {
                odd = 1;    
            } 
        }
        res += odd;
        return res;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见正则示例.md]]></title>
        <id>http://blog.kuranado.com/post/chang-jian-zheng-ze-shi-li-md/</id>
        <link href="http://blog.kuranado.com/post/chang-jian-zheng-ze-shi-li-md/">
        </link>
        <updated>2020-10-22T13:21:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="url">URL</h2>
<p>简单写法：</p>
<h3 id="表达式">表达式</h3>
<pre><code>https?:\/\/[-\w.]+(:\d+)?(\/([\w\/_.]*)?)?
</code></pre>
<ul>
<li><code>https?:\/\/</code> 匹配 <code>http://</code> 或 <code>https://</code></li>
<li><code>[-\w.]+</code> 匹配主机名</li>
<li><code>(:\d+)?</code> 匹配一个可选的端口号</li>
<li><code>(\/([\w\/_.]*)?)?</code> 匹配路径</li>
</ul>
<h3 id="测试文本">测试文本</h3>
<pre><code>https://www.forta.com/blog
https://www.forta.com:80/blog/index.do
http://www.forta.com
http://ben:password@www.forta.com/
http://localhost/index.php?username=1&amp;type=2
http://localhost:8500
</code></pre>
<h3 id="匹配结果">匹配结果</h3>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1603372932.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>虽然第四条和第五条匹配不正确，但该写法已经可以满足绝大部分使用场景了，如需要匹配的更精准，参考下面的写法：</p>
<p>复杂写法：</p>
<h3 id="表达式-2">表达式</h3>
<pre><code>https?:\/\/(\w*:\w*@)?[-\w.]+(:\d+)?(\/([\w\/_.]*(\?\S+)?)?)?
</code></pre>
<ul>
<li><code>(\w*:\w*@)?</code> 匹配 Url 中的用户名和密码</li>
<li><code>(\?\S+)?</code> 匹配查询参数</li>
</ul>
<h3 id="匹配结果-2">匹配结果</h3>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1603372958.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>这种写法虽然匹配的更精准，但性能上也会大打折扣</p>
<hr>
<h2 id="ip-地址">IP 地址</h2>
<p>IP 地址范围为 0.0.0.0 ~ 255.255.255.255，总结如下：</p>
<ol>
<li>任意的 1 位或 2 位数字</li>
<li>任意的以 1 开头的 3 位数字</li>
<li>任意的以 2 开头，第二位数字在 0 到 4 之间的 3 位数字</li>
<li>任意的以 25 开头，第三位数字在 0 到 5 之间的 3 位数字<br>
很容易写出如下正则：</li>
</ol>
<pre><code>(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))
</code></pre>
<p>但这个正则却是错误的，如 IP 地址：<code>12.159.46.200</code> 的匹配结果如下图，最后的 0 无法被匹配，这是因为 <code>20</code> 已经被子表达式 <code>(\d{1, 2})</code> 匹配，并没有被 <code>(25[0-5])</code> 匹配<br>
<img src="http://image.kuranado.com/blog/1603372978.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
正确的写法如下：</p>
<pre><code>((((25[0-5])\d)|(2[0-4]\d)|(1\d{2})|(\d{1,2}))\.){3}(((25[0-5])\d)|(2[0-4]\d)|(1\d{2})|(\d{1,2}))
</code></pre>
<p>匹配结果：<br>
<img src="http://image.kuranado.com/blog/1603372987.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></p>
<hr>
<h2 id="邮箱地址">邮箱地址</h2>
<h3 id="表达式-3">表达式</h3>
<pre><code>(\w+\.)*\w+@(\w+\.)+[A-z]+
</code></pre>
<h3 id="测试文本-2">测试文本</h3>
<pre><code>jing@163.com
jing.xin@mail.kuranado.com
</code></pre>
<h3 id="匹配结果-3">匹配结果</h3>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1603372998.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<hr>
<h2 id="身份证号">身份证号</h2>
<h3 id="表达式-4">表达式</h3>
<pre><code>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$
</code></pre>
<h3 id="测试文本-3">测试文本</h3>
<pre><code>322225199809020429
</code></pre>
<h2 id="手机号">手机号</h2>
<h3 id="表达式-5">表达式</h3>
<pre><code>^1(3|4|5|6|7|8|9)\d{9}$
</code></pre>
<h3 id="测试文本-4">测试文本</h3>
<pre><code>18855465629
</code></pre>
<h2 id="html-注释">HTML 注释</h2>
<h3 id="表达式-6">表达式</h3>
<pre><code>&lt;!-{2,}.*?-{2,}&gt;
</code></pre>
<h3 id="测试文本-5">测试文本</h3>
<pre><code>&lt;!-- comment --&gt;
&lt;!---- -- comment -- -----&gt;
</code></pre>
<h3 id="匹配结果-4">匹配结果</h3>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1603373014.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<hr>
<h2 id="java-单行注释">Java 单行注释</h2>
<h3 id="表达式-7">表达式</h3>
<pre><code>\/\/.*
</code></pre>
<h3 id="测试文本-6">测试文本</h3>
<pre><code>// comment
</code></pre>
<h3 id="匹配结果-5">匹配结果</h3>
<figure data-type="image" tabindex="5"><img src="http://image.kuranado.com/blog/1603373023.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<hr>
<h2 id="java-多行注释">Java 多行注释</h2>
<h3 id="表达式-8">表达式</h3>
<pre><code>/\*[\s\S]*?\*/
</code></pre>
<h3 id="测试文本-7">测试文本</h3>
<pre><code>public class UpgradeEntity {
    /**
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database columnT_UPGRADE_TASK.ID
     *
     * @mbggenerated Wed Oct 14 14:39:23 CST 2020
     */
    private long id;

    /**
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database columnT_UPGRADE_TASK.UPGRADE_NAMES
     *
     * @mbggenerated Wed Oct 14 14:39:23 CST 2020
     */
    private String upgradeNames;

    /**
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database columnT_UPGRADE_TASK.UPGRADE_DESCRIPTION
     *
     * @mbggenerated Wed Oct 14 14:39:23 CST 2020
     */
    private String upgradeDescription;
</code></pre>
<h3 id="匹配结果-6">匹配结果</h3>
<figure data-type="image" tabindex="6"><img src="http://image.kuranado.com/blog/1603373053.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="参考">参考</h2>
<ul>
<li>《正则表达式必知必会修订版》</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3 过渡.md]]></title>
        <id>http://blog.kuranado.com/post/css3-guo-du-md/</id>
        <link href="http://blog.kuranado.com/post/css3-guo-du-md/">
        </link>
        <updated>2020-10-19T11:06:04.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>transition: 要过渡的属性1 花费时间1 运动曲线1 何时开始1, 要过渡的属性2 花费时间2 运动曲线2 何时开始2; 谁想要过渡效果，就为谁设置 trasition 属性
<ul>
<li>要过渡的属性 即想要变化的 CSS 属性，如 width、heigth、background-color、padding、margin、border 都可以，如果想要所有的属性都有过渡效果，则将该值设置为 all</li>
<li>花费时间 过渡需要花费的时间，单位 s，如 .5s（单位 s 不可省略）</li>
<li>运动曲线 可省略，默认为 ease<br>
<img src="http://image.kuranado.com/blog/1603105590.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></li>
<li>何时开始 可省略，默认为 0s，表示立即触发。单位 s（单位 s 不可省略）</li>
</ul>
</li>
</ul>
<pre><code>div {
    width: 100px;
    height: 100px;
    background-color: skyblue;
    /* 口诀：过渡写到本身上，谁做动画给谁加 */
    transition: width 1s ease .5s;
}
div:hover {
    width: 200px;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<p>当鼠标悬浮在 div 上时，0.5s 后，该 div 的宽度会在 1s 内由原来的 100px 过渡到 200px</p>
<pre><code>div {
    width: 100px;
    height: 100px;
    background-color: skyblue;
    transition: width 1s ease .5s, heigth 1s ease .5s;
}
div:hover {
    width: 200px;
    height: 200px;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<p>当鼠标悬浮在 div 上时，0.5s 后，该 div 的宽度会在 1s 内由原来的 100px 过渡到 200px，同时高度也会在 1s 内由原来的 100px 过渡到 200px</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 836. 矩形重叠]]></title>
        <id>http://blog.kuranado.com/post/leetcode-836-ju-xing-chong-die/</id>
        <link href="http://blog.kuranado.com/post/leetcode-836-ju-xing-chong-die/">
        </link>
        <updated>2020-10-15T10:58:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="836-矩形重叠"><a href="https://leetcode-cn.com/problems/rectangle-overlap/">836. 矩形重叠</a> 2020年3月18日星期三</h2>
<p>月度打卡题<br>
刚开始在平板上画了画，发现重叠的情况有很多种，于是利用<strong>逆向思维</strong>，找出所有不重叠的情况，如下图，看起来比较复杂，但仔细一看，下图描述的情况其实非常简单，即如果不想交，则：矩形 r2 要么在矩形 r1 的左边，下面要么在矩形 r1 的右边，要么在矩形 r1 的上边，要么在矩形 r1 的下边，可以写出如下表达式：</p>
<p>r2.x<sub>2</sub> &lt; r1.x<sub>1</sub> || r2.x<sub>1</sub> &gt; r1.x<sub>2</sub> || r2.y<sub>1</sub> &gt; r1.y<sub>2</sub> || r2.y<sub>2</sub> &lt; r1.y<sub>1</sub></p>
<p>不重叠则是对上述表达式取反，大学学数字逻辑时，都知道取反后表达式为：</p>
<p>r2.x<sub>2</sub> &gt;= r1.x<sub>1</sub> || r2.x<sub>1</sub> &gt;= r1.x<sub>2</sub> || r2.y<sub>1</sub> &gt;= r1.y<sub>2</sub> || r2.y<sub>2</sub> &lt;= r1.y<sub>1</sub></p>
<p>由于题目要求只是边重叠并不算做矩形重叠，去掉等于号即可</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602759551.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h3 id="最终代码-0ms">最终代码 0ms</h3>
<pre><code class="language-java">class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        if (rec2[2] &gt; rec1[0] &amp;&amp; rec2[0] &lt; rec1[2] &amp;&amp; rec2[1] &lt; rec1[3] &amp;&amp; rec2[3] &gt; rec1[1]) {
            return true;
        }
        return false;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3 盒子模型.md]]></title>
        <id>http://blog.kuranado.com/post/css3-he-zi-mo-xing-md/</id>
        <link href="http://blog.kuranado.com/post/css3-he-zi-mo-xing-md/">
        </link>
        <updated>2020-10-14T08:26:55.000Z</updated>
        <content type="html"><![CDATA[<p>CSS3 通过 box-sizing 属性指定盒子模型</p>
<ul>
<li>box-sizing: content-box 盒子宽为 width + padding + border，高位 height + padding + border + magin 也就是默认的盒子模型。PC 端如果需要完全兼容，就用该传统模式</li>
</ul>
<pre><code>div {
    /* 盒子会被 padding 和 border 撑大 */
    box-sizing: content-box;
    width: 200px;
    height: 200px;
    background-color: skyblue;
    padding: 20px;
    border: 20px solid pink;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602664045.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<ul>
<li>box-sizing: border-box <strong>重点</strong>，盒子宽就是 width（前提是设置的 padding 和 brorder 不会超过 width），高就是 height（前提是设置的 padding 和 brorder 不会超过 height）。PC 端如果不要求兼容，则使用该盒子模型；因为移动端浏览器都是比较新的内核，所以移动端全部使用该盒子模型</li>
</ul>
<pre><code>div {
    /* 盒子不会被 padding 和 border 撑大 */
    box-sizing: border-box;
    width: 200px;
    height: 200px;
    background-color: skyblue;
    padding: 20px;
    border: 20px solid pink;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1602664056.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>