<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.kuranado.com</id>
    <title>KURANADO</title>
    <updated>2020-10-08T04:10:28.701Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.kuranado.com"/>
    <link rel="self" href="http://blog.kuranado.com/atom.xml"/>
    <subtitle>笔记/博客</subtitle>
    <logo>http://blog.kuranado.com/images/avatar.png</logo>
    <icon>http://blog.kuranado.com/favicon.ico</icon>
    <rights>All rights reserved 2020, KURANADO</rights>
    <entry>
        <title type="html"><![CDATA[装饰器模式.md]]></title>
        <id>http://blog.kuranado.com/post/guan-cha-zhe-mo-shi/</id>
        <link href="http://blog.kuranado.com/post/guan-cha-zhe-mo-shi/">
        </link>
        <updated>2020-10-08T03:23:26.000Z</updated>
        <content type="html"><![CDATA[<p>装饰器模式也称为包装器模式，往往以 Decorator 或 Wrapper 结尾的类都是使用的装饰器模式</p>
<h2 id="什么是装饰器模式">什么是装饰器模式？</h2>
<blockquote>
<p>装饰器模式又称装饰模式、包装模式。用于动态的给一个对象添加一些额外的职责。就增加功能来说，装饰器模式比生成子类更为灵活</p>
</blockquote>
<h2 id="装饰模式结构">装饰模式结构</h2>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602130112.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<ul>
<li>Component 组件对象的接口，可以给这些对象动态的添加职责</li>
<li>ConcreteComponent 具体的组件对象，实现组件对象接口，通常就是被装饰器装饰的原始对象，可以给这个对象添加职责</li>
<li>Decorator 所有装饰器的抽象父类，需要定义一个与组件接口一致的接口，并持有一个 Component 对象，也就是持有一个被装饰的对象（注意这个被装饰的对象不一定是最原始的那个对象了，有可能是被其它装饰器装饰过后的对象）</li>
<li>ConcreateDecorator 实际的装饰器对象，实现具体要向被装饰对象添加的功能</li>
</ul>
<h2 id="装饰器模式实现简单示例">装饰器模式实现简单示例</h2>
<h3 id="1-定义组件接口">1. 定义组件接口</h3>
<pre><code class="language-java">import lombok.Data;

/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 15:59
 */
@Data
public abstract class BasePerson {

    private String name;

    public abstract String show();
}
</code></pre>
<h3 id="2-定义具体组件类该组件类的对象将被装饰器装饰">2. 定义具体组件类，该组件类的对象将被装饰器装饰</h3>
<p>所有人开始都是一丝不挂</p>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:01
 */
public class ConcretPerson extends BasePerson {

    @Override
    public String show() {
        return this.getName() + &quot;裸体&quot;;
    }
}
</code></pre>
<h3 id="3-定义装饰器接口需要和被装饰的对象实现同样的接口">3. 定义装饰器接口，需要和被装饰的对象实现同样的接口</h3>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:01
 */
public abstract class BaseDecorator extends BasePerson {

    private BasePerson person;

    public BaseDecorator(BasePerson person) {
        this.person = person;
    }

    @Override
    public String show() {
        return person.show();
    }
}
</code></pre>
<h3 id="4-定义具体装饰器类">4. 定义具体装饰器类</h3>
<h4 id="穿内裤的装饰器">穿内裤的装饰器</h4>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:14
 */
public class PantsDecorator extends BaseDecorator {

    public PantsDecorator(BasePerson person) {
        super(person);
    }

    @Override
    public String show() {
        return String.join(&quot; -&gt; &quot;, super.show(), &quot;穿上了红胖次&quot;);
    }
}
</code></pre>
<h4 id="穿裤子的装饰器">穿裤子的装饰器</h4>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:21
 */
public class TrousersDecorator extends BaseDecorator {

    public TrousersDecorator(BasePerson person) {
        super(person);
    }

    @Override
    public String show() {
        return String.join(&quot; -&gt; &quot;, super.show(), &quot;穿上了裤子&quot;);
    }
}
</code></pre>
<h4 id="穿-t-恤的装饰器">穿 T 恤的装饰器</h4>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:23
 */
public class TShirtDecorator extends BaseDecorator {

    public TShirtDecorator(BasePerson person) {
        super(person);
    }

    @Override
    public String show() {
        return String.join(&quot; -&gt; &quot;, super.show(), &quot;穿上了 T 恤&quot;);
    }
}
</code></pre>
<h4 id="梳头发的装饰器">梳头发的装饰器</h4>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:25
 */
public class HairstyleDecorator extends BaseDecorator {

    public HairstyleDecorator(BasePerson person) {
        super(person);
    }

    @Override
    public String show() {
        return String.join(&quot; -&gt; &quot;, super.show(), &quot;梳了一个性感的发型&quot;);
    }
}
</code></pre>
<h3 id="5-客户端调用">5. 客户端调用</h3>
<p>客户端首先创建被装饰的组件对象，然后创建一种或多种装饰器对象，然后把装饰器对象组合起来：</p>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 16:26
 */
public class Client {

    public static void main(String[] args) {
        
        // 小明家很穷，出门只能穿得起一条内裤
        PantsDecorator decorator = new PantsDecorator(new ConcretPerson(&quot;小明&quot;));
        System.out.println(decorator.show());

        // 康康不仅穿了内裤，还穿了裤子和 T 恤
        TShirtDecorator decorator2 = new TShirtDecorator(new TrousersDecorator(new PantsDecorator(new ConcretPerson(
            &quot;康康&quot;))));
        System.out.println(decorator2.show());

        // 西瓜个头比较小，只需要穿条内裤，然后梳理下发型就可以了
        HairstyleDecorator decorator3 = new HairstyleDecorator(new PantsDecorator(new ConcretPerson(&quot;西瓜&quot;)));
        System.out.println(decorator3.show());
    }
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>小明裸体 -&gt; 穿上了红胖次
康康裸体 -&gt; 穿上了红胖次 -&gt; 穿上了裤子 -&gt; 穿上了 T 恤
西瓜裸体 -&gt; 穿上了红胖次 -&gt; 梳了一个性感的发型
</code></pre>
<p>结构如下：</p>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1602130129.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="常见装饰器模式实现">常见装饰器模式实现</h2>
<h3 id="io-流">IO 流</h3>
<p>结构如下：</p>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1602130138.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>各个类在装饰器中扮演的角色如下：</p>
<ul>
<li><code>InputStream</code> 对应 <code>Component</code></li>
<li><code>FileInputStream</code> 对应 <code>ConcretComponent</code></li>
<li><code>FilterInputStream</code> 对应 <code>Decorator</code></li>
<li><code>DataInputStream</code>、<code>BufferedInputStream</code>、<code>PushbackInputStream</code> 均是具体的装饰器实现</li>
</ul>
<p>示例代码：</p>
<pre><code class="language-java">/**
 * @Author: Xinling Jing
 * @Date: 2019-07-21 18:21
 */
public class IOTest {

    public static void main(String[] args) {

        DataInputStream dataInputStream = null;
        try {
            dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(&quot;/Users/jing/Desktop&quot; +
                &quot;/IOTest.txt&quot;)));
            byte[] buff = new byte[dataInputStream.available()];
            dataInputStream.read(buff);
            System.out.println(new String(buff));
        } catch (IOException e) {
             e.printStackTrace();
        } finally {
            try {
                if (dataInputStream != null) {
                    dataInputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<h2 id="总结">总结</h2>
<p>下面开始装饰器模式的技术总结：</p>
<ul>
<li>装饰器模式的本质是<strong>动态组合</strong></li>
<li>装饰器用来装饰组件，装饰器一定要实现和组件类一致的接口，保证它们是同一个类型，并且具有同一个外观，这样组合完成的装饰才能递归调用下去</li>
<li>各个装饰器之间最好是完全独立的功能，不要有依赖，以在装饰组合的时候，可以随心所欲，不受先后顺序的限制，也就是说先装饰谁和后装饰谁都应该是一样的，否则会大大降低装饰器组合的灵活性。虽然在实际应用中，可以根据具体的功能要求而有顺序的限制，但应该尽量避免这种情况</li>
</ul>
<h3 id="优点">优点</h3>
<ul>
<li>装饰模式比继承更灵活。继承是静态的，一旦继承，所有子类都有一样的功能，然而有时候有些子类可能并不需要这些继承而来的功能；装饰模式把功能分离到多个装饰器中，然后通过对象组合的方式，在运行时动态的组合功能，每个被装饰的对象最终拥有哪些功能，是由运行时期动态组合的功能来决定的</li>
<li>功能容易复用。一个对象可以使用多个装饰器，一个装饰器也可以用来装饰多个对象，从而实现功能复用</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>会产生很多细粒度的对象。装饰模式是把一系列复杂的功能分散到多个装饰器当中，一般每个装饰器只实现一个功能，这样会产生很多细粒度的对象，而且功能越复杂，需要的细粒度对象也就越多，大量小对象占据内存，一定程度上会影响性能</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>《研磨设计模式》</li>
</ul>
<h2 id="源码">源码</h2>
<ul>
<li><a href="https://github.com/KURANADO2/DesignPatterns">https://github.com/KURANADO2/DesignPatterns</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 面试题 01.06. 字符串压缩]]></title>
        <id>http://blog.kuranado.com/post/leetcode-mian-shi-ti-0106-zi-fu-chuan-ya-suo/</id>
        <link href="http://blog.kuranado.com/post/leetcode-mian-shi-ti-0106-zi-fu-chuan-ya-suo/">
        </link>
        <updated>2020-10-08T03:17:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="面试题-0106-字符串压缩"><a href="https://leetcode-cn.com/problems/compress-string-lcci/">面试题 01.06. 字符串压缩</a> 2020年3月16日星期一</h2>
<p>月度打卡题<br>
因为没注意看题目描述（题目要求：若“压缩”后的字符串<strong>没有变短</strong>，则返回原先的字符串），把 <code>if (result.length() &gt;= S.length())</code> 写成了 <code>if (result.length() &gt; S.length())</code> ，导致提交错误了一次</p>
<p>题目还是比较简单的，不再赘述了</p>
<h3 id="完整代码-6ms">完整代码 6ms</h3>
<pre><code class="language-java">class Solution {
    public String compressString(String S) {
        if (&quot;&quot;.equals(S)) {
            return S;
        }
        int sum = 1;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; S.length() - 1; i ++) {
            char m = S.charAt(i);
            char n = S.charAt(i + 1);
            if (n == m) {
                sum++;
            } else {
                sb.append(m).append(sum);
                sum = 1;
            }
        }
        sb.append(S.charAt(S.length() - 1)).append(sum);
        String result = sb.toString();
        if (result.length() &gt;= S.length()) {
            return S;
        }
        return sb.toString();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 2 两数相加]]></title>
        <id>http://blog.kuranado.com/post/leetcode-2-liang-shu-xiang-jia/</id>
        <link href="http://blog.kuranado.com/post/leetcode-2-liang-shu-xiang-jia/">
        </link>
        <updated>2020-10-07T02:13:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="2-两数相加"><a href="https://leetcode-cn.com/problems/add-two-numbers/">2 两数相加</a> 2020年3月16日星期一</h2>
<p>太久没做过算法题，题目看了好久愣是没搞懂什么意思，昨天晚上想了好久，今天又在平板上画了好多遍，最后直接一边写代码一边思考独立做出来了，使用了递归，最后提交结果用时 2ms，战胜 99.98% 的 Java 提交记录，还是蛮有成就感的，嘻嘻😬</p>
<p>下面为我的思路：</p>
<p>根据题目可以大概知道需要处理以下几个问题：</p>
<ol>
<li>进位问题</li>
<li>两个链表长度不相等问题</li>
</ol>
<p>第一步，不考虑进位，并且假设输入数据的两个链表长度是相同的，可简单写出如下代码：</p>
<pre><code class="language-java">    public static ListNode addTwoNumbers2(ListNode l1, ListNode l2) {
        int x = l1.val + l2.val;
        ListNode r = new ListNode(x % 10);
        if (l1.next != null) {
            r.next = addTwoNumbers2(l1.next, l2.next);
        }
        return r;
    }
</code></pre>
<p>第二步，如果两个链表的长度是不相同的，只要其中一个链表还没有被遍历完，就继续递归，并为另一个已遍历完的链表创建下一节点，只不过把节点值设置为 0，就可以将两个链表变为相同长度链表：</p>
<pre><code class="language-java">    public static ListNode addTwoNumbers2(ListNode l1, ListNode l2) {
        if (l1 == null) {
            l1 = new ListNode(0);
        }
        if (l2 == null) {
            l2 = new ListNode(0);
        }
        int x = l1.val + l2.val;
        ListNode r = new ListNode(x % 10);
        if (l1.next != null || l2.next != null) {
            r.next = addTwoNumbers2(l1.next, l2.next);
        }
        return r;
    }
</code></pre>
<p>最后再考虑进位问题，下面为完整代码：</p>
<h3 id="完整代码2ms">完整代码：2ms</h3>
<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
       if (l1 == null) {
            l1 = new ListNode(0);
        }
        if (l2 == null) {
            l2 = new ListNode(0);
        }
        int x = l1.val + l2.val;
        ListNode r = new ListNode(x % 10);
        if (l1.next != null || l2.next != null) {
            if (x &gt;= 10) {
                if (l1.next != null) {
                    l1.next.val += 1;
                } else {
                    l2.next.val += 1;
                }
            }
            r.next = addTwoNumbers(l1.next, l2.next);
        } else {
            if (x &gt;= 10) {
                r.next = new ListNode(1);
            }
        }
        return r;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 制作三角.md]]></title>
        <id>http://blog.kuranado.com/post/css-zhi-zuo-san-jiao-md/</id>
        <link href="http://blog.kuranado.com/post/css-zhi-zuo-san-jiao-md/">
        </link>
        <updated>2020-10-07T02:05:20.000Z</updated>
        <content type="html"><![CDATA[<p>在很多网站，鼠标悬浮在某个按钮上，都会出现一个带有小箭头的小浮框，接下来就来讲解这样一个小箭头的实现原理：<br>
<a href="https://www.jd.com/">京东</a>：<br>
<img src="http://image.kuranado.com/blog/1602036362.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
<a href="https://www.mi.com/">小米</a><br>
<img src="http://image.kuranado.com/blog/1602036369.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
编写如下代码：</p>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-top: 50px solid red;
    border-right: 50px solid green;
    border-bottom: 50px solid blue;
    border-left: 50px solid skyblue;
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p>效果图：<br>
<img src="http://image.kuranado.com/blog/1602036385.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
生成了 4 个箭头，箭头的大小取决于 border 的粗细<br>
那如果只想生成一个小箭头，只需要将其他边框颜色设置为透明即可：</p>
<pre><code>.box {
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    /* 生成向下的箭头 */
    border: 50px solid transparent;
    border-top: 50px solid skyblue;
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036394.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
综上，想要实现京东或小米的箭头效果，只要一个相对定位的大盒子上放一个绝对定位的小箭头就可以了，遂编写如下代码：</p>
<pre><code>.box {
    position: relative;
    width: 300px;
    height: 100px;
    background-color: #A1E75A;
    border-radius: 5px;
}
.arrow {
    position: absolute;
    /** 此处为了让向右的箭头能垂直居中，所以 top 设置为大盒子的高度的一半 - 等腰三角形的底边的一半即可（等腰直角三角形高 = 底边的一半）= 100/2 - 10 = 40px **/
    top: 40px;
    left: 300px;
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border: 10px solid transparent;
    border-left: 10px solid #A1E75A;
}
&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036404.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
怎么样，是不是有点像微信的聊天框呢，哈哈哈！<br>
有时还可以看到这样的形状：<br>
<img src="http://image.kuranado.com/blog/1602036412.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
左边部分是一个梯形，根据我们上面分析问题的经验，这个梯形可以分解成一个红色矩形加一个白色的直角三角形实现，可是我们上面的代码得到的是一个普通等腰三角形，应该如何设置 border 才能得到这样一个直角三角形呢？不妨按照如下思路来一步步实现：</p>
<ol>
<li>boder-bottom 设置为 0<br>
去除下边框</li>
</ol>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-top: 50px solid red;
    border-right: 50px solid green;
    /* border-bottom: 50px solid blue; */
    border-left: 50px solid skyblue;
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036422.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
2. 增大 boder-top<br>
为了得到一个高大于地板的直角三角形，所以这里调大 border-top</p>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-top: 100px solid red;
    border-right: 50px solid green;
    /* border-bottom: 50px solid blue; */
    border-left: 50px solid skyblue;
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036431.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
3. boder-left 设置为 0<br>
去除左边框</p>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-top: 100px solid red;
    border-right: 50px solid green;
    /* border-bottom: 50px solid blue; */
    /* border-left: 50px solid skyblue; */
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036440.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
4. border-top 改为透明色</p>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-top: 100px solid transparent;
    border-right: 50px solid green;
    /* border-bottom: 50px solid blue; */
    /* border-left: 50px solid skyblue; */
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1602036448.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
这样我们就得到了想要的高大于底边的直角三角形，当然代码可以简写成如下形式：</p>
<pre><code>.box {
    /* 盒子宽高一定要都设置为 0 */
    width: 0;
    height: 0;
    /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */
    font-size: 0;
    line-height: 0;
    border-style: solid;
    border-width: 100px 50px 0 0;
    border-color: transparent green transparent transparent;
}
</code></pre>
<p>有了上面的基础，现在回到京东的案例，我们只需要为该三角形设置绝对定位，将其定位到红色矩形的最右侧，然后将其颜色改为白色即可，具体代码如下：</p>
<pre><code>* {
    margin: 0;
    padding: 0;
}
.price {
    width: 160px;
    height: 24px;
    line-height: 24px;
    border: 1px solid red;
}
.price .miaosha {
    float: left;
    position: relative;
    width: 90px;
    height: 100%;
    text-align: center;
    color: white;
    font-weight: 700;
    background-color: red;
}
.price .miaosha i {
    position: absolute;
    top: 0;
    left: 80px;
    width: 0;
    height: 0;
    font-size: 0;
    line-height: 0;
    border-style: solid;
    border-width: 24px 10px 0 0;
    border-color: transparent white transparent transparent;
}
.origin {
    padding-left: 10px;
    font-size: 14px;
    color: gray;
    text-decoration: line-through;
}
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;price&quot;&gt;
    &lt;sapn class=&quot;miaosha&quot;&gt;
        ¥1650&lt;i&gt;&lt;/i&gt;
    &lt;/sapn&gt;
    &lt;span class=&quot;origin&quot;&gt;¥5650&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602036463.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 字体图标.md]]></title>
        <id>http://blog.kuranado.com/post/css-zi-ti-tu-biao-md/</id>
        <link href="http://blog.kuranado.com/post/css-zi-ti-tu-biao-md/">
        </link>
        <updated>2020-10-06T03:38:37.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="常用字体图标网站">常用字体图标网站</h2>
<ul>
<li><a href="https://icomoon.io/app/#/select">icomoon.io</a></li>
<li><a href="https://www.iconfont.cn/">iconfont.cn</a></li>
</ul>
<h2 id="字体图标格式">字体图标格式</h2>
<p>为了兼容性而存在 .ttf/.woff/.eot/.svg 字体</p>
<h2 id="字体图标的引入">字体图标的引入</h2>
<p>以 icomoon 举例：</p>
<ol>
<li>进入 <a href="https://icomoon.io/app/#/select">icomoon.io</a>，选择字体后下载，解压如下：<br>
<img src="http://image.kuranado.com/blog/1601955553.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></li>
<li>把下载包中的 fonts 文件夹放入页面根目录下</li>
<li>在 CSS 样式中全局声明字体：简单理解就是将字体文件通过 CSS 引入到我们的页面中，一定要注意文件路径是否正确，把下面这段代码（可从下载包中的 style.css 得到）复制到 CSS 文件中</li>
</ol>
<pre><code>/** 字体声明 **/
@font-face {
  font-family: 'icomoon';
  src: url('fonts/icomoon.eot?bypbup');
  src: url('fonts/icomoon.eot?bypbup#iefix') format('embedded-opentype'),
    url('fonts/icomoon.ttf?bypbup') format('truetype'),
    url('fonts/icomoon.woff?bypbup') format('woff'),
    url('fonts/icomoon.svg?bypbup#icomoon') format('svg');
  font-weight: normal;
  font-style: normal;
  font-display: block;
}
</code></pre>
<ol start="4">
<li>打开下载包中的 demo.html，复制需要的图标到代码中<br>
<img src="http://image.kuranado.com/blog/1601955565.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></li>
</ol>
<pre><code>/** 字体声明 **/
@font-face {
    font-family: 'icomoon';
    src: url('fonts/icomoon.eot?bypbup');
    src: url('fonts/icomoon.eot?bypbup#iefix') format('embedded-opentype'),
        url('fonts/icomoon.ttf?bypbup') format('truetype'),
        url('fonts/icomoon.woff?bypbup') format('woff'),
        url('fonts/icomoon.svg?bypbup#icomoon') format('svg');
    font-weight: normal;
    font-style: normal;
    font-display: block;
}
span {
    /** 指定字体为 icomoon **/
    font-family: 'icomoon';
    /** 既然是图标是字体，当然也可以为其设置字体的相关属性 **/
    color: skyblue;
    font-size: 16px;
}
&lt;body&gt;
    &lt;!-- 虽然下面的图标看起来好像一样，但其实是不一样的，如果是在 CSS3 中，使用伪元素选择器 ::after/::before，content 中都可以使用转义图标，如 content: '\e905' 将同样会显示正确的图标 --&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
    &lt;span&gt;&lt;/span&gt;
&lt;/body&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1601955574.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="字体图标的追加">字体图标的追加</h2>
<p>如果项目中想要在原来的基础上引入新的字体图标，可进入 <a href="https://icomoon.io/app/#/select">icomoon.io</a>，导入原来字体包的 selection.json 文件<br>
<img src="http://image.kuranado.com/blog/1601955593.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
这时 icomoon 就会加载出我们以前下载的图标<br>
<img src="http://image.kuranado.com/blog/1601955602.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
之后在此基础上选择其他想要的新图标，选完后下载字体包，解压，将 fonts 文件夹复制到页面根目录下，替换原先的 fonts 文件夹即可（替换文件夹，需把旧文件夹删掉，然后把新文件夹复制进去即可，以完成彻底替换，否则字体可能会不生效）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac - Hammerspoon.md]]></title>
        <id>http://blog.kuranado.com/post/mac-hammerspoonmd/</id>
        <link href="http://blog.kuranado.com/post/mac-hammerspoonmd/">
        </link>
        <updated>2020-10-06T01:50:03.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在<a href="https://mrdear.cn/posts/osx_app_switcher.html">学长博客</a>中发现一个非常好玩的效率软件：<a href="http://www.hammerspoon.org/">Hammerspoon</a>，通过编写 Lua 脚本，完成各种有趣的小功能</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在<a href="https://mrdear.cn/posts/osx_app_switcher.html">学长博客</a>中发现一个非常好玩的效率软件：<a href="http://www.hammerspoon.org/">Hammerspoon</a>，通过编写 Lua 脚本，完成各种有趣的小功能</p>
<!-- more -->
<p>[TOC]</p>
<h2 id="hammerspoon-作用">Hammerspoon 作用</h2>
<ul>
<li>替代 Magnet 进行窗口移动<br>
之前一直用 Magnet 移动窗口，使用 Hammerspoon 之后完全可以替代 Magnet，以下为 Magnet 横屏和竖屏分别支持的快捷键截图<br>
横屏：<br>
<img src="http://image.kuranado.com/blog/1601949462.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
竖屏：<br>
<img src="http://image.kuranado.com/blog/1601949470.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></li>
<li>为应用配置快捷键，比 ⌘⇥ 和 Alfred 切换程序更高效（建议只为高频使用的一些软件分配快捷键）</li>
</ul>
<h2 id="个人配置快捷键列表">个人配置快捷键列表</h2>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>⌃⌥←</td>
<td>左半屏</td>
</tr>
<tr>
<td>⌃⌥→</td>
<td>右半屏</td>
</tr>
<tr>
<td>⌃⌥↑</td>
<td>上半屏</td>
</tr>
<tr>
<td>⌃⌥↓</td>
<td>下半屏</td>
</tr>
<tr>
<td>⌃⌥D</td>
<td>左 1/3（横屏）或上 1/3（竖屏）</td>
</tr>
<tr>
<td>⌃⌥F</td>
<td>中 1/3</td>
</tr>
<tr>
<td>⌃⌥G</td>
<td>右 1/3（横屏）或下 1/3（竖屏）</td>
</tr>
<tr>
<td>⌃⌥E</td>
<td>左 2/3（横屏）或上 2/3（竖屏）</td>
</tr>
<tr>
<td>⌃⌥T</td>
<td>右 2/3（横屏）或下 2/3（竖屏）</td>
</tr>
<tr>
<td>⌃⌥C</td>
<td>居中</td>
</tr>
<tr>
<td>⌃⌥=</td>
<td>等比例放大窗口</td>
</tr>
<tr>
<td>⌃⌥-</td>
<td>等比例缩小窗口</td>
</tr>
<tr>
<td>⌃⌥↩︎</td>
<td>最大化</td>
</tr>
<tr>
<td>⌃⌥⌘←</td>
<td>窗口由主屏移动到副屏</td>
</tr>
<tr>
<td>⌃⌥⌘→</td>
<td>窗口由副屏移动到主屏</td>
</tr>
<tr>
<td>⌥Q</td>
<td>打开 QQ</td>
</tr>
<tr>
<td>⌥W</td>
<td>打开 WeChat</td>
</tr>
<tr>
<td>⌥V</td>
<td>打开 Visual Studio Code</td>
</tr>
<tr>
<td>⌥F</td>
<td>打开 Finder</td>
</tr>
<tr>
<td>⌥C</td>
<td>打开 Chrome</td>
</tr>
<tr>
<td>⌥J</td>
<td>打开 Intellij IDEA</td>
</tr>
<tr>
<td>⌥N</td>
<td>打开 WizNote</td>
</tr>
<tr>
<td>⌥G</td>
<td>打开 Gridea</td>
</tr>
<tr>
<td>⌥D</td>
<td>打开 DataGrip</td>
</tr>
<tr>
<td>⌥T</td>
<td>打开 iTerm2</td>
</tr>
<tr>
<td>⌥M</td>
<td>打开 MailMaster</td>
</tr>
<tr>
<td>⌥P</td>
<td>打开 Postman</td>
</tr>
</tbody>
</table>
<h2 id="个人配置文件">个人配置文件</h2>
<p>见 GitHub：<a href="https://github.com/KURANADO2/hammerspoon-kuranado/blob/main/init.lua">https://github.com/KURANADO2/hammerspoon-kuranado/blob/main/init.lua</a></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://mrdear.cn/posts/osx_app_switcher.html">学长博客 - OSX--OSX应用快速切换方案</a></li>
<li><a href="https://www.hammerspoon.org/go/">官方 Quick Start</a></li>
<li><a href="http://www.hammerspoon.org/docs/">官方文档</a></li>
<li><a href="https://sspai.com/post/53992">少数派 - 免费又强大的 macOS 自动化工具，Hammerspoon 可以让你少买很多 App</a></li>
<li><a href="https://www.v2ex.com/t/553241">V2EX - 推荐一个 MacOS 上用了就无法自拔的神器</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/72499152">Hammerspoon - 岂止于窗口管理</a></li>
<li><a href="https://github.com/rtoshiro/hammerspoon-init">hammerspoon-init</a></li>
<li><a href="https://www.runoob.com/lua/lua-tutorial.html">菜鸟教程 - Lua 教程</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Builder 模式.md]]></title>
        <id>http://blog.kuranado.com/post/builder-mo-shi-md/</id>
        <link href="http://blog.kuranado.com/post/builder-mo-shi-md/">
        </link>
        <updated>2020-10-05T02:36:45.000Z</updated>
        <content type="html"><![CDATA[<p>Builder 模式又称为建造者、生成器模式。日常开发中，很多类名包含 <code>Builder</code> 的都是生成器模式，例如 StringBuilder 的 append 方法</p>
<h2 id="生成器模式的本质">生成器模式的本质</h2>
<ul>
<li>分离了对象子组件的单独构造和装配，从而可以构造出复杂的对象。建造者模式适用于某个对象的构建过程较为复杂的情况</li>
<li>由于实现了构建和装配的解耦，不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。构建和装配的解耦，实现了更好的复用</li>
</ul>
<h2 id="生成器模式的构成">生成器模式的构成</h2>
<p>生成器模式的构成分为两个部分：</p>
<ol>
<li>Builder 接口：定义如何<strong>构建</strong>各个部件，了解每个部件的构建实现细节</li>
<li>Director 接口：定义如何<strong>装配</strong>各个部件，负责产品的整体构建算法</li>
</ol>
<h2 id="举个栗子">举个栗子</h2>
<p>下面以生产电脑为例，讲解 Builder 模式：</p>
<h3 id="computer-类">Computer 类</h3>
<pre><code>package com.kuranado.builder;

import lombok.Getter;
import lombok.Setter;

/**
 * 电脑类
 * @Author: Xinling Jing
 * @Date: 2018-12-21 15:01
 */
@Setter
@Getter
public class Computer {

    private CPU cpu;
    private Graphics graphics;
    private HardDisk hardDisk;

    public Computer(CPU cpu, Graphics graphics, HardDisk hardDisk) {
        this.cpu = cpu;
        this.graphics = graphics;
        this.hardDisk = hardDisk;
    }

    public void start() {
        System.out.println(&quot;开机中...&quot;);
    }
}

class Hardware {

    /**
     * 品牌
     */
    private String brand;
    /**
     * 型号
     */
    private String model;

    public Hardware(String brand, String model) {
        this.brand = brand;
        this.model = model;
    }
}

/**
 * CPU
 */
class CPU extends Hardware {

    /**
     * Cache
     */
    private String cache;

    public CPU(String brand, String model, String cache) {
        super(brand, model);
        this.cache = cache;
    }
}

/**
 * 显卡
 */
class Graphics extends Hardware {

    /**
     * 显存
     */
    private String videoMemory;

    public Graphics(String brand, String model, String videoMemory) {
        super(brand, model);
        this.videoMemory = videoMemory;
    }
}

/**
 * 硬盘
 */
class HardDisk extends Hardware {

    /**
     * 硬盘容量
     */
    private String capacity;

    public HardDisk(String brand, String model, String capacity) {
        super(brand, model);
        this.capacity = capacity;
    }
}
</code></pre>
<h3 id="computerbuilder-接口">ComputerBuilder 接口</h3>
<pre><code>package com.kuranado.builder;

/**
 * @Author: Xinling Jing
 * @Date: 2018-12-22 10:17
 */
public interface ComputerBuilder {

    CPU buildCPU();
    Graphics buildGraphics();
    HardDisk buildHardDisk();

}
</code></pre>
<h3 id="maccomputerbuilder-实现类">MacComputerBuilder 实现类</h3>
<p>具体的 Builder 知道每个部件的实现细节。可以定义很多种 Builder，每种 Builder 在部件细节实现上都不尽相同，从而构建出不同的对象</p>
<pre><code>package com.kuranado.builder;

/**
 * @Author: Xinling Jing
 * @Date: 2018-12-22 10:19
 */
public class MacComputerBuilder implements ComputerBuilder {

    @Override
    public CPU buildCPU() {
        System.out.println(&quot;构建 Mac CPU&quot;);
        return new CPU(&quot;Intel&quot;, &quot;Xeon W&quot;, &quot;19MB&quot;);
    }

    @Override
    public Graphics buildGraphics() {
        System.out.println(&quot;构建 Mac 显卡&quot;);
        return new Graphics(&quot;AMD&quot;, &quot;Radeon Pro Vega 56&quot;, &quot;8GB&quot;);
    }

    @Override
    public HardDisk buildHardDisk() {
        System.out.println(&quot;构建 Mac 硬盘&quot;);
        return new HardDisk(&quot;三星&quot;, &quot;SM128C&quot;, &quot;2TB&quot;);
    }
}
</code></pre>
<h3 id="computerdirector-接口">ComputerDirector 接口</h3>
<pre><code>package com.kuranado.builder;

/**
 * @Author: Xinling Jing
 * @Date: 2018-12-22 10:39
 */
public interface ComputerDirector {

    Computer directorComputer();

}
</code></pre>
<h3 id="maccomputerdirector-实现类">MacComputerDirector 实现类</h3>
<p>具体的 Director 负责将部件装配起来，Director 知道整个产品的装配细节。可以定义很多 Director，从而装配出不同的对象</p>
<pre><code>package com.kuranado.builder;

import lombok.Getter;
import lombok.Setter;

/**
 * @Author: Xinling Jing
 * @Date: 2018-12-22 10:40
 */
@Setter
@Getter
public class MacComputerDirector implements ComputerDirector {

    private ComputerBuilder computerBuilder;

    public MacComputerDirector(ComputerBuilder computerBuilder) {
        this.computerBuilder = computerBuilder;
    }

    @Override
    public Computer directorComputer() {

        // 调用 Builder 构建每个部件
        CPU cpu = computerBuilder.buildCPU();
        Graphics graphics = computerBuilder.buildGraphics();
        HardDisk hardDisk = computerBuilder.buildHardDisk();

        // 装配电脑
        return new Computer(cpu, graphics, hardDisk);
    }
}
</code></pre>
<p>实际应用中 Director 需要进行复杂的运算，然后根据需要，调用 Builder 中的方法生成需要的部件对象并按照某种算法装配这些部件。实际开发中可能会有如下几种情况(摘自《研磨设计模式》)：</p>
<blockquote>
<ul>
<li>在运行指导者的时候，会按照整体构建算法的步骤进行运算，可能先运行前几步运算，到了某一步骤，需要具体创建某个部件对象了，然后就调用 Builder 中创建相应部件调度方法来创建具体的部件。同时把前面运算得到的数据传递给 Builder，因为在 Builder 内部实现创建和组装部件的时候，可能会需要这些数据</li>
<li>Builder 创建完具体的部件对象后，会把创建好的部件对象返回给装配者，装配者继续后续的算法运算，可能会用到已经创建好的对象</li>
<li>如此反复下去，直到整个构建算法完成，整个产品也就创建好了</li>
</ul>
</blockquote>
<h3 id="客户端调用">客户端调用</h3>
<pre><code>package com.kuranado.builder;

/**
 * @Author: Xinling Jing
 * @Date: 2018-12-17 21:12
 */
public class Client {

    public static void main(String[] args) {
        ComputerDirector director = new MacComputerDirector(new MacComputerBuilder());
        Computer computer = director.directorComputer();
       
        computer.start();
    }
}
</code></pre>
<p>程序运行结果：</p>
<pre><code>构建 Mac CPU
构建 Mac 显卡
构建 Mac 硬盘
开机中...
</code></pre>
<h2 id="生成器模式的优点">生成器模式的优点</h2>
<ul>
<li>松散耦合：生成器模式可以用同一个构建算法构建出表现上完全不同的产品，实现产品构建和产品表现上的分离。</li>
<li>可以很容易的改变产品的内部表示：Builder 对象提供接口给 Director 使用，所以具体不见的创建和装配方式被 Builder 接口隐藏了，Director 并不知道具体的实现细节。</li>
<li>复用性好：因为实现了构建算法和具体产品实现的分离，所以构建算法和具体的产品装配两者都可以复用。同一个构建算法可以应用到不用的具体产品实现中，同一个具体产品实现，也可以配合不同的构建算法。</li>
</ul>
<p>这就是生成器模式，是不是很简单呢！</p>
<h2 id="思考">思考</h2>
<p>现在在考虑一个问题，在 directorComputer 方法中我们组装电脑使用了这样一行代码：</p>
<pre><code>return new Computer(cpu, graphics, hardDisk);
</code></pre>
<p>想想这里有没有可以优化的地方呢？</p>
<p>想不到？</p>
<p>那倘若 Computer 类不止 CPU、Gragphics、HardDisk 这三个属性呢，比如 Computer 类还有 NetworkCard、SoundCard、MainBoard、Power、CDRom、Memory 等属性，那这时我们是不是要写这样一行代码来创建 Computer 对象：</p>
<pre><code>return new Computer(cpu, graphics, hardDisk, networkCard, soundCard, mainBoard, power, cdRom, memory);
</code></pre>
<p>遇到这种参数较多的情况，很多人还会重叠构造器：</p>
<pre><code>public Computer(CPU cpu) {
    this(cpu, null);
}

public Computer(CPU cpu, Graphics graphics) {
    this(cpu, graphics, null);
}

public Computer(CPU cpu, Graphics graphics, HardDisk hardDisk) {
    this(cpu, graphics, hardDisk, null)
}

...

public Computer(cpu, graphics, hardDisk, networkCard, soundCard, mainBoard, power, cdRom, memory) {
    this.cpu = cpu;
    this.graphics = graphics;
    this.hardDisk = hardDisk;
    ...
}
</code></pre>
<p>在参数很多的情况下，重叠构造器有很多缺点：</p>
<ol>
<li>层层嵌套，代码不灵活</li>
<li>不优雅</li>
<li>如果增加参数那就是噩梦</li>
</ol>
<p>这时候就有人说了：可以提供空参构造方法，然后一个个调 setter 方法设置属性就不用重叠构造器了！</p>
<pre><code>Computer computer = new Computer();
computer.setCPU(cpu);
computer.setGragphics(gragphics);
computer.setHardDisk(hardDisk);
computer.setNetworkCard(networkCard);
computer.setSoundCard(soundCard);
computer.setMainBoard(mainBoard);
computer.setPower(power);
computer.setCDRom(cdRom);
computer.setMemory(memory);
</code></pre>
<p>事实上，我们项目组的同事都是通过这种 set 的形式设置对象的，然而这真的是一个好的代码风格吗？《阿里 Java 开发手册》中推荐方法代码不超过 80 行，照这样创建对象很难符合规范。在工作中发现了这一点，想到了 Android 的 Api 中存在大量的链式调用，我们也可以将自己的代码修改成链式调用：</p>
<pre><code>package com.kuranado.builder;

import lombok.Getter;
import lombok.Setter;

/**
 * 电脑类
 * @Author: Xinling Jing
 * @Date: 2018-12-21 15:01
 */
@Setter
@Getter
public class Computer {

    private CPU cpu;
    private Graphics graphics;
    private HardDisk hardDisk;

    public Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.graphics = builder.graphics;
        this.hardDisk = builder.hardDisk;
    }

    public void start() {
        System.out.println(&quot;开机中...&quot;);
    }

    public static class Builder {

        private CPU cpu;
        private Graphics graphics;
        private HardDisk hardDisk;

        public Builder setCpu(CPU cpu) {
            this.cpu = cpu;
            return this;
        }

        public Builder setGraphics(Graphics graphics) {
            this.graphics = graphics;
            return this;
        }

        public Builder setHardDisk(HardDisk hardDisk) {
            this.hardDisk = hardDisk;
            return this;
        }

        Computer build() {
            return new Computer(this);
        }
    }
}
</code></pre>
<p>内部类中的每个 set 方法都返回内部类自己，对于 set 方法可以使用 IDEA 自动生成，但需要注意需要选择 Builder 模板，而不要选择 Intellij Default：</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1601865469.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>然后创建 Computer 对象：</p>
<pre><code>new Computer.Builder().setCpu(cpu).setGraphics(graphics).setHardDisk(hardDisk).build();
</code></pre>
<p>这样即便在属性很多时代码看起来也很简洁，当然这种链式调用也存在一定缺点，比如：</p>
<ul>
<li>每次创建外部类对象，都需要再创建一个内部类，所以需要消耗更多的内存</li>
<li>每个属性要同时在内部类和外部类中定义</li>
</ul>
<p>所以大家具体根据使用场景而定</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>《Effective Java》</li>
<li>《研磨设计模式》</li>
<li><a href="https://mrdear.cn/2018/03/06/experience/design_patterns--builder-model/">学长博客</a></li>
<li><a href="https://www.youtube.com/watch?v=03ly8k1FkVc">【GOF23设计模式】 建造者模式详解</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 定位.md]]></title>
        <id>http://blog.kuranado.com/post/css-ding-wei-md/</id>
        <link href="http://blog.kuranado.com/post/css-ding-wei-md/">
        </link>
        <updated>2020-10-05T02:02:39.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="为什么需要定位">为什么需要定位</h2>
<p>使用标准流或浮动很难快速实现如下效果：</p>
<ol>
<li>某个元素可以自由的在一个盒子内移动位置，并且压住其它盒子</li>
<li>当我们滚动窗口的时候，盒子可以固定在屏幕的某个位置</li>
</ol>
<p>而定位具有如下特性：</p>
<ul>
<li>定位可以让盒子自由的在某个盒子内移动位置或者固定在屏幕中某个位置，并且可以压住其它盒子</li>
</ul>
<h2 id="定位组成">定位组成</h2>
<p>定位 = 定位模式 + 边偏移</p>
<h3 id="边偏移">边偏移</h3>
<p>边偏移决定了元素的最终位置，也就是定位的盒子移动到的最终位置</p>
<ul>
<li>top 顶部偏移量，定义元素相对其父元素上边线的距离</li>
<li>bottom 底部偏移量，定义元素相对其父元素下边线的距离</li>
<li>left 左侧偏移量，定义元素相对其父元素左边线的距离</li>
<li>right 右侧偏移量，定义元素相对其父元素右边线的距离</li>
</ul>
<p>如果一个定位盒子既设置了 left，又设置了 right，则默认会执行 left；如果一个定位盒子既设置了 top，又设置了 bottom，则默认会执行 top。不过一般情况，我们也不会为同一个定位盒子这样设置边偏移</p>
<h3 id="定位模式">定位模式</h3>
<p>定位模式用于指定一个元素在文档中的定位方式</p>
<ul>
<li>position
<ul>
<li>static 静态定位（了解）</li>
<li>relative 相对定位（重要）</li>
<li>absolute 绝对定位（重要）</li>
<li>fixed 固定定位（重要）</li>
<li>sticky 粘性定位（了解）</li>
</ul>
</li>
</ul>
<h4 id="static-静态定位">static 静态定位</h4>
<p>静态定位就是元素的默认定位方式，无定位的意思。静态定位按照标准流特性摆放位置，它没有边偏移</p>
<h4 id="relative-相对定位">relative 相对定位</h4>
<p>相对定位在元素移动位置时，是相对于它原来的位置来移动的</p>
<ul>
<li>相对定位最典型的应用就是给绝对定位当爹的</li>
<li>移动前在标准流的位置会继续占有，也就是<strong>不脱标</strong></li>
</ul>
<pre><code>.one {
    position: relative;
    top: 100px;
    left: 100px;
    width: 200px;
    height: 200px;
    background-color: purple;
}
.two {
    width: 200px;
    height: 200px;
    background-color: gray;
}
&lt;div class=&quot;one&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;two&quot;&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1601863410.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h4 id="absolute-绝对定位">absolute 绝对定位</h4>
<p>绝对定位是相对于它的祖先元素来移动位置的</p>
<ul>
<li>如果绝对定位的元素没有祖先元素，或者<strong>祖先元素没有定位</strong>，则以浏览器为准定位</li>
</ul>
<pre><code>.father {
    width: 200px;
    height: 200px;
    background-color: purple;
}
.son {
    position: absolute;
    top: 100px;
    right: 100px;
    width: 200px;
    height: 200px;
    background-color: gray;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1601863424.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<ul>
<li>如果祖先元素有定位（相对定位、绝对定位、固定定位都可以），则以<strong>最近</strong>一级有定位的祖先元素为参考点移动位置</li>
<li>绝对定位不再占有原先的位置，也就是会<strong>脱标</strong></li>
</ul>
<p>子绝父相：子绝父相是开发中常用的定位方式，即：子级使用相对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其它兄弟的盒子；父盒子需要加定位限制子盒子在父盒子内的显示；父盒子布局时，需要占有位置，因此父亲只能是相对定位，这就是父觉子相的由来。<strong>总结：因为父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位</strong></p>
<h4 id="fixed-固定定位">fixed 固定定位</h4>
<p>固定定位用于指定元素固定于浏览器可视窗口的位置</p>
<ul>
<li>以浏览器的<strong>可视窗口</strong>为参照点移动元素</li>
</ul>
<pre><code>div {
    position: fixed;
    top: 20px;
    right: 100px;
}    
&lt;div&gt;&lt;img src=&quot;./images/pvp.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1601863442.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
缩小浏览器窗口：<br>
<img src="http://image.kuranado.com/blog/1601863448.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></p>
<ul>
<li>跟父元素没有任何关系</li>
<li>不会随滚动条滚动</li>
<li>固定定位不占有原先的位置，也就是会脱标</li>
</ul>
<p>固定定位小技巧：固定在版心右侧位置：</p>
<ol>
<li>让固定定位的盒子 left: 50%，也就是走到浏览器可视区域（也可以看做版心）的一半的位置</li>
<li>为固定定位的盒子添加 margin-left: 版心宽度一般的距离，当然也可以再多加几像素，保留一定空间<br>
这样就可以让固定定位的盒子贴着版心右侧对齐了</li>
</ol>
<pre><code>/* 版心 */
.w {
    margin: 0 auto;
    width: 800px;
    height: 1400px;
    background-color: hotpink;
}
/* 固定定位盒子 */
.fixed {
    position: fixed;
    top: 200px;
    left: 50%;
    margin-left: 405px;
    width: 50px;
    height: 100px;
    background-color: skyblue;
}
&lt;div class=&quot;w&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1601863460.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h4 id="粘性定位">粘性定位</h4>
<p>粘性定位可以被认为是相对定位和固定定位的混合</p>
<ul>
<li>以浏览器的可视窗口为参照点移动元素（固定定位的特点）</li>
<li>粘性定位占有原先的位置（相对定位的特点）</li>
<li>必须添加 top、left、right、bottom 中的其中一个才生效</li>
<li>兼容性较差（IE 完全不支持）</li>
</ul>
<pre><code>body {
    height: 3000px;
}
.nav {
    position: sticky;
    top: 0;
    width: 800px;
    height: 50px;
    margin: 200px auto;
    background-color: skyblue;
}
&lt;div class=&quot;nav&quot;&gt;我是粘性定位&lt;/div&gt;
</code></pre>
<p>起始位置：<br>
<img src="http://image.kuranado.com/blog/1601863470.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
鼠标滚动到为粘性定位盒子设置的 top 值时，盒子将黏住不再跟着滚动：<br>
<img src="http://image.kuranado.com/blog/1601863477.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></p>
<h2 id="定位的层叠次序">定位的层叠次序</h2>
<p>在使用定位布局时，可能会出现盒子重叠的情况，这时需要使用 z-index 属性控制盒子的上下顺序</p>
<ul>
<li>z-index 属性值可以是整数、0 或负数，数值越大，盒子越靠上，如果没有指定数值，则默认值为 auto</li>
<li>如果属性值相同，则按照书写顺序，后来居上</li>
<li>数字后面不能加单位</li>
<li>只有定位的盒子才有 z-index 属性<br>
未加 index 按照书写顺序，后来居上：</li>
</ul>
<pre><code>div {
    position: absolute;
    top: 0;
    left: 0;
}
.one {
    width: 100px;
    height: 100px;
    background-color: red;
}
.two {
    width: 75px;
    height: 75px;
    background-color: green;
}
.three {
    width: 50px;
    height: 50px;
    background-color: blue;
}
&lt;div class=&quot;one&quot;&gt;我是第一个盒子&lt;/div&gt;
&lt;div class=&quot;two&quot;&gt;我是第二个盒子&lt;/div&gt;
&lt;div class=&quot;three&quot;&gt;我是第三个盒子&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1601863487.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>指定 z-index：</p>
<pre><code>div {
    position: absolute;
    top: 0;
    left: 0;
}
.one {
    z-index: 3;
    width: 100px;
    height: 100px;
    background-color: red;
}
.two {
    z-index: 2;
    width: 75px;
    height: 75px;
    background-color: green;
}
.three {
    z-index: 1;
    width: 50px;
    height: 50px;
    background-color: blue;
}
&lt;div class=&quot;one&quot;&gt;我是第一个盒子&lt;/div&gt;
&lt;div class=&quot;two&quot;&gt;我是第二个盒子&lt;/div&gt;
&lt;div class=&quot;three&quot;&gt;我是第三个盒子&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="5"><img src="http://image.kuranado.com/blog/1601863495.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="总结">总结</h2>
<table>
<thead>
<tr>
<th>定位模式</th>
<th>是否脱标</th>
<th>移动位置</th>
<th>是否常用</th>
</tr>
</thead>
<tbody>
<tr>
<td>static 静态定位</td>
<td>否</td>
<td>不能使用边偏移</td>
<td>很少</td>
</tr>
<tr>
<td>relative 相对定位</td>
<td>否（占有位置）</td>
<td>相对于自身位置移动</td>
<td>常用</td>
</tr>
<tr>
<td>absolute 绝对定位</td>
<td>是（不占有位置）</td>
<td>带有定位的父级</td>
<td>常用</td>
</tr>
<tr>
<td>fixed 固定定位</td>
<td>是（不占有位置）</td>
<td>浏览器的可视窗口</td>
<td>常用</td>
</tr>
<tr>
<td>stick 粘性定位</td>
<td>否（占有位置）</td>
<td>浏览器可视窗口</td>
<td>很少</td>
</tr>
</tbody>
</table>
<h2 id="拓展">拓展</h2>
<h3 id="如何让绝对定位的盒子水平居中垂直居中">如何让绝对定位的盒子水平居中/垂直居中</h3>
<p>首先加了绝对定位的盒子不能通过 margin: 0 auto; 水平居中，但是可以通过如下算法实现水平居中：</p>
<ol>
<li>left: 50%; 让盒子的左侧移动到父级元素的水平中心位置</li>
<li>margin-left: 负的盒子自身宽度一半的px; 让盒子向左移动自身宽度的一半</li>
</ol>
<pre><code>div {
    position: absolute;
    left: 50%;
    margin-left: -100px;
    width: 200px;
    height: 200px;
    background-color: skyblue;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1601863507.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
改变浏览器窗口大小，盒子也始终处于水平居中位置</p>
<p>同理如果让盒子垂直居中，则算法如下：</p>
<ol>
<li>top: 50%; 让盒子的上侧移动到父级元素的垂直中心位置</li>
<li>margin-top: 负的盒子自身高度一半的px; 让盒子向上移动自身高度的一半</li>
</ol>
<p>如果想让盒子既水平又垂直居中，算法如下：</p>
<ol>
<li>
<p>left: 50%;</p>
</li>
<li>
<p>margin-left: 负的盒子自身宽度一半的px;</p>
</li>
<li>
<p>top: 50%;</p>
</li>
<li>
<p>margin-top: 负的盒子自身高度一半的px;</p>
</li>
</ol>
<h3 id="绝对定位或固定定位的特殊特性">绝对定位或固定定位的特殊特性</h3>
<ol>
<li>行内元素添加绝对定位或固定定位，可以直接设置宽度和高度</li>
</ol>
<pre><code>span {
    position: absolute;
    width: 100px;
    height: 100px;
    background-color: skyblue;
}
&lt;span&gt;Hello&lt;/span&gt;
</code></pre>
<figure data-type="image" tabindex="6"><img src="http://image.kuranado.com/blog/1601863520.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<ol start="2">
<li>块级元素添加绝对定位或固定定位，如果不给宽度或高度，则默认大小是内容的大小</li>
</ol>
<pre><code>div {
    position: absolute;
    background-color: skyblue;
}
&lt;div&gt;Hello&lt;/div&gt;
</code></pre>
<p><img src="http://image.kuranado.com/blog/1601863533.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
3. 绝对定位或固定定位会完全压住盒子<br>
和浮动元素不同，浮动元素只会压住下面标准流的盒子，而不会压住下面标准流盒子里的文字或图片，但绝对定位或固定定位会压住下面标准流所有的内容：</p>
<pre><code>* {
    margin: 0;
    padding: 0;
}
div {
    position: absolute;
    width: 100px;
    height: 100px;
    background-color: skyblue;
}
&lt;div&gt;&lt;/div&gt;
&lt;p&gt;绝对定位或固定定位会压住下面标准流所有的内容&lt;/p&gt;
</code></pre>
<figure data-type="image" tabindex="7"><img src="http://image.kuranado.com/blog/1601863543.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 属性书写顺序.md]]></title>
        <id>http://blog.kuranado.com/post/css-shu-xing-shu-xie-shun-xu-md/</id>
        <link href="http://blog.kuranado.com/post/css-shu-xing-shu-xie-shun-xu-md/">
        </link>
        <updated>2020-10-04T02:21:22.000Z</updated>
        <content type="html"><![CDATA[<p>建议遵循以下规则：</p>
<ol>
<li>布局定位属性：display/position/float/clear/visibility/overflow（建议 display 第一个写，毕竟关系到模式）</li>
<li>自身属性：width/heigth/margin/padding/border/background</li>
<li>文本属性：color/font/text-decoration/text-align/vertical-align/white-space/break-word</li>
<li>其它属性（CSS3）：content/cursor/border-radius/box-shadow/text-shadow/background:linear-gradient/...</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 1 两数之和]]></title>
        <id>http://blog.kuranado.com/post/leetcode-1-liang-shu-zhi-he/</id>
        <link href="http://blog.kuranado.com/post/leetcode-1-liang-shu-zhi-he/">
        </link>
        <updated>2020-10-04T02:18:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-两数之和"><a href="https://leetcode-cn.com/problems/two-sum/">1 两数之和</a> 2020年3月15日星期日</h2>
<p>在 LeetCode 做的第一题，比起以前做的 OJ 系统，省去了编写繁琐、无脑的读取文件操作部分的代码，很人性化</p>
<h3 id="解法一-92ms">解法一 92ms</h3>
<p>暴力遍历</p>
<pre><code class="language-java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] result = new int[2];
        for (int i = 0; i &lt; nums.length; i++) {
            for (int j = i + 1; j &lt; nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    result[0] = i;
                    result[1] = j;
                    return result;
                }
            }
        }
        return result;
    }
}
</code></pre>
<h4 id="时间复杂度">时间复杂度</h4>
<p>O(n<sup>2</sup>)</p>
<h4 id="空间复杂度">空间复杂度</h4>
<p>O(1)</p>
<h3 id="解法二-4ms">解法二 4ms</h3>
<p>借助 Hash 表</p>
<pre><code class="language-java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(nums.length);
        for (int i = 0; i &lt; nums.length; i++) {
            int a = target - nums[i];
            if (map.containsKey(a)) {
                return new int[]{map.get(a), i};
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException();
    }
}
</code></pre>
<h4 id="个人观点">个人观点</h4>
<p>题目并没有明确提到给定数组中不会出现重复元素，但根据题意，如果真的有重复元素，那结果就可能会有多个，真的有重复数据，就会自动覆盖掉，代码仍可以返回其中一组答案，所以把数组元素当作 map 的 key 也是没有问题的</p>
<h4 id="时间复杂度-2">时间复杂度</h4>
<p>O(n)<br>
遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间</p>
<h4 id="空间复杂度-2">空间复杂度</h4>
<p>O(n)<br>
所需的额外空间取决于哈希表中存储的元素数量，最多存储 n 个元素</p>
]]></content>
    </entry>
</feed>