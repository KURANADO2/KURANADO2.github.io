<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.kuranado.com</id>
    <title>KURANADO</title>
    <updated>2020-10-27T15:32:18.701Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.kuranado.com"/>
    <link rel="self" href="http://blog.kuranado.com/atom.xml"/>
    <subtitle>笔记/博客</subtitle>
    <logo>http://blog.kuranado.com/images/avatar.png</logo>
    <icon>http://blog.kuranado.com/favicon.ico</icon>
    <rights>All rights reserved 2020, KURANADO</rights>
    <entry>
        <title type="html"><![CDATA[LeetCode - 365. 水壶问题]]></title>
        <id>http://blog.kuranado.com/post/leetcode-365-shui-hu-wen-ti/</id>
        <link href="http://blog.kuranado.com/post/leetcode-365-shui-hu-wen-ti/">
        </link>
        <updated>2020-10-27T15:30:26.000Z</updated>
        <content type="html"><![CDATA[<h2 id="365-水壶问题"><a href="https://leetcode-cn.com/problems/water-and-jug-problem/">365. 水壶问题</a> 2020年3月21日星期六</h2>
<p>月度打卡题<br>
提交了 5 次，代码 50 行左右，'除零异常、超时（死循环）、解答错误，晚上 11 点多，看了题解，是个数学问题，几行代码搞定。感受到智商被碾压，服气，很服气！！！</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1603812653.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>首先看两个示例：<br>
示例 1：x = 3, y = 5, z = 4<br>
示例 2：x = 3, y = 11, z = 13<br>
对于示例 1：可以满足题目条件，具体操作步骤为：</p>
<ol>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 0 + 3 = 3L</li>
<li>A 装满水，倒到 B 中，因为 A 剩下的容量为 y - 3 = 2L，所以 A 只能向 B 中倒入 2L 水，剩下 1L 留在 A 中。此时 A 中水量为 1L，B 中水量为 5L</li>
<li>B 中水全部倒掉，A 中的 1L 水倒入 B 中。此时 A 中水量为 0L，B 中水量为 1L</li>
<li>A 装满水。此时 A 中水量为 3L，B 中水量为 1L，加在一块等于 4L，也就是等于 z，示例一数据满足条件</li>
</ol>
<p>对于示例 2：可以满足题目条件，具体操作步骤为：</p>
<ol>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 0 + 3 = 3L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 3 + 3 = 6L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 6 + 3 = 9L</li>
<li>A 装满水，倒到 B 中，因为 A 剩下的容量为 y - 9 = 2L，所以 A 只能向 B 中倒入 2L 水，剩下 1L 留在 A 中。此时 A 中水量为 1L，B 中水量为 11L</li>
<li>B 中水全部倒掉，A 中的 1L 水倒入 B 中。此时 A 中水量为 0L，B 中水量为 1L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 1 + 3 = 4L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 4 + 3 = 7L</li>
<li>A 装满水，倒到 B 中。此时 A 中水量为 0L，B 中水量为 7 + 3 = 10L</li>
<li>A 装满水，倒到 B 中，因为 A 剩下的容量为 y - 10 = 1L，所以 A 只能向 B 中倒入 1L 水，剩下 2L 留在 A 中。此时 A 中水量为 2L，B 中水量为 11L，加在一块等于 13L，也就是等于 z，示例二数据满足条件</li>
</ol>
<p>从上面的模拟可以发现，我们的每一步操作，都只会给水的总量带来 x 或 y 的变化，即要么增加或减少 xL 水，要么增加或减少 yL 水<br>
如对于示例一的每一步操作，两壶水的总量变化如下：</p>
<ol>
<li>A 中水量为 0L，B 中水量为 3L，总水量 = 0 + 3 = 3L</li>
<li>A 中水量为 1L，B 中水量为 5L，总水量 = 1 + 5 = 6L</li>
<li>A 中水量为 0L，B 中水量为 1L，总水量为 0 + 1 = 1L</li>
<li>A 中水量为 3L，B 中水量为 1L，总水量为 3 + 1 = 4L</li>
</ol>
<p>确实是每一步操作都只会对两壶水的总量带来 x 或 y 的变化，对于示例一，变化过程为 0 + x + x - y + x = 0 + 3 + 3 - 5 + 3 = 4<br>
同样对于示例二，也是满足这个规律的，此处就不再赘述了<br>
也就是说，只要能够找到一对整数 a、b，满足 ax + by = z，就说明是满足条件的，例如对于示例一，a = 3，b = -1<br>
根据<a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86&amp;fromid=5185441">裴蜀定理</a>：<br>
<strong>ax + by = z 有解当且仅当 z 是 x，y 的最大公约数的倍数</strong>，也就是 z % gcd(x, y) == 0</p>
<p>以上就是本题的解题思路，此外还需要注意，如果 z == 0 是直接满足条件的，不需要进行任何计算。另外这里求最大公约数的算法为欧几里得算法。最终代码如下：</p>
<h3 id="最终代码-0ms">最终代码 0ms</h3>
<pre><code class="language-java">class Solution {
    public boolean canMeasureWater(int x, int y, int z) {
        return z == 0 || (x + y &gt;= z &amp;&amp; z % gcd(x, y) == 0);
    }

    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 3. 无重复字符的最长子串]]></title>
        <id>http://blog.kuranado.com/post/leetcode-3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/</id>
        <link href="http://blog.kuranado.com/post/leetcode-3-wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/">
        </link>
        <updated>2020-10-26T12:40:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="3-无重复字符的最长子串"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a> 2020年3月20日星期五 - 2020年3月21日星期六</h2>
<p>做完最小的 k 个数完成打卡，紧接着看了这一题，先用 Set 实现了一遍，执行用时 131 ms，第二天，在 iPad 上画了点草稿，使用双层循环又实现了一遍，执行用时 6ms</p>
<h3 id="解法一-131ms">解法一 131ms</h3>
<p>代码简单明了，但用时很多</p>
<pre><code class="language-java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        int max = -1;
        Set&lt;Character&gt; set = new HashSet&lt;&gt;();
        int j = 0;
        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            boolean add = set.add(c);
            if (!add) {
                if (set.size() &gt; max) {
                    max = set.size();
                }
                set.clear();
                while (j &lt; i) {
                    if (s.charAt(j) == c) {
                        i = j;
                        j++;
                        break;
                    }
                    j++;
                }
            }
        }
        return Math.max(set.size(), max);
    }
}
</code></pre>
<h3 id="解法二-6ms">解法二 6ms</h3>
<p>代码其实也不难，需要定义一个变量跳索引，用于跳过已经判断过的符号。第一次提交时，没有判断输入是空字符串的情况，导致判题返回解答错误</p>
<pre><code class="language-java">class Solution {
    public int lengthOfLongestSubstring(String s) {
        if (&quot;&quot;.equals(s)) {
            return
                0;
        }
        int max = -1;
        int tmp = 0;
        int length = 1;
        for (int i = 0; i &lt; s.length(); i++) {
            for (int j = tmp; j &lt; i; j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    length = i - tmp;
                    tmp = j + 1;
                    break;
                }
                if (j == s.length() - 2) {
                    length = s.length() - tmp;
                }
            }
            if (length &gt; max) {
                max = length;
            }
        }
        return max;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 409. 最长回文串]]></title>
        <id>http://blog.kuranado.com/post/leetcode-409-zui-chang-hui-wen-chuan/</id>
        <link href="http://blog.kuranado.com/post/leetcode-409-zui-chang-hui-wen-chuan/">
        </link>
        <updated>2020-10-24T03:28:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="409-最长回文串"><a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a> 2020年3月19日星期四</h2>
<p>月度打卡题</p>
<p>仔细研究了下规律，得到如下结论：</p>
<ul>
<li>字母个数如果是偶数，则必然满足，直接把个数相加</li>
<li>如果只有一个字母的个数是奇数，则必然满足，直接把该字母对应个数（奇数）直接相加</li>
<li>如果存在 &gt; 1 个字母的个数是奇数，则其中任意一个字母个数（奇数）直接相加，其他字母个数 - 1 后再相加</li>
</ul>
<p>综上，其实最终结论就是：只要是字母对应个数是偶数，直接相加，如果是奇数，第一个奇数也直接相加，剩余的奇数 - 1 后再相加</p>
<h3 id="最终代码-3ms">最终代码 3ms</h3>
<pre><code class="language-java">class Solution {
    public int longestPalindrome(String s) {
        int[] arr = new int[52];

        for (int i = 0; i &lt; s.length(); i++) {
            char c = s.charAt(i);
            if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {
                arr[c - 'A']++;
            }
            if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {
                arr[c - 71]++;
            }
        }
        int sum = 0;
        boolean firstOdd = true;
        int odd = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            if (arr[i] == 0) {
                continue;
            }
            if (arr[i] % 2 == 0) {
                sum += arr[i];
            } else {
                sum += arr[i] - 1;
                odd = 1;
            }
        }
        sum += odd;
        return sum;
    }
}
</code></pre>
<p>LeetCode 上 1ms 的执行范例：</p>
<pre><code class="language-java">class Solution {
    public int longestPalindrome(String s) {
        if (s == null) return 0;
        
        int[] f = new int[75];
        for (char ch : s.toCharArray()) {
            f[ch - '0']++;
        }
        int res = 0, odd = 0;
        for (int num : f) {
            if (num == 0) continue;
            res += num / 2 * 2;
            
            if (num % 2 == 1) {
                odd = 1;    
            } 
        }
        res += odd;
        return res;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见正则示例.md]]></title>
        <id>http://blog.kuranado.com/post/chang-jian-zheng-ze-shi-li-md/</id>
        <link href="http://blog.kuranado.com/post/chang-jian-zheng-ze-shi-li-md/">
        </link>
        <updated>2020-10-22T13:21:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="url">URL</h2>
<p>简单写法：</p>
<h3 id="表达式">表达式</h3>
<pre><code>https?:\/\/[-\w.]+(:\d+)?(\/([\w\/_.]*)?)?
</code></pre>
<ul>
<li><code>https?:\/\/</code> 匹配 <code>http://</code> 或 <code>https://</code></li>
<li><code>[-\w.]+</code> 匹配主机名</li>
<li><code>(:\d+)?</code> 匹配一个可选的端口号</li>
<li><code>(\/([\w\/_.]*)?)?</code> 匹配路径</li>
</ul>
<h3 id="测试文本">测试文本</h3>
<pre><code>https://www.forta.com/blog
https://www.forta.com:80/blog/index.do
http://www.forta.com
http://ben:password@www.forta.com/
http://localhost/index.php?username=1&amp;type=2
http://localhost:8500
</code></pre>
<h3 id="匹配结果">匹配结果</h3>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1603372932.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>虽然第四条和第五条匹配不正确，但该写法已经可以满足绝大部分使用场景了，如需要匹配的更精准，参考下面的写法：</p>
<p>复杂写法：</p>
<h3 id="表达式-2">表达式</h3>
<pre><code>https?:\/\/(\w*:\w*@)?[-\w.]+(:\d+)?(\/([\w\/_.]*(\?\S+)?)?)?
</code></pre>
<ul>
<li><code>(\w*:\w*@)?</code> 匹配 Url 中的用户名和密码</li>
<li><code>(\?\S+)?</code> 匹配查询参数</li>
</ul>
<h3 id="匹配结果-2">匹配结果</h3>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1603372958.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>这种写法虽然匹配的更精准，但性能上也会大打折扣</p>
<hr>
<h2 id="ip-地址">IP 地址</h2>
<p>IP 地址范围为 0.0.0.0 ~ 255.255.255.255，总结如下：</p>
<ol>
<li>任意的 1 位或 2 位数字</li>
<li>任意的以 1 开头的 3 位数字</li>
<li>任意的以 2 开头，第二位数字在 0 到 4 之间的 3 位数字</li>
<li>任意的以 25 开头，第三位数字在 0 到 5 之间的 3 位数字<br>
很容易写出如下正则：</li>
</ol>
<pre><code>(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))
</code></pre>
<p>但这个正则却是错误的，如 IP 地址：<code>12.159.46.200</code> 的匹配结果如下图，最后的 0 无法被匹配，这是因为 <code>20</code> 已经被子表达式 <code>(\d{1, 2})</code> 匹配，并没有被 <code>(25[0-5])</code> 匹配<br>
<img src="http://image.kuranado.com/blog/1603372978.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"><br>
正确的写法如下：</p>
<pre><code>((((25[0-5])\d)|(2[0-4]\d)|(1\d{2})|(\d{1,2}))\.){3}(((25[0-5])\d)|(2[0-4]\d)|(1\d{2})|(\d{1,2}))
</code></pre>
<p>匹配结果：<br>
<img src="http://image.kuranado.com/blog/1603372987.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></p>
<hr>
<h2 id="邮箱地址">邮箱地址</h2>
<h3 id="表达式-3">表达式</h3>
<pre><code>(\w+\.)*\w+@(\w+\.)+[A-z]+
</code></pre>
<h3 id="测试文本-2">测试文本</h3>
<pre><code>jing@163.com
jing.xin@mail.kuranado.com
</code></pre>
<h3 id="匹配结果-3">匹配结果</h3>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1603372998.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<hr>
<h2 id="身份证号">身份证号</h2>
<h3 id="表达式-4">表达式</h3>
<pre><code>^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{4}$
</code></pre>
<h3 id="测试文本-3">测试文本</h3>
<pre><code>322225199809020429
</code></pre>
<h2 id="手机号">手机号</h2>
<h3 id="表达式-5">表达式</h3>
<pre><code>^1(3|4|5|6|7|8|9)\d{9}$
</code></pre>
<h3 id="测试文本-4">测试文本</h3>
<pre><code>18855465629
</code></pre>
<h2 id="html-注释">HTML 注释</h2>
<h3 id="表达式-6">表达式</h3>
<pre><code>&lt;!-{2,}.*?-{2,}&gt;
</code></pre>
<h3 id="测试文本-5">测试文本</h3>
<pre><code>&lt;!-- comment --&gt;
&lt;!---- -- comment -- -----&gt;
</code></pre>
<h3 id="匹配结果-4">匹配结果</h3>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1603373014.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<hr>
<h2 id="java-单行注释">Java 单行注释</h2>
<h3 id="表达式-7">表达式</h3>
<pre><code>\/\/.*
</code></pre>
<h3 id="测试文本-6">测试文本</h3>
<pre><code>// comment
</code></pre>
<h3 id="匹配结果-5">匹配结果</h3>
<figure data-type="image" tabindex="5"><img src="http://image.kuranado.com/blog/1603373023.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<hr>
<h2 id="java-多行注释">Java 多行注释</h2>
<h3 id="表达式-8">表达式</h3>
<pre><code>/\*[\s\S]*?\*/
</code></pre>
<h3 id="测试文本-7">测试文本</h3>
<pre><code>public class UpgradeEntity {
    /**
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database columnT_UPGRADE_TASK.ID
     *
     * @mbggenerated Wed Oct 14 14:39:23 CST 2020
     */
    private long id;

    /**
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database columnT_UPGRADE_TASK.UPGRADE_NAMES
     *
     * @mbggenerated Wed Oct 14 14:39:23 CST 2020
     */
    private String upgradeNames;

    /**
     * This field was generated by MyBatis Generator.
     * This field corresponds to the database columnT_UPGRADE_TASK.UPGRADE_DESCRIPTION
     *
     * @mbggenerated Wed Oct 14 14:39:23 CST 2020
     */
    private String upgradeDescription;
</code></pre>
<h3 id="匹配结果-6">匹配结果</h3>
<figure data-type="image" tabindex="6"><img src="http://image.kuranado.com/blog/1603373053.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="参考">参考</h2>
<ul>
<li>《正则表达式必知必会修订版》</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3 过渡.md]]></title>
        <id>http://blog.kuranado.com/post/css3-guo-du-md/</id>
        <link href="http://blog.kuranado.com/post/css3-guo-du-md/">
        </link>
        <updated>2020-10-19T11:06:04.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>transition: 要过渡的属性1 花费时间1 运动曲线1 何时开始1, 要过渡的属性2 花费时间2 运动曲线2 何时开始2; 谁想要过渡效果，就为谁设置 trasition 属性
<ul>
<li>要过渡的属性 即想要变化的 CSS 属性，如 width、heigth、background-color、padding、margin、border 都可以，如果想要所有的属性都有过渡效果，则将该值设置为 all</li>
<li>花费时间 过渡需要花费的时间，单位 s，如 .5s（单位 s 不可省略）</li>
<li>运动曲线 可省略，默认为 ease<br>
<img src="http://image.kuranado.com/blog/1603105590.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></li>
<li>何时开始 可省略，默认为 0s，表示立即触发。单位 s（单位 s 不可省略）</li>
</ul>
</li>
</ul>
<pre><code>div {
    width: 100px;
    height: 100px;
    background-color: skyblue;
    /* 口诀：过渡写到本身上，谁做动画给谁加 */
    transition: width 1s ease .5s;
}
div:hover {
    width: 200px;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<p>当鼠标悬浮在 div 上时，0.5s 后，该 div 的宽度会在 1s 内由原来的 100px 过渡到 200px</p>
<pre><code>div {
    width: 100px;
    height: 100px;
    background-color: skyblue;
    transition: width 1s ease .5s, heigth 1s ease .5s;
}
div:hover {
    width: 200px;
    height: 200px;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<p>当鼠标悬浮在 div 上时，0.5s 后，该 div 的宽度会在 1s 内由原来的 100px 过渡到 200px，同时高度也会在 1s 内由原来的 100px 过渡到 200px</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode - 836. 矩形重叠]]></title>
        <id>http://blog.kuranado.com/post/leetcode-836-ju-xing-chong-die/</id>
        <link href="http://blog.kuranado.com/post/leetcode-836-ju-xing-chong-die/">
        </link>
        <updated>2020-10-15T10:58:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="836-矩形重叠"><a href="https://leetcode-cn.com/problems/rectangle-overlap/">836. 矩形重叠</a> 2020年3月18日星期三</h2>
<p>月度打卡题<br>
刚开始在平板上画了画，发现重叠的情况有很多种，于是利用<strong>逆向思维</strong>，找出所有不重叠的情况，如下图，看起来比较复杂，但仔细一看，下图描述的情况其实非常简单，即如果不想交，则：矩形 r2 要么在矩形 r1 的左边，下面要么在矩形 r1 的右边，要么在矩形 r1 的上边，要么在矩形 r1 的下边，可以写出如下表达式：</p>
<p>r2.x<sub>2</sub> &lt; r1.x<sub>1</sub> || r2.x<sub>1</sub> &gt; r1.x<sub>2</sub> || r2.y<sub>1</sub> &gt; r1.y<sub>2</sub> || r2.y<sub>2</sub> &lt; r1.y<sub>1</sub></p>
<p>不重叠则是对上述表达式取反，大学学数字逻辑时，都知道取反后表达式为：</p>
<p>r2.x<sub>2</sub> &gt;= r1.x<sub>1</sub> || r2.x<sub>1</sub> &gt;= r1.x<sub>2</sub> || r2.y<sub>1</sub> &gt;= r1.y<sub>2</sub> || r2.y<sub>2</sub> &lt;= r1.y<sub>1</sub></p>
<p>由于题目要求只是边重叠并不算做矩形重叠，去掉等于号即可</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602759551.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h3 id="最终代码-0ms">最终代码 0ms</h3>
<pre><code class="language-java">class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        if (rec2[2] &gt; rec1[0] &amp;&amp; rec2[0] &lt; rec1[2] &amp;&amp; rec2[1] &lt; rec1[3] &amp;&amp; rec2[3] &gt; rec1[1]) {
            return true;
        }
        return false;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3 盒子模型.md]]></title>
        <id>http://blog.kuranado.com/post/css3-he-zi-mo-xing-md/</id>
        <link href="http://blog.kuranado.com/post/css3-he-zi-mo-xing-md/">
        </link>
        <updated>2020-10-14T08:26:55.000Z</updated>
        <content type="html"><![CDATA[<p>CSS3 通过 box-sizing 属性指定盒子模型</p>
<ul>
<li>box-sizing: content-box 盒子宽为 width + padding + border，高位 height + padding + border + magin 也就是默认的盒子模型。PC 端如果需要完全兼容，就用该传统模式</li>
</ul>
<pre><code>div {
    /* 盒子会被 padding 和 border 撑大 */
    box-sizing: content-box;
    width: 200px;
    height: 200px;
    background-color: skyblue;
    padding: 20px;
    border: 20px solid pink;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602664045.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<ul>
<li>box-sizing: border-box <strong>重点</strong>，盒子宽就是 width（前提是设置的 padding 和 brorder 不会超过 width），高就是 height（前提是设置的 padding 和 brorder 不会超过 height）。PC 端如果不要求兼容，则使用该盒子模型；因为移动端浏览器都是比较新的内核，所以移动端全部使用该盒子模型</li>
</ul>
<pre><code>div {
    /* 盒子不会被 padding 和 border 撑大 */
    box-sizing: border-box;
    width: 200px;
    height: 200px;
    background-color: skyblue;
    padding: 20px;
    border: 20px solid pink;
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1602664056.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS3 选择器.md]]></title>
        <id>http://blog.kuranado.com/post/css3-xuan-ze-qi-md/</id>
        <link href="http://blog.kuranado.com/post/css3-xuan-ze-qi-md/">
        </link>
        <updated>2020-10-13T11:16:58.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="属性选择器">属性选择器</h2>
<pre><code>/* 选择所有拥有 type 属性的元素 */
input[type]
/* 选择所有拥有 type 属性，且该属性值为 password 的元素 */
input[type=&quot;password&quot;]
/* 选择所有以具有 class 属性，且属性值以 icon 开头的 div 标签 */
div[class^=&quot;icon&quot;]
/* 选择所有以具有 class 属性，且属性值以 icon 结尾的 div 标签 */
div[class$=&quot;icon&quot;]
/* 选择所有以具有 class 属性，且属性值中包含 icon 的 div 标签 */
div[class*=&quot;icon&quot;]
</code></pre>
<h2 id="结构伪类选择器">结构伪类选择器</h2>
<pre><code>/* 选择 ul 下的第一个子元素 */
ul :first-child
/* 选择 ul 下的第一个子元素，且该子元素必须是 li */
ul li:first-child
/* 选择 ul 下的第一个子元素，且该子元素必须是 li */
ul li:last-child
/* 选择 ul 下的第 3 （n 从 1 开始）个子元素，且该子元素必须是 li */
ul li:nth-child(3)
/* 选择 ul 下所有偶数位子元素（2、4、6...），且该子元素必须是 li */
ul li:nth-child(even)
/* 选择 ul 下所有偶数位子元素（1、3、5...），且该子元素必须是 li */
ul li:nth-child(odd)
/* 选择 ul 下所有 li 子元素（只能是字母 n，不能是其他字母），n 从 0 开始，每匹配一个元素后，n 自增 1（刚开始为 0，一个元素也匹配不到，自增为 1 后，菜开始匹配到元素） */
ul li:nth-child(n)
/* 选择 ul 下所有偶数位子元素（2、4、6...），且该子元素必须是 li（2 * 0、2 * 1、2 * 2、2 * 3...）*/
ul li:nth-child(2n)
/* 选择 ul 下所有奇数位子元素（1、3、5...），且该子元素必须是 li（2 * 0 + 1、2 * 1 + 1、2 * 2 + 1...）*/
ul li:nth-child(2n)
/* 选择 ul 下所有 5 的倍数位子元素（5、10、15...），且该子元素必须是 li */
ul li:nth-child(5n)
/* 选择 ul 下从第 5 个开始（包含第 5 个）后面的子元素（5、6、7...），且该子元素必须是 li（0 + 5、1 + 5、2 + 5） */
ul li:nth-child(n+5)
/* 选择 ul 下前 5 （包含第 5 个）子元素（1、2、3、4、5），且该子元素必须是 li（-0 + 5、-1 + 5、-2 + 5、-3 + 5、-4 + 5）*/
ul li:nth-child(-n+5)
</code></pre>
<p>nth-child() 和 nth-of-type() 用法完全相同，都可以在括号中填数字，关键字（even、odd）和公式（如 n、2n、5n 等等），但 nth-child 和 nth-of-type 有如下区别：<br>
nth-child()：</p>
<pre><code>/* 没有选中任何元素，因为 nth-child 会先把所有的盒子都排列成序号，然后再看元素是否匹配，这里第一个 p 标签序号为 1，第一个 div 标签选好为 2，第二个 div 标签序号为 3，所以 nth-child(1) 先找到第一个 1 标签，然后校验该标签是否是 div 标签，因为第一个标签是 p 而不是 div，所以没有任何效果 */
section div:nth-child(1) {
    background-color: red;
}
&lt;section&gt;
    &lt;p&gt;光头强&lt;/p&gt;
    &lt;div&gt;熊大&lt;/div&gt;
    &lt;div&gt;熊二&lt;/div&gt;
&lt;/section&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602587848.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>nth-of-type()：</p>
<pre><code>/* 成功选中第一个 div，因为 nth-of-type 会对指定的盒子进行编号，这里制定了盒子必须是 div */
section div:nth-of-type(1) {
    background-color: red;
}
&lt;section&gt;
    &lt;p&gt;光头强&lt;/p&gt;
    &lt;div&gt;熊大&lt;/div&gt;
    &lt;div&gt;熊二&lt;/div&gt;
&lt;/section&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1602587861.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="伪元素选择器">伪元素选择器</h2>
<p>帮助我们使用 CSS 创建新标签，而不需要显示去写 HTML 标签，从而简化 HTML 结构</p>
<table>
<thead>
<tr>
<th>选择符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>::before</td>
<td>在父元素内容的前面创建元素</td>
</tr>
<tr>
<td>::after</td>
<td>在父元素内容的后面创建元素</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>::before 和 ::after 创建的伪元素属于行内元素（根据需要将其转换为块级元素或行内块元素）</li>
<li>新创建的这个元素在 DOM 树中是找不到的，所以称之为伪元素</li>
<li>before 和 after <strong>必须有 content 属性</strong>，即便内容为空</li>
</ul>
<pre><code>div {
    width: 200px;
    height: 100px;
    background-color: skyblue;
}
div::before {
    content: &quot;我&quot;;
}
div::after {
    content: &quot;小猪佩奇&quot;;
}
&lt;div&gt;
    是
&lt;/div&gt;
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1602587871.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 浏览器私有前缀.md]]></title>
        <id>http://blog.kuranado.com/post/css-liu-lan-qi-si-you-qian-zhui-md/</id>
        <link href="http://blog.kuranado.com/post/css-liu-lan-qi-si-you-qian-zhui-md/">
        </link>
        <updated>2020-10-11T03:33:57.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<blockquote>
<p>浏览器私有前缀是为了兼容老版本的浏览器，如果 CSS 代码只运行在较新版本的浏览器上则无需添加</p>
</blockquote>
<h2 id="私有前缀">私有前缀</h2>
<ul>
<li><code>-moz-</code> Firefox 的私有前缀</li>
<li><code>-ms-</code> IE 的私有前缀</li>
<li><code>-webkit-</code> Safari 和 Chrome 的私有前缀</li>
<li><code>-o-</code> Opera 的私有前缀</li>
</ul>
<p>国产浏览器基本也全是使用上面四种前缀中的一种</p>
<h2 id="提倡写法">提倡写法</h2>
<p>先写私有前缀，再写不带前缀，例如：</p>
<pre><code>-moz-border-radius: 10px;
-webkit-border-radius: 10px;
-o-border-radius: 10px;
border-radius: 10px;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS margin 负值的巧妙应用.md]]></title>
        <id>http://blog.kuranado.com/post/css-margin-fu-zhi-de-qiao-miao-ying-yong-md/</id>
        <link href="http://blog.kuranado.com/post/css-margin-fu-zhi-de-qiao-miao-ying-yong-md/">
        </link>
        <updated>2020-10-10T11:21:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="margin-负值的巧妙运用">margin 负值的巧妙运用</h2>
<p>先看如下代码：</p>
<pre><code>ul li {
    float: left;
    list-style: none;
    width: 100px;
    height: 100px;
    border: 1px solid skyblue;
}
&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1602328932.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>可以看到相邻 li 之间的 border 左右贴在一块，像素数为 2，而我们一般不需要这种效果，所以向左浮动时，可以让每个 li margin-left = -1，即每个 li 向左多走一个像素，这样就能让相邻的 border 上下重叠：</p>
<pre><code>ul li {
    float: left;
    margin-left: -1px;
    list-style: none;
    width: 100px;
    height: 100px;
    border: 1px solid skyblue;
}
&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1602328945.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>效果是实现了，如果现在要求鼠标悬浮在某个 li 上面时，将其边框改成红色，相信大家很容易写出如下代码：</p>
<pre><code>ul li:hover {
    border: 1px solid red;
}
</code></pre>
<p>鼠标悬浮在最后一个 li 上，它的四个边框确实都变成了红色，但是鼠标移到前三个 li 上时，边框却是如下效果：</p>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1602329410.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>这就是因为 margin-left: -1px; 导致左边 li 的右边框被右边 li 的左边框给压住了<br>
为了解决这个问题，可以在鼠标悬浮时为 li 添加一个 relative 定位，因为 relative 定位占有原先的位置（不脱标）且会压住浮动的盒子：</p>
<pre><code>ul li:hover {
    position: relative;
    border: 1px solid red;
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1602328967.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>那如果每个 li 中上面都有一些元素，比如按钮，就需要每个 li 都是相对定位，li 上面的元素使用绝对定位，这时候在鼠标悬浮到某个 li 时，只要给当前鼠标悬浮的 li 设置一个更大的 z-index 就可以正常压住其他 li 的边框了</p>
]]></content>
    </entry>
</feed>