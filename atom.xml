<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.kuranado.com</id>
    <title>KURANADO</title>
    <updated>2020-09-30T01:05:26.126Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.kuranado.com"/>
    <link rel="self" href="http://blog.kuranado.com/atom.xml"/>
    <subtitle>笔记/博客</subtitle>
    <logo>http://blog.kuranado.com/images/avatar.png</logo>
    <icon>http://blog.kuranado.com/favicon.ico</icon>
    <rights>All rights reserved 2020, KURANADO</rights>
    <entry>
        <title type="html"><![CDATA[CSS 选择器.md]]></title>
        <id>http://blog.kuranado.com/post/css-xuan-ze-qi-md/</id>
        <link href="http://blog.kuranado.com/post/css-xuan-ze-qi-md/">
        </link>
        <updated>2020-09-30T03:14:07.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="基础选择器">基础选择器</h2>
<h3 id="标签选择器">标签选择器</h3>
<pre><code>/** 选择所有 p 标签 **/
p {
    color: red;
}
</code></pre>
<h3 id="类选择器">类选择器</h3>
<pre><code>/** 选择所有 class 属性值为 red 的标签 **/
.red {
    color: red;
}
&lt;p class=&quot;red&quot;&gt;Hello&lt;/p&gt;
</code></pre>
<h3 id="类选择器-多类名">类选择器-多类名</h3>
<pre><code>.box {
    width: 100px;
    height: 100px;
    font-size: 35px;
}
.red {
    color: red;
}
.green {
    color: green;
}
&lt;div class=&quot;box red&quot;&gt;红色&lt;/div&gt;
&lt;div class=&quot;box green&quot;&gt;绿色&lt;/div&gt;
&lt;div class=&quot;box red&quot;&gt;红色&lt;/div&gt;
</code></pre>
<h3 id="id-选择器">ID 选择器</h3>
<pre><code>#pink {
    color: pink;
}
&lt;p id=&quot;pink&quot;&gt;Hello&lt;/p&gt;
</code></pre>
<h3 id="通配符选择器">通配符选择器</h3>
<pre><code>/** 选择页面所有标签 **/
* {
    maring: 0;
    padding: 0;
}
</code></pre>
<h2 id="复合选择器">复合选择器</h2>
<h3 id="后代选择器又称包含选择器重要">后代选择器（又称包含选择器，重要）</h3>
<pre><code>/** 选择 ol 下的所有 li 标签（包括子元素、孙子元素、重孙等） **/
ol li {
    color: pink;
}
</code></pre>
<h3 id="子选择器重要">子选择器（重要）</h3>
<pre><code>/** 只选择第一代子元素（只选择亲儿子） **/
div &gt; a {
    color: red;
}
</code></pre>
<h3 id="并集选择器重要">并集选择器（重要）</h3>
<pre><code>/** 选择 div 标签、 p 标签和 .nav 下的 ul 下的 li 标签 **/
div, 
p, 
.nav ul li {
    color: red;
}
</code></pre>
<h3 id="伪类选择器">伪类选择器</h3>
<h4 id="链接伪类选择器">链接伪类选择器</h4>
<pre><code>/** 选择所有未被点击过的链接（不常用，一般直接用 a 标签选择器选择） **/
a:link {
    color: black;
}
/** 选择所有点击过的链接 **/
a:visited {
    color: orange;
}
/** 选择鼠标悬浮的链接，最常用 **/
a:hover {
    color: blue;
}
/** 选择鼠标按下，还没有抬起的链接 **/
a:active {
    color: green;
}
</code></pre>
<p>一般只会用到 a:hover 选择器，如果 4 个链接伪类选择器都要使用，则一定要按照 <strong>LVHA</strong> 的先后顺序定义，否则将不会生效</p>
<h4 id="focus-伪类选择器">focus 伪类选择器</h4>
<pre><code>/** 选择获取焦点的表单元素 **/
input:focus {
    background-color: yellow;
}
</code></pre>
<h2 id="选择器权重优先级">选择器权重（优先级）</h2>
<ul>
<li>!import &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器，伪类选择器 &gt; 标签选择器 &gt; 继承或者 <code>*</code></li>
</ul>
<table>
<thead>
<tr>
<th>选择器</th>
<th>权重</th>
</tr>
</thead>
<tbody>
<tr>
<td>继承或者 <code>*</code></td>
<td>0 0 0 0</td>
</tr>
<tr>
<td>标签选择器，伪元素选择器</td>
<td>0 0 0 1</td>
</tr>
<tr>
<td>类选择器，伪类选择器，属性选择器（CSS3）</td>
<td>0 0 1 0</td>
</tr>
<tr>
<td>ID 选择器</td>
<td>0 1 0 0</td>
</tr>
<tr>
<td>行内样式</td>
<td>1 0 0 0</td>
</tr>
<tr>
<td>!import</td>
<td>无穷大</td>
</tr>
</tbody>
</table>
<ul>
<li>浏览器为 a 标签默认指定了蓝色、带下划线的样式，如：</li>
</ul>
<pre><code>body {
    color: red;
}
&lt;body&gt;
    &lt;!-- 显示为蓝色带下划线，因为浏览器默认为 a 标签指定了蓝色下划线，而标签选择器优先级 &gt; 继承，所以最终显示为蓝色带下划线 --&gt;
    &lt;a href=&quot;#&quot;&gt;链接&lt;/a&gt;
&lt;/body&gt;
</code></pre>
<ul>
<li>复合选择器会有权重叠加，如：</li>
</ul>
<pre><code>ul li {
    color: red;
}
li {
    color: green;
}
&lt;ul&gt;
    &lt;!-- 显示为红色，而不是绿色，因为标签选择器的权重为 0 0 0 1，所以复合选择器 ul li 的权重为 0 0 0 1 + 0 0 0 1 = 0 0 0 2，0 0 0 2 &gt; 标签选择器 li 的权重 0 0 0 1，所以最后显示为红色而不是绿色 --&gt;
    &lt;li&gt;Hello&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>再如：</p>
<pre><code>.nav li {
    color: pink;
}
ul li {
    color: red;
}
li {
    color: green;
}
&lt;ul class=&quot;nav&quot;&gt;
    &lt;!-- 显示为粉色，不是红色也不是绿色，复合选择器 .nav li 的权重为 0 0 1 0 + 0 0 0 1 = 0 0 1 1，该值大于复合选择器 ul li 的权重 0 0 0 2，也大于标签选择器 li 的权重 0 0 0 1，所以最后显示为粉色 --&gt;
    &lt;li&gt;Hello&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<ul>
<li>权重虽然会有叠加，但一定不会有进位，如 0 0 0 9 + 0 0 0 2 = 0 0 0 11 而不是 0 0 1 1</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[同时管理 GitHub/GitLab/Gitee 等多个 SSH  Key.md]]></title>
        <id>http://blog.kuranado.com/post/githubgitlab-tong-shi-guan-li-duo-ge-ssh-keymd/</id>
        <link href="http://blog.kuranado.com/post/githubgitlab-tong-shi-guan-li-duo-ge-ssh-keymd/">
        </link>
        <updated>2020-09-29T01:17:21.000Z</updated>
        <content type="html"><![CDATA[<p>平时在 GitHub 拉取、提交代码时都是通过本地放置 <code>~/.ssh/id_rsa</code> 私钥，GitHub 账号下配置公钥 <code>id_rsa.pub</code> 完成的<br>
但除了 GitHub，有时候还需要用到 GitLab、Gitee 等代码托管平台，如何在同一台电脑上配置多对秘钥呢？</p>
<h2 id="生成-ssh-key">生成 ssh key</h2>
<p>生成并添加第一个ssh key</p>
<pre><code>cd ~/.ssh
ssh-keygen -t rsa -C &quot;youremail@163.com&quot;
</code></pre>
<p>这时可以一路回车，不输入任何字符，将自动生成 id_rsa 和 id_rsa.pub 文件<br>
然后把 id_rsa.pub 内容添加到 GitHub 账号下，私钥保留在 <code>~/.ssh</code> 目录</p>
<p>生成并添加第二个ssh key</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;youremail@163.com&quot;
</code></pre>
<p>注意，这时不能一路回车，否则邮箱将覆盖上一次生成的 ssh key，给这个文件起一个名字， 比如叫 id_rsa_gitlab, 相应的也会生成一个 id_rsa_gitlab.pub 文件。</p>
<p>此时查看 <code>~/.ssh</code> 下的目录文件，发现多了 id_rsa_gitlab 和 id_rsa_gitlab.pub 两个文件<br>
同样，将 id_rsa_gitlab.pub 文件内容复制到 GitLab 账号下，id_rsa_gitlab 文件留在 <code>~/.ssh</code> 目录下</p>
<h2 id="增加修改配置文件">增加/修改配置文件</h2>
<p>在 <code>~/.ssh</code> 目录下新建一个 config 文件</p>
<pre><code>touch config
</code></pre>
<p>并添加以下内容</p>
<pre><code># gitlab
Host gitlab.com
    HostName gitlab.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/id_rsa
# github
Host github.com
    HostName github.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/id_rsa_github
</code></pre>
<p><strong>需要注意的是，公司一般都是自建 GitLab，如公司自建 GitLab 地址为 <code>http://gitlab.companyname.com</code>，则 Host 和 HostName 就需要配置为 <code>gitlab.companyname.com</code> 才可以</strong>：</p>
<pre><code># github
Host github.com
    HostName github.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/id_rsa
# gitlab
Host gitlab.companyname.com
    HostName gitlab.companyname.com
    PreferredAuthentications publickey
    IdentityFile ~/.ssh/id_rsa_gitlab
</code></pre>
<p>同理可以继续为其它代码托管平台生成公私钥</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1601342260.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="测试">测试</h2>
<pre><code>$ ssh -T git@github.com
</code></pre>
<p>如果输出：Hi xxx You've successfully authenticated, but GitHub does not provide shell access.，说明成功的连上 github 了，以后可以自由从 GitHub 克隆、拉取、提交代码<br>
但是如果提示：Bad owner or permissions on /home/jing/.ssh/config，则是因为 <code>~/.ssh/config</code> 文件的权限不对，执行 <code>chmod 600 ~/.ssh/config</code> 修改权限即可</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://xuyuan923.github.io/2014/11/04/github-gitlab-ssh/">GitHub/GitLab 同时管理多个ssh key</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 泛型总结.md]]></title>
        <id>http://blog.kuranado.com/post/java-fan-xing-zong-jie-md/</id>
        <link href="http://blog.kuranado.com/post/java-fan-xing-zong-jie-md/">
        </link>
        <updated>2020-09-28T09:30:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="泛型类">泛型类</h2>
<p>我们知道使用泛型可以使类型错误在编译时就被检测到，从而能够增加程序的健壮性。</p>
<h3 id="定义泛型类">定义泛型类</h3>
<pre><code>public class Generic&lt;T&gt; {

    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey() {
        return key;
    }

    public void setKey(T key) {
        this.key = key;
    }
}
</code></pre>
<h3 id="实例化泛型类">实例化泛型类</h3>
<pre><code>Generic&lt;String&gt; genericString = new Generic&lt;&gt;(&quot;abc&quot;);
Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123);
System.out.println(genericString.getKey());
System.out.println(genericInteger.getKey());
</code></pre>
<p>需要注意的是泛型的类型参数必须是<code>引用类型</code>（类、接口、数组等都是 <code>引用类型</code>）而不能是简单类型，如 <code>Generic&lt;int&gt; generic = new Generic&lt;&gt;(123);</code> 是不允许的。</p>
<p>当然和 List 等一样，实例化泛型类可以传入任意类型而并不一定非要传入泛型类实参，只不过既然我们将类定义为泛型类，其目的就是希望开发者们能够传入确定的类型实参，以增加程序健壮性：</p>
<pre><code>Generic generic = new Generic(&quot;abc&quot;);
Generic generic2 = new Generic(123);
Generic generic3 = new Generic(true);
</code></pre>
<h2 id="泛型接口">泛型接口</h2>
<h3 id="定义泛型接口">定义泛型接口</h3>
<pre><code>public interface Generator&lt;T&gt; {
    public T fun();
}
</code></pre>
<h3 id="实现泛型接口">实现泛型接口</h3>
<pre><code>public class PersonGenerator&lt;T&gt; implements Generator&lt;T&gt; {
    @Override
    public T fun() {
        return null;
    }
}
</code></pre>
<p>可见当类实现泛型接口时若没有传入泛型实参，则需要将泛型也加到类的定义中，否则像下面的代码将会出现编译错误：</p>
<pre><code>public class PersonGenerator implements Generator&lt;T&gt; {
    @Override
    public T fun() {
        return null;
    }
}
</code></pre>
<p>如果实现泛型接口时传入了泛型实参，则该类中所有使用泛型的地方都要替换成传入的泛型实参：</p>
<pre><code>public class PersonGenerator implements Generator&lt;String&gt; {
    @Override
    public String fun() {
        return null;
    }
}
</code></pre>
<h2 id="泛型方法">泛型方法</h2>
<p>为了判断数组中是否包含某值写了如下两个重载方法：</p>
<pre><code>public static void main(String[] args) {
    Integer[] integers = new Integer[]{1, 2, 3};
    String[] strings = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
    System.out.println(contains(2, integers));
    System.out.println(contains(&quot;b&quot;, strings));
}
public static boolean contains(Integer integer, Integer[] integers) {
    return Arrays.asList(integers).contains(integer);
}
public static boolean contains(String s, String[] strings) {
    return Arrays.asList(strings).contains(s);
}
</code></pre>
<p>但如果还想要判断 Float 类型的数组中是否包含某个值就有需要编写一个重载方法，好在我们可以通过泛型方法有效的避免这些冗余的方法：</p>
<pre><code>public static void main(String[] args) {
    Integer[] integers = new Integer[]{1, 2, 3};
    String[] strings = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;};
    Float[] floats = new Float[]{0.1f, 0.2f, 0.3f};
    System.out.println(contains(2, integers));
    System.out.println(contains(&quot;b&quot;, strings));
    System.out.println(contains(0.2f, floats));
}
public static &lt;T&gt; boolean contains(T t, T[] ts) {
    return Arrays.asList(ts).contains(t);
}
</code></pre>
<p>需要注意的是方法返回值前需要包含形式参数，如 <code>&lt;T&gt;</code>， <strong>否则该方法不能被称为泛型方法</strong>，编译也将出错。<br>
值得一提的是，如果同时保留以下两个方法：</p>
<pre><code>public static &lt;T&gt; boolean contains(T t, T[] ts) {
    return Arrays.asList(ts).contains(t);
}
public static boolean contains(Integer integer, Integer[] integers) {
    return Arrays.asList(integers).contains(integer);
}
</code></pre>
<p><code>contains(&quot;b&quot;, strings)</code> 会自动匹配泛型方法，而 <code>contains(2, integers)</code> 匹配的是普通方法而不是泛型方法。</p>
<h2 id="泛型通配符">泛型通配符</h2>
<h3 id="无限定通配符-unbounded-wildcard">无限定通配符-Unbounded Wildcard</h3>
<p>我们知道 Integer、Double、Float 等都是 Number 类的子类，所以下面的代码完全没问题：</p>
<pre><code>public static void main(String[] args) {
    printMsg(123);
}
public static void printMsg(Number number) {
    System.out.println(number);
}
</code></pre>
<p>基本类型 123 被自动装箱成 Integer 类型，而 Integer 又是 Number 类的子类，所以可以作为 printMsg 方法的实参。</p>
<p>但泛型类 <code>Generic&lt;Number&gt;</code> 和 <code>Generic&lt;Integer&gt;</code> 可以认为是两个完全没有关联的新类型，两者之间不具有任何继承关系，所以下面的代码会出现编译错误：</p>
<pre><code>public static void main(String[] args) {
    Generic&lt;Number&gt; genericNumber = new Generic&lt;&gt;(123);
    Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123);
    printMsg(genericNumber);  // 编译通过
    printMsg(genericInteger); // 编译出错，因为 Generic&lt;Integer&gt; 和 Generic&lt;Number&gt; 二者之间没有任何继承关系
}
public static void printMsg(Generic&lt;Number&gt; generic) {
    System.out.println(generic.getKey());
}
</code></pre>
<p>而如果就是希望 printMsg 方法既能接收 <code>Generic&lt;Number&gt;</code> 又能够接收 <code>Generic&lt;Integer&gt;</code>类型，甚至是能够接收传入了任意实参类型的 <code>Generic</code> 泛型类（如 <code>Generic&lt;String&gt;</code>、<code>Generic&lt;Random&gt;</code>等），则需要用到泛型通配符 <code>?</code> 了：</p>
<pre><code>public static void main(String[] args) {
    Generic&lt;Number&gt; genericNumber = new Generic&lt;&gt;(123);
    Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123);
    printMsg(genericNumber);  // 编译通过
    printMsg(genericInteger); // 编译通过
}
public static void printMsg(Generic&lt;?&gt; generic) {
    System.out.println(generic.getKey());
}
</code></pre>
<h3 id="上限通配符-upper-bounded-wildcard">上限通配符-Upper Bounded Wildcard</h3>
<p>为泛型添加上边界，即传入的类型实参必须是指定类型或指定类型的子类。使用 <code>extends</code> 指定上限通配符</p>
<pre><code>public static void main(String[] args) {
    Generic&lt;Number&gt; genericNumber = new Generic&lt;&gt;(123);
    Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123);
    Generic&lt;Float&gt; genericFloat = new Generic&lt;&gt;(0.5f);
    Generic&lt;String&gt; genericString = new Generic&lt;&gt;(&quot;Hello&quot;);
    printMsg(genericNumber);  // 编译通过
    printMsg(genericInteger); // 编译通过
    printMsg(genericFloat);   // 编译通过
    printMsg(genericString);  // 编译出错
}
public static void printMsg(Generic&lt;? extends Number&gt; generic) {
    System.out.println(generic.getKey());
}
</code></pre>
<p>因为 <code>Generic&lt;? extends Number&gt; generic</code> 指定了传入的类型实参必须是 Number 类或 Number 类的子类，所以<code>printMsg(genericString);</code> 出错，因为 String 不是 Number 的子类</p>
<h3 id="下限通配符-lower-bounded-wildcard">下限通配符-Lower Bounded Wildcard</h3>
<p>和上限通配符类似，下限通配符使用 <code>super</code> 关键字实现：</p>
<pre><code>public static void main(String[] args) {
    Generic&lt;Number&gt; genericNumber = new Generic&lt;&gt;(123);
    Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123);
    Generic&lt;Float&gt; genericFloat = new Generic&lt;&gt;(0.5f);
    Generic&lt;String&gt; genericString = new Generic&lt;&gt;(&quot;Hello&quot;);
    printMsg(genericNumber);  // 编译通过
    printMsg(genericInteger); // 编译通过
    printMsg(genericFloat);   // 编译出错
    printMsg(genericString);  // 编译出错
}
public static void printMsg(Generic&lt;? super Integer&gt; generic) {
    System.out.println(generic.getKey());
}
</code></pre>
<p>因为 <code>Generic&lt;? super Integer&gt; generic</code> 指定了传入的类型实参必须是 Integer 类或 Integer 类的父类，所以 <code>printMsg(genericFloat);</code> 和 <code>printMsg(genericString);</code> 出现编译错误，因为 Float 和 String 都不是 Integer 类的父类</p>
<h2 id="类型擦除-type-erasure">类型擦除-Type Erasure</h2>
<p>Java 的泛型只在编译阶段有效，编译过程中正确检验泛型结果后，会将泛型相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法，即泛型信息不回进入运行时阶段：</p>
<pre><code>public static void main(String[] args) {
    Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123);
    Generic&lt;String&gt; genericString= new Generic&lt;&gt;(&quot;Hello&quot;);
    System.out.println(genericInteger.getClass() == genericString.getClass());  // 返回 true
}
</code></pre>
<p>结果返回 <code>true</code> ，说明虽然编译时 <code>Generic&lt;Integer&gt;</code> 和 <code>Generic&lt;String&gt;</code> 是不同的类型，但因为泛型的类型擦除，所以编译后 <code>genericInteger</code> 和 <code>genericString</code> 为相同的类型</p>
<h2 id="命名规则">命名规则</h2>
<p>JDK 中文档经常能看到 <code>T</code>、<code>K</code>、<code>V</code>、<code>E</code>、<code>N</code> 等类型参数，而我们在编写泛型相关代码时，这些符号都可以随意使用，实际上还可以使用 JDK 文档中从来没用过的符号，如 <code>A</code>、<code>B</code>、<code>C</code> 等，但却极力不推荐这样做</p>
<p>JDK 文档中各符号的含义：</p>
<ul>
<li>T：类型</li>
<li>K：键</li>
<li>V：值</li>
<li>E：元素（如集合类中的元素全部用该符号表示）</li>
<li>N：Number</li>
</ul>
<p>我们应该遵循 JDK 中已有的规范</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://blog.csdn.net/u012152619/article/details/47253811">java泛型详解</a><br>
<a href="https://blog.csdn.net/s10461/article/details/53941091/">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[适配器模式.md]]></title>
        <id>http://blog.kuranado.com/post/gua-pei-qi-mo-shi-md/</id>
        <link href="http://blog.kuranado.com/post/gua-pei-qi-mo-shi-md/">
        </link>
        <updated>2020-09-28T04:52:46.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>适配器模式又叫 Adapter 模式</p>
</blockquote>
<h2 id="什么是适配器模式">什么是适配器模式</h2>
<blockquote>
<p>将一个类的接口转换成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的类可以在一起工作</p>
</blockquote>
<p>适配器模式中的角色：</p>
<ul>
<li>Target：目标接口。客户所期望的接口，可以是具体的类，也可以是抽象类或接口</li>
<li>Adaptee：需要适配的类</li>
<li>Adapter：适配器。通过包装一个需要适配的对象，把原接口转换成目标接口</li>
</ul>
<h2 id="栗子">栗子</h2>
<p>网购一块键盘，收到货时却是这样的：</p>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1601268804.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>......，黑心店家竟然发了块 PS2 接口的键盘</p>
<p>可把我给气坏了！！！</p>
<figure data-type="image" tabindex="2"><img src="http://image.kuranado.com/blog/1601268819.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>因为笔记本接口是这样的：</p>
<figure data-type="image" tabindex="3"><img src="http://image.kuranado.com/blog/1601268843.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>只有 USB 接口</p>
<p>黑心店家不给退货，没办法，翻箱倒柜，DIY 了一个 PS2 转 USB 的转换器：</p>
<figure data-type="image" tabindex="4"><img src="http://image.kuranado.com/blog/1601268890.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>最终如愿以偿的用上了新键盘</p>
<figure data-type="image" tabindex="5"><img src="http://image.kuranado.com/blog/1601268901.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>好了，就以这个场景为例，简单写下代码吧：</p>
<h3 id="adaptee">Adaptee</h3>
<p>拥有 PS2 接口的键盘是需要被适配的类</p>
<pre><code>package com.kuranado.adaptor;

/**
 * PS2 键盘（要被适配的对象）
 * @Author: Xinling Jing
 * @Date: 2018-12-23 13:28
 */
public class PS2KeyboardAdaptee {

    public void specificRequest() {
        System.out.println(&quot;处理打字请求&quot;);
    }

}
</code></pre>
<h3 id="target">Target</h3>
<p>客户（也就是笔记本）所期望的 USB 接口</p>
<pre><code>package com.kuranado.adaptor;

/**
 * USB 接口（目标接口，客户所期望的接口）
 * @Author: Xinling Jing
 * @Date: 2018-12-23 13:33
 */
public interface USBTarget {

    void handleRequest();

}
</code></pre>
<h3 id="adapter">Adapter</h3>
<p>PS2 和 USB 的转换器，通过组合的方式包装了被适配的对象，并调用被适配对象所具有的功能。<br>
因为客户端只关心 USB 接口的使用，所以需要实现 USBTarget</p>
<pre><code>package com.kuranado.adaptor;

/**
 * PS2 到 USB 转接口（适配器）
 * @Author: Xinling Jing
 * @Date: 2018-12-23 13:43
 */
public class PS22USBAdapter implements USBTarget {

    private PS2KeyboardAdaptee adaptee;

    @Override
    public void handleRequest() {
        adaptee.specificRequest();
    }

    public PS22USBAdapter(PS2KeyboardAdaptee adaptee) {
        this.adaptee = adaptee;
    }
}
</code></pre>
<h3 id="client">Client</h3>
<p>客户端调用 Target 接口</p>
<pre><code>package com.kuranado.adaptor;

/**
 * 电脑客户端类
 * @Author: Xinling Jing
 * @Date: 2018-12-23 13:31
 */
public class ComputerClient {

    public void test(USBTarget target) {
        target.handleRequest();
    }

    public static void main(String[] args) {
        ComputerClient client = new ComputerClient();
        PS2KeyboardAdaptee adaptee = new PS2KeyboardAdaptee();
        USBTarget target = new PS22USBAdapter(adaptee);
        client.test(target);
    }
}
</code></pre>
<p>程序运行效果：</p>
<pre><code>处理打字请求
</code></pre>
<p>总结适配器模式各个角色的的关系如下图：</p>
<figure data-type="image" tabindex="6"><img src="http://image.kuranado.com/blog/1601268916.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<h2 id="实际业务中的栗子">实际业务中的栗子</h2>
<p>上面的例子比较简单，但真正业务中该如何应用适配器模式呢？此处把《研磨设计模式》中的例子拿过来与大家一起学习</p>
<h3 id="1-logmodel日志类用于保存日志相关信息">1. LogModel：日志类，用于保存日志相关信息：</h3>
<pre><code>/**
 * 日志类
 * @Author: Xinling Jing
 * @Date: 2018-12-23 19:01
 */
@Data
public class LogModel implements Serializable {

    private static final long serialVersionUID = -2324527735778406382L;
   
    private String logId;
    /**
     * 日志内容
     */
    private String logContent;
    /**
     * 操作人
     */
    private String operateUser;
    /**
     * 操作时间
     */
    private String operateTime;

    public LogModel() {
    }

    public LogModel(String logId, String logContent, String operateUser, String operateTime) {
        this.logId = logId;
        this.logContent = logContent;
        this.operateUser = operateUser;
        this.operateTime = operateTime;
    }
}
</code></pre>
<h3 id="2-logfileoperateapi从文件中读取日志或向文件中写入日志的接口">2. LogFileOperateApi：从文件中读取日志或向文件中写入日志的接口：</h3>
<pre><code>/**
 *
 * @Author: Xinling Jing
 * @Date: 2018-12-23 19:08
 */
public interface LogFileOperateApi {

    List&lt;LogModel&gt; readLogFile();

    void writeLogFile(List&lt;LogModel&gt; logModels);
}
</code></pre>
<h3 id="3-logfileoperateapi-接口的实现类">3. LogFileOperateApi 接口的实现类：</h3>
<pre><code>/**
 *
 * @Author: Xinling Jing
 * @Date: 2018-12-23 19:10
 */
public class LogFileOperateApiImpl implements LogFileOperateApi {

    // 默认的日志路径
    private String logFilePathName = &quot;/Users/jing/Code/GitHub/DesignPatterns/src/main/resources/AdaptorLog.log&quot;;

    public LogFileOperateApiImpl(String logFilePathName) {
        if (logFilePathName != null &amp;&amp; logFilePathName.trim().length() &gt; 0) {
            this.logFilePathName = logFilePathName;
        }
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public List&lt;LogModel&gt; readLogFile() {
        File file;
        ObjectInputStream objectInputStream = null;
        List&lt;LogModel&gt; logModels = null;
        try {
            file = new File(logFilePathName);
            if (file.exists()) {
                InputStream inputStream = new FileInputStream(file);
                if (inputStream.available() != 0) {
                    objectInputStream = new ObjectInputStream(new BufferedInputStream(new FileInputStream(file)));
                    logModels = (List&lt;LogModel&gt;) objectInputStream.readObject();
                } else {
                    return null;
                }
            }
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            if (objectInputStream != null) {
                try {
                    objectInputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return logModels;
    }

    @Override
    public void writeLogFile(List&lt;LogModel&gt; logModels) {
        ObjectOutputStream objectOutputStream = null;
        File file;
        try {
            file = new File(logFilePathName);
            objectOutputStream = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(file)));
            objectOutputStream.writeObject(logModels);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (objectOutputStream != null) {
                try {
                    objectOutputStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre>
<h3 id="4-client">4. Client:</h3>
<pre><code>/**
 * 客户端
 * @Author: Xinling Jing
 * @Date: 2018-12-23 19:01
 */
public class Client {

    public static void main(String[] args) {

        LogModel logModel = new LogModel(&quot;0001&quot;, &quot;这是第一条测试日志&quot;, &quot;JING&quot;, &quot;2018-08-03 09:44:35&quot;);

        List&lt;LogModel&gt; logModels = new ArrayList&lt;&gt;();
        logModels.add(logModel);

        LogFileOperateApi logFileOperateApi = new LogFileOperateApiImpl(&quot;&quot;);
        logFileOperateApi.writeLogFile(logModels);
        List&lt;LogModel&gt; models = logFileOperateApi.readLogFile();
        System.out.println(models);
    }
}
</code></pre>
<p>客户端创建了一个日志对象，并将该日志对象写入了文件，然后从文件中读取出日志，并打印出来：</p>
<pre><code>[LogModel(logId=0001, logContent=这是第一条测试日志, operateUser=JING, operateTime=2018-08-03 09:44:35)]
</code></pre>
<p>这样程序正常运行着，可是突然有一天 leader 说为了方便日志管理，要求把日志存储到数据库中，于是你快速定义了将日志存取到数据库的接口：</p>
<h3 id="5-logdboperateapi">5. LogDbOperateApi:</h3>
<pre><code>/**
 *
 * @Author: Xinling Jing
 * @Date: 2018-12-23 19:15
 */
public interface LogDbOperateApi {

    /**
     * 将日志保存到数据库
     * @param logModel
     */
    void createLog(LogModel logModel);

    /**
     * 更新数据库中的日志
     * @param logModel
     */
    void updateLog(LogModel logModel);

    /**
     * 删除数据库中的日志
     * @param logModel
     */
    void removeLog(LogModel logModel);

    /**
     * 获取数据库中的所有日志
     * @return
     */
    List&lt;LogModel&gt; getAllLog();

}
</code></pre>
<p>然后实现该接口：</p>
<h3 id="6-logdboperateapiimpl">6. LogDbOperateApiImpl：</h3>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2018-12-23 19:48
 */
public class LogDbOperateApiImpl implements LogDbOperateApi {

    @Override
    public void createLog(LogModel logModel) {
        System.out.println(&quot;成功插入日志:&quot; + logModel.toString() + &quot;到数据库中&quot;);
    }

    @Override
    public void updateLog(LogModel logModel) {
        System.out.println(&quot;成功更新数据库中日志:&quot; + logModel.toString());
    }

    @Override
    public void removeLog(LogModel logModel) {
        System.out.println(&quot;成功删除数据库中日志:&quot; + logModel.toString() + &quot;到数据库中&quot;);
    }

    @Override
    public List&lt;LogModel&gt; getAllLog() {
        System.out.println(&quot;已找到数据库中的所有日志&quot;);
        return null;
    }
}
</code></pre>
<h3 id="7-client">7. Client:</h3>
<pre><code>/**
 * 客户端
 * @Author: Xinling Jing
 * @Date: 2018-12-23 19:01
 */
public class Client {

    public static void main(String[] args) {

        LogModel logModel = new LogModel(&quot;0001&quot;, &quot;这是一条测试日志&quot;, &quot;JING&quot;, &quot;2018-08-03 09:44:35&quot;);
        LogDbOperateApi logDbOperateApi = new LogDbOperateApiImpl();
        logDbOperateApi.createLog(logModel);
    }
}
</code></pre>
<p>程序运行结果：</p>
<pre><code>成功插入日志:LogModel(logId=0001, logContent=这是一条测试日志, operateUser=JING, operateTime=2018-08-03 09:44:35)到数据库中
</code></pre>
<p><strong>到这里我们把 LogFileOperateApi 叫做第一版接口，LogDbOperateApi 叫做第二版接口</strong></p>
<p>好啦，所有的工作都做完了，终于可以开开心心的去撩妹啦</p>
<p>刚和妹子约好晚上共度良宵，leader 却又找到了你，因为他觉得还 是 把 日 志 存 储 到 文 件 中 比 较 好！！！</p>
<figure data-type="image" tabindex="7"><img src="http://imgblog.kuranado.com/womeishengqi.jpeg" alt="" loading="lazy"></figure>
<p>此刻内心想法：I have a line of MMP to tell you when the perfect timing comes to us. （╯' - ')╯︵ ┻━┻</p>
<p>工作还得继续，硬着头皮想到了这么几个解决办法：</p>
<ul>
<li>方法一：修改客户端调用，重新修改为调用第一版的接口</li>
<li>方法二：按照第二版的接口重新实现一个将日志存取到文件的实现类</li>
<li>方法三：不修改客户端调用，编写一个适配器，将第二版的接口适配到第一版的实现上，也就是使用适配器模式</li>
</ul>
<p>这三个方法哪个更可取呢？</p>
<ul>
<li>方法一：现在所有的业务都使用第二版接口，要更改为第一版接口的话，即要更改整个项目所有地方，费时费力</li>
<li>方法二：已经完成的功能何必再重做一遍呢</li>
<li>方法三：复用已有代码，省时省力</li>
</ul>
<h3 id="8-adapter">8. Adapter</h3>
<pre><code>/**
 *
 * @Author: Xinling Jing
 * @Date: 2018-12-23 19:59
 */
public class Adapter implements LogDbOperateApi {

    private LogFileOperateApi adaptee;

    public Adapter(LogFileOperateApi adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void createLog(LogModel logModel) {
        List&lt;LogModel&gt; logModels = adaptee.readLogFile();
        logModels.add(logModel);
        adaptee.writeLogFile(logModels);
    }

    @Override
    public void updateLog(LogModel logModel) {
        List&lt;LogModel&gt; logModels = adaptee.readLogFile();
        for (int i = 0; i &lt; logModels.size(); i ++) {
            if (logModels.get(i).getLogId().equals(logModel.getLogId())) {
                logModels.set(i, logModel);
                break;
            }
        }
        adaptee.writeLogFile(logModels);
    }

    @Override
    public void removeLog(LogModel logModel) {
        List&lt;LogModel&gt; logModels = adaptee.readLogFile();
        logModels.remove(logModel);
    }

    @Override
    public List&lt;LogModel&gt; getAllLog() {
        return adaptee.readLogFile();
    }
}
</code></pre>
<h3 id="9-client">9. Client</h3>
<p>此时客户端只要做一点小修改即可：</p>
<pre><code>/**
 * 客户端
 * @Author: Xinling Jing
 * @Date: 2018-12-23 19:01
 */
public class Client {

    public static void main(String[] args) {

        LogModel logModel = new LogModel(&quot;0002&quot;, &quot;这是第二条测试日志&quot;, &quot;JING&quot;, &quot;2019-09-04 10:55:46&quot;);
        List&lt;LogModel&gt; logModels = new ArrayList&lt;&gt;();
        logModels.add(logModel);
        LogFileOperateApi logFileOperateApi = new LogFileOperateApiImpl(&quot;&quot;);
        LogDbOperateApi target = new Adapter(logFileOperateApi);
        target.createLog(logModel);
        System.out.println(target.getAllLog());
    }
}
</code></pre>
<pre><code>[LogModel(logId=0001, logContent=这是第一条测试日志, operateUser=JING, operateTime=2018-08-03 09:44:35), LogModel(logId=0002, logContent=这是第二条测试日志, operateUser=JING, operateTime=2019-09-04 10:55:46)]
</code></pre>
<p>整体结构：</p>
<figure data-type="image" tabindex="8"><img src="http://image.kuranado.com/blog/1601271526.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>第二版接口对应适配器中的 Target，第一版的实现扮演适配器中的 Adaptee。整个适配器模式中最关键的就是 Adapter，它需要实现第二版的接口，但在内部实现的时候通过对象组合的方式调用第一版已经实现的功能。</p>
<p>好啦，这回终于可以结束工作，时间也还早，可以放心的去陪妹子逛街啦！</p>
<h2 id="工作中的应用场景">工作中的应用场景</h2>
<ul>
<li>旧系统的改造和升级</li>
<li>系统维护</li>
</ul>
<h2 id="常见实现">常见实现</h2>
<h3 id="java-io">Java IO</h3>
<ul>
<li>java.io.InputStreamReader(InputStream)：通过适配器将字节流转换为我们需要的字符流</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=HKVZNuZwVhQ&amp;t=1280s&amp;list=PLkQ01vCRt9bUFnXOD66dabj2NM9Wbjhoc&amp;index=7">【GOF23设计模式】 适配器模式</a></li>
<li><a href="https://mrdear.cn/2018/03/14/experience/design_patterns--adapter/">学长博客</a></li>
<li>《研磨设计模式》</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 多线程 - 内存可见性.md]]></title>
        <id>http://blog.kuranado.com/post/java-duo-xian-cheng-nei-cun-ke-jian-xing-md/</id>
        <link href="http://blog.kuranado.com/post/java-duo-xian-cheng-nei-cun-ke-jian-xing-md/">
        </link>
        <updated>2020-09-27T14:45:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="jmm">JMM</h2>
<p><code>JMM(Java Memory Model)</code> 即 Java 内存模型，描述了 Java 程序中各种变量（线程共享变量）的访问规则，以及在 <code>JVM</code>中将变量存储到内存和从内存中读取出变量这样的底层细节，JMM 有如下几条规则：</p>
<ul>
<li>所有的变量都存储在<code>主内存</code>中</li>
<li>每个线程都有自己独立的<code>工作内存</code>，里面保存该线程使用到的变量的副本（<code>主内存</code>中该变量的一份拷贝）</li>
<li>线程对<code>共享变量</code>的所有操作都必须在自己的<code>工作内存</code>中进行，不能直接从<code>主内存</code>中读写</li>
<li>不同线程之间无法直接访问其他线程<code>工作内存</code>中的变量，线程间变量值的传递需要通过<code>主内存</code>来完成</li>
</ul>
<figure data-type="image" tabindex="1"><img src="http://image.kuranado.com/blog/1601218014.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></figure>
<p>根据上图也可以发现：线程不能直接与<code>主内存</code>进行交互，<code>工作内存</code>负责与线程和<code>主内存</code>进行交互</p>
<h2 id="共享变量">共享变量</h2>
<p>如果一个变量在多个线程的<code>工作内存</code>中都存在副本，那么这个变量就是这几个线程的<code>共享变量</code></p>
<h2 id="可见性">可见性</h2>
<p>一个线程对<code>共享变量</code>值的修改，能够及时被其他线程看到则称这个<code>共享变量</code>在线程之间是可见的</p>
<h2 id="重排序">重排序</h2>
<p>代码书写的顺序与实际执行的顺序不同,指令重排序是编译器或处理器为了提高程序性能而做的优化</p>
<h3 id="as-if-serial语义">as-if-serial语义</h3>
<p>无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致，Java 编译器、运行时和处理器都会保证 Java 在<strong>单线程下</strong>遵循 as-if-serial 语义，所以重排序不会给单线程带来内存可见性问题，但是在多线程中程序交错执行时，重排序可能会造成内存可见性问题</p>
<pre><code>int num1 = 3;
int num2 = 5;
int sum = num1 + num2;
</code></pre>
<p>在单线程中，第 1 行和第 2 行代码可以进行重排序，但第 3 行代码不可以进行重排序，也就是说代码实际执行顺序可能是1 -&gt; 2 -&gt; 3 或 2 -&gt; 1 -&gt; 3，但绝不可能是3 -&gt; 1 -&gt; 2 或 3 -&gt; 2 -&gt; 1，因为这和代码顺序执行的结果不一致，不满足 as-if-serial 语义</p>
<h2 id="实现共享变量可见性">实现共享变量可见性</h2>
<p>要实现共享变量的可见性，必须保证两点：</p>
<ol>
<li>线程修改后的<code>共享变量</code>值能够及时从该线程的<code>工作内存</code>刷新到<code>主内存</code>中</li>
<li>其他线程能够及时把<code>共享变量</code>的最新值从<code>主内存</code>更新到自己的<code>工作内存</code>中</li>
</ol>
<p>而 Java 保证<code>共享变量</code>可见性主要通过 <code>synchronized</code> 或 <code>volatile</code> 关键字实现：</p>
<h3 id="synchronized">synchronized</h3>
<p><code>synchronized</code> 能够实现：</p>
<ul>
<li>原子性（同步）</li>
<li>内存可见性</li>
</ul>
<p><code>JMM</code> 关于 <code>synchronized</code> 的两条规定：</p>
<ul>
<li>线程解锁前，必须把<code>共享变量</code>的最新值刷新到<code>主内存</code>中</li>
<li>线程加锁时，将清空<code>工作内存</code>中共享变量的值，从而使用<code>共享变量</code>时，需要从<code>主内存</code>中重新读取最新的值（注意：加锁与解锁需要是同一把锁）</li>
</ul>
<p>可见 <code>synchronized</code> 的这两条规定刚好满足要实现<code>共享变量</code>可见性所必须要保证的两点</p>
<p><code>synchronized</code> 实现可见性过程如下：</p>
<ol>
<li>获得互斥锁</li>
<li>清空<code>工作内存</code></li>
<li>从<code>主内存</code>拷贝变量的最新副本到<code>工作内存</code></li>
<li>执行代码</li>
<li>将更改后的<code>共享变量</code>的值刷新到<code>主内存</code></li>
<li>释放互斥锁</li>
</ol>
<p>下面上一段代码：</p>
<pre><code>public class Synchronpublic class SynchronizedDemo {
    // 共享变量
    private boolean ready = false;
    private int result = 0;
    private int number = 1;
    // 写操作
    public void write(){
        ready = true; // 1.1
        number = 2; // 1.2
    }
    // 读操作
    public void read(){
        if(ready){ // 2.1
            result = number * 3; // 2.2
        }
        System.out.println(&quot;result的值为：&quot; + result);
    }

    // 内部线程类
    private class ReadWriteThread extends Thread {
        // 根据构造方法中传入的flag参数，确定线程执行读操作还是写操作
        private boolean flag;
        public ReadWriteThread(boolean flag){
            this.flag = flag;
        }
        @Override
        public void run() {
            if(flag){
                // 构造方法中传入true，执行写操作
                write();
            }else{
                // 构造方法中传入false，执行读操作
                read();
            }
        }
    }

    public static void main(String[] args) {
        SynchronizedDemo synDemo = new SynchronizedDemo();
        // 启动线程执行写操作
        synDemo.new ReadWriteThread(true).start();

        // 启动线程执行读操作
        synDemo.new ReadWriteThread(false).start();
    }
}
</code></pre>
<p>执行这段代码输出结果可能为 6，可能为 0，也可能为 3，而不论哪种结果，都可能有多种执行顺序</p>
<p>result = 6 1.1-&gt;1.2-&gt;2.1-&gt;2.2<br>
result = 6 1.1-&gt;2.1-&gt;1.2-&gt;2.2<br>
result = 6 1.2-&gt;1.1-&gt;2.1-&gt;2.2<br>
result = 3 1.1-&gt;2.1-&gt;2.2-&gt;1.2<br>
result = 0 1.2-&gt;2.1-&gt;2.2-&gt;1.1 （1.1 和 1.2 进行了重排序，先执行了 1.2，然后写线程让出 CPU 资源执行读线程 ）<br>
result = 0 1.2-&gt;2.2-&gt;2.1-&gt;1.1 （1.1 和 1.2 进行了重排序，2.1 和 2.2 也进行了重排序）<br>
...</p>
<p>注：代码 2.1 和代码 2.2 也可以进行重排序，因为在单线程中，2.1 和 2.2 无论谁先执行，都不会影响 result 的值</p>
<p>上面的例子简单说明了导致<code>共享变量</code>在线程中不可见的原因可能是线程的交叉执行或重排序，通过 <code>synchronized</code> 可以解决：</p>
<p>导致共享变量在线程间不可见的原因|synchronized解决方案<br>
-|<br>
线程的交叉执行（比如先执行 1.1 后执行 2.1）|原子性，synchronized保证了锁内部代码的原子性，避免了锁内部代码在线程之间交叉执行<br>
重排序结合线程交叉执行|原子性<br>
共享变量更新后的值没有在工作内存与主内存之间及时更新|可见性</p>
<p><code>synchroized</code> 实现可见性代码：</p>
<pre><code>//写操作
public synchronized void write(){
    ready = true;	//1.1
    number = 2;	//1.2
}
//读操作
public synchronized void read(){
    if(ready){	//2.1
        result = number * 3;	//2.2
    }
    System.out.println(&quot;result的值为：&quot; + result);
}
</code></pre>
<p>这样程序的输出结果将总是 6</p>
<h3 id="volatile">volatile</h3>
<p><code>volatile</code> 关键字：</p>
<ul>
<li>能够保证 volatile 变量的可见性</li>
<li>在 JDK 1.5 之后，volatile 变量能够禁止指令重排序</li>
<li>不能保证 volatile 变量复合操作的原子性</li>
</ul>
<p><code>volatile</code> 如何实现内存可见性：</p>
<p>volatile 变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存，这样任何时刻，不同的线程总能看到该变量的最新值</p>
<p>线程写 <code>volatile</code> 变量的过程:</p>
<ol>
<li>改变线程工作内存中 <code>volatile</code> 变量副本的值</li>
<li>将改变后的副本的值从工作内存刷新到主内存</li>
</ol>
<p>线程读 <code>volatile</code> 变量的过程:</p>
<ol>
<li>从主内存中读取 <code>volatile</code> 变量的最新值到线程的工作内存中</li>
<li>从工作内存中读取 <code>volatile</code> 变量的副本</li>
</ol>
<p>上代码：</p>
<pre><code>public class VolatileDemo {

    private volatile int number = 0;
    private Lock lock = new ReentrantLock();

    public void increase() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.number++;
    }

    public int getNumber() {
        return this.number;
    }

    public static void main(String[] args) {
        VolatileDemo volatileDemo = new VolatileDemo();
        for (int i = 0; i &lt; 500; i ++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    volatileDemo.increase();
                }
            }).start();
        }
        //如果还有子线程在运行，主线程就让出CPU资源，
        //直到所有子线程都运行完了，主线程再继续往下执行
        while (Thread.activeCount() &gt; 2) { //在IDEA中设置大于2，在Eclipse中设置为大于1即可，因为IDEA除了主线程之外还会有一个监视线程在运行
            Thread.yield();
        }
        System.out.println(&quot;number:&quot; + volatileDemo.getNumber());
    }

}
</code></pre>
<p>这段代码的执行结果可能为 500，也可能小于 500，而问题就出在 <code>number ++;</code> 上，因为 <code>number ++</code> 实际要分为如下 3 步执行：</p>
<ol>
<li>读取 number 的值</li>
<li>将 number 的值加 1</li>
<li>写入最新的 number 值</li>
</ol>
<p>而 <code>volatile</code> 虽然能够保证<code>共享变量</code>的内存可见性，但却不能保证复合操作的原子性，假设有两个线程 A 和 B，volatile int number = 5，线程 A 和 B 并发执行 <code>number ++;</code> 操作时就可能产生下面的执行顺序：</p>
<ol>
<li>线程 A 从主内存读取 number 的值</li>
<li>线程 B 从主内存读取 number 的值</li>
<li>线程 B 执行加 1 操作</li>
<li>线程 B 向主内存写入最新的 number 值</li>
<li>线程 A 执行加 1 操作</li>
<li>线程 A 向主内存写入最新的 number 值</li>
</ol>
<p>两个线程都执行了 <code>number ++;</code>，但主内存中共享变量 <code>number</code> 的值却是 6 而不是 7</p>
<p>解决办法有两种，一是通过 <code>synchronized</code> 加锁保证自增操作原子性，二是通过 <code>ReentrantLock</code> 对象加锁保证自增操作原子性</p>
<ol>
<li>使用 synchronized 关键字保证 number 自增操作的原子性</li>
</ol>
<pre><code>public synchronized void increase() {
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    this.number++;
}
</code></pre>
<p>当然加锁的范围应该尽量更小一些：</p>
<pre><code>public void increase() {
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    synchronized (this) {
        this.number++;
    }
}
</code></pre>
<ol start="2">
<li>使用 <code>ReentrantLock</code> 保证 number 自增操作的原子性</li>
</ol>
<pre><code>public void increase() {
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    lock.lock(); // 加锁
    try {
        this.number ++;
    } finally {
        lock.unlock(); // 释放锁
    }
}
</code></pre>
<p>使用上面两种方法的任意一种输出结果将总是 500</p>
<p><code>synchronized</code> 和 <code>volatile</code> 比较：</p>
<ul>
<li><code>volatile</code> 不需要加锁，比 <code>synchronized</code> 更轻量级，不会阻塞线<br>
程，执行效率更高</li>
<li><code>synchronized</code> 既能保证<code>共享变量</code>的可见性，又能保证<code>共享变量</code>的原子性，而 <code>volatile</code>只能保证<code>共享变量</code>的可见性，无法保证<code>共享变量</code>的原子性。</li>
</ul>
<p>最后，我们知道 Java 中 long 和 double 都是64 位的数据类型，而 <code>JMM</code> 允许 JVM 将没有被 <code>volatile</code> 修饰的 64 位数据类型的读写操作划分为两次 32 位的读写操作来进行，这就可能会导致读取到“半个变量”的情况，为了预防这种情况，最好为 long 和 double 类型的变量加上 <code>volatile</code> 关键字</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.imooc.com/learn/352">细说Java多线程之内存可见性</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例模式.md]]></title>
        <id>http://blog.kuranado.com/post/dan-li-mo-shi-md/</id>
        <link href="http://blog.kuranado.com/post/dan-li-mo-shi-md/">
        </link>
        <updated>2020-09-27T14:36:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是单例模式">什么是单例模式</h2>
<p>所谓单例模式即单例类只能有一个实例，并向外部提供一个访问该实例的全局访问点。</p>
<p>单例模式优点：</p>
<ul>
<li>可以避免类的频繁创建与销毁</li>
<li>只创建一个实例，节省系统资源</li>
</ul>
<h2 id="饱汉式-单线程">饱汉式-单线程</h2>
<p>饱汉式又称懒汉式（吃饱了可不就懒得动弹了嘛）：</p>
<pre><code>public class Test {

    public static void main(String[] args) {
        Singleton singleton = Singleton.getSingleton();
        Singleton singleton2 = Singleton.getSingleton();
        // 输出 true
        System.out.println(singleton == singleton2);
    }

}
class Singleton {

    private static Singleton singleton;

    private Singleton () {}

    public static Singleton getSingleton() {

        if (singleton == null) {
            singleton = new Singleton();
        }

        return singleton;
    }
}
</code></pre>
<p>这就是最简单的单例模式，为了防止外部通过 <code>new</code> 创建多个 Singleton 类的对象，将构造方法设为 <code>private</code>；向外部提供 <code>getSingleton</code> 方法，通过 <code>if</code> 判断，即便外部多次调用该方法也只会创建一次实例；因为 new 关键字已被禁用，无法通过 <code>new Singleton().getSingleton()</code> 的形式创建实例，所以该方法为静态方法，可以直接通过 <code>Singleton.getSingleton()</code> 调用该方法创建实例；因为静态方法不能访问普通变量，所以 Singleton 变量也使用 <code>static</code> 修饰。</p>
<h2 id="饱汉式-多线程">饱汉式-多线程</h2>
<p>饱汉式-单线程的代码在单线程下的执行效率很高，同时也实现了懒加载（外部调用 getInstance() 方法时才创建 Singleton 类的实例），但缺点也很明显，那就是在多线程情况下，并不能保证只创建一次实例，如两个线程 A 和 B，A 执行完 <code>if (singleton == null)</code> 后，线程 B 获得处理器资源也执行到 <code>if (singleton == null)</code> ，这样线程 A 和 B 将都会创建一次实例。解决办法也很简单，使用 <code>synchronized</code> 修饰 <code>getSingleton</code> 方法即可：</p>
<pre><code>public static synchronized Singleton getSingleton() {

    if (singleton == null) {
        singleton = new Singleton();
    }

    return singleton;
}
</code></pre>
<p>这样即可保证多线程下也只会创建一次实例，但同样存在很大的缺陷：加锁会影响效率，实际应该在创建完第一个实例后就解锁，否则每个线程调用 <code>getSingleton</code> 时都要上锁阻塞其他线程，导致执行效率极低。</p>
<h2 id="双重检验锁double-checked-locking">双重检验锁(Double Checked Locking)</h2>
<p>双重检验锁是对饱汉式-多线程的优化，做到一旦创建完第一个实例后就不再加锁的效果：</p>
<pre><code>class Singleton {

    private volatile static Singleton singleton;
    
    private Singleton () {}

    public static Singleton getSingleton() {
        // 可能会有多个线程都进入了此 if
        if (singleton == null) { // 第一次检查
            // 加锁
            synchronized (Singleton.class) {
                // 第一个进入锁内的线程才会进入此 if
                if (singleton == null) { // 第二次检查
                    singleton = new Singleton();
                }
            }
        }

        return singleton;
    }
}
</code></pre>
<p>关键点在于 <code>volatile</code> 关键字的使用，此处为何要使用 <code>volatile</code> 关键字呢？</p>
<p>问题在于 <code>singleton = new Singleton();</code> 这行代码上，这行代码在底层可以粗略的分为以下几步执行：</p>
<ol>
<li>栈内存开辟空间给 singleton 引用</li>
<li>堆内存开辟空间准备初始化对象</li>
<li>初始化对象</li>
<li>栈中引用指向这个堆内存空间地址</li>
</ol>
<p>因为指令重排序的原因，这行代码的执行顺序可能是 1 -&gt; 2 -&gt; 3 -&gt; 4，也可能是 1 -&gt; 2 -&gt; 4 -&gt; 3。在某个时刻，确实可以保证只有一个线程进入同步代码块，如果进入同步代码块的线程刚好执行到 1 -&gt; 2 -&gt; 4，并没有执行到 3，但此时 singleton 已经非空，如果这时还有一个线程抢占资源调用 getInstance() 方法，则该线程执行到第一个 <code>if</code> 判断时，由于 singleton 非空，直接返回该 singleton，而实际上，该 singleton 所指向的堆内存空间地址并没有存放初始化后的对象，造成我们并没有拿到正确的对象实例。</p>
<p><code>volatile</code> 刚好可以解决上述问题，我们知道 <code>volatile</code> 有 3 个特点：</p>
<ol>
<li>能够保证 <code>volatile</code> 变量的可见性</li>
<li>在 JDK 1.5 之后，<code>volatile</code> 变量能够禁止指令重排序</li>
<li>不能保证 <code>volatile</code> 变量复合操作的原子性。</li>
</ol>
<p>其中禁止指令重排序的特性正是我们所需要的。</p>
<h2 id="饥汉式">饥汉式</h2>
<p>饥汉式又称饿汉式，实现代码最为简单：</p>
<pre><code>class Singleton {

    private static Singleton singleton = new Singleton();

    private Singleton () {}

    public static Singleton getSingleton() {
        return singleton;
    }
}
</code></pre>
<p>饥汉式一上来就在类加载时创建好对象，由于 Java 的类加载机制避免了多线程的同步问题（类的加载方式是按需加载，且只加载一次，因为这个类在整个生命周期中只会被加载一次，所以只会创建一个实例），所以执行效率非常高。但饥汉式也存在如下两个缺点：</p>
<ol>
<li>没有实现懒加载，即便根本没有人主动调用 getSingleton 方法，不管三七二十一，也会在类加载时就创建 Singleton 类实例。假设 Singleton 类实例的创建非常消耗系统资源的话，则会造成系统资源浪费。</li>
<li>像 Spring 等框架的设计中也都用到了单例模式，但这些框架常常需要通过参数进行配置，如果直接像饥汉式一样 <code>private static Singleton singleton = new Singleton();</code> 将创建对象写死，将无法传入配置参数。</li>
</ol>
<h2 id="静态内部类">静态内部类</h2>
<pre><code>class Singleton {

    private Singleton() {}
    
    // 私有静态内部类，用到时才加载，所以时懒加载
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getSingleton() {
        return SingletonHolder.INSTANCE;
    }
}
</code></pre>
<p>静态内部类的加载不需要依附外部类，在使用到静态内部类时才加载，所以实现了懒加载。同时和饥汉式一样，类加载时就创建好对象，Java 的类加载机制也避免了多线程的同步问题，区别只在于这里是内部类</p>
<h2 id="枚举">枚举</h2>
<p>常有人说实现单例模式的最佳方法是使用枚举，这是因为枚举拥有以下特性，且代码实现简洁：</p>
<ul>
<li>枚举类的构造器只能使用 <code>private</code> 修饰，若省略 <code>private</code>，则默认也是使用 <code>private</code> 修饰，如果省略构造器，默认也会提供一个 <code>private</code> 修饰的构造器，这和我们前面 5 种写法完全吻合</li>
<li>枚举类的每个实例系统都会自动为其添加 <code>public static final</code> 修饰，保证了枚举中的实例都只会被实例化一次</li>
<li>线程安全</li>
</ul>
<pre><code>public class Test {

    public static void main(String[] args) {
        Singleton singleton = Singleton.SINGLETON;
        Singleton singleton2 = Singleton.SINGLETON;
        // 输出 true
        System.out.println(singleton == singleton2);
    }

}

enum Singleton {
    SINGLETON
}
</code></pre>
<p>遗憾的是枚举类加载时就开始加载枚举实例，所以并没有实现懒加载。</p>
<h2 id="总结">总结</h2>
<p>各种写法特性总结如下：</p>
<table>
<thead>
<tr>
<th>s</th>
<th>饱汉式-单线程</th>
<th>饱汉式-多线程</th>
<th>双重检验锁</th>
<th>饥汉式</th>
<th>静态内部类</th>
<th>枚举</th>
</tr>
</thead>
<tbody>
<tr>
<td>支持多线程</td>
<td>✘</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>懒加载</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✘</td>
<td>✔</td>
<td>✘</td>
</tr>
<tr>
<td>效率</td>
<td>高</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
</tbody>
</table>
<p>综合来说我更倾向于使用双重检验锁方式，但每种写法各有其优缺点，在开发中应该根据需求选择，引用一段话：</p>
<blockquote>
<p>既应当考虑到需求可能出现的扩展与变化，也应该避免无谓的提升设计、实现复杂度，最终反而会带来工期、性能和稳定性的损失，设计不足与设计过度都是危害，正所谓：没有最好的单例模式，只有最合适的单例模式。</p>
</blockquote>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>《Java 疯狂讲义》</li>
<li><a href="http://www.runoob.com/design-pattern/singleton-pattern.html">菜鸟教程单例模式</a></li>
<li><a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/">如何正确地写出单例模式</a></li>
<li><a href="http://www.importnew.com/23535.html">Java并发：volatile内存可见性和指令重排</a></li>
<li><a href="http://www.kuranado.com/2018/03/27/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7/">Java多线程之内存可见性</a></li>
<li><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">The &quot;Double-Checked Locking is Broken&quot; Declaration</a></li>
<li><a href="https://www.cnblogs.com/cielosun/p/6596475.html">Java枚举enum以及应用：枚举实现单例模式</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[毒鸡汤.md]]></title>
        <id>http://blog.kuranado.com/post/du-ji-tang-md/</id>
        <link href="http://blog.kuranado.com/post/du-ji-tang-md/">
        </link>
        <updated>2020-09-27T14:32:26.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>做人如果没点追求，那么，该多轻松啊…</li>
<li>做一天的好人并不难，难的是做一辈子有钱人。</li>
<li>你每天都那么努力，忍受了那么多的寂寞和痛苦。可我也没见你有多优秀！</li>
<li>今天的事不用放在今天做，万一明天死了呢，就可以不用做了。</li>
<li>其实只要不要脸，很多人生难题都能迎刃而解。</li>
<li>做人要谦虚，多听听他人的意见，然后认真记下他们的名字。</li>
<li>真正的吃货，是可以把月供看成月饼的。</li>
<li>总是在重复，尤其是错误！</li>
<li>很多时候，乐观的态度和好听的话帮不了你。</li>
<li>狗是人类最好的朋友。 然而狗最好的朋友是「屎」。</li>
<li>最怕你一生碌碌无为，还安慰自己说平凡可贵。</li>
<li>当你觉得生活对你不公时，秤秤体重，照照镜子，你会觉得一切又合乎情理。</li>
<li>谁说我不会乐器？我退堂鼓打的可好了。</li>
<li>世界这么大，我想去看看，什么地方要饭比较方便！</li>
<li>知道为何自古红颜多薄命吗？因为没人在意丑的人活多久。</li>
<li>别人问你有谈恋爱吗？就说现在没有。可以机智地掩盖过去也没有的事实。</li>
<li>做事一定要考虑别人的感受，千万不能让他们太开心了。</li>
<li>就算睡得晚，不会找你的人还是不会找你！</li>
<li>纵然人生坎坷，但我从不向命运屈服！我通常都是直接屈膝Orz。</li>
<li>曾经我也是打算靠脸吃饭的，后来差点饿死才放弃的。</li>
<li>众里寻她千百度，蓦然回首，那人依旧对我不屑一顾。</li>
<li>做人要安安稳稳本本分分，因为，你也根本搞不出什么幺蛾子。</li>
<li>没有人能让那你放弃减肥，你自己想想就会放弃了。</li>
<li>做梦梦到自己在考试，然后被吓醒，发现自己真的在考试。</li>
<li>白天嘈杂得不愿意醒，夜晚安静得舍不得睡。</li>
<li>人生不如意，十之有十！</li>
<li>做政治试卷，是我这辈子，说谎最多的时候。</li>
<li>转角一般不会遇到爱，只会遇到乞丐。</li>
<li>总结一下你的2018，留下你的不开心，让大家开心开心。</li>
<li>做好人没希望，做坏人不擅长。</li>
<li>如果十年之后你未娶，我未嫁，那真是太惨了！</li>
<li>别看我平时对你漠不关心，其实私下里我每天都盼着你出事！</li>
<li>只有努力过的人才知道，背景是多么重要！</li>
<li>真正努力过的人，就会明白，天赋是有多么重要。</li>
<li>做了一个风险非常大的投资，要是成功一下就能挣几个亿，要失败我这两块就打水漂了。</li>
<li>总是在凌晨想通很多事情，又在天亮之后，忘得一干二净。</li>
<li>装逼只是瞬间，不要脸那才是永恒。</li>
<li>總以為退一步海闊天空，沒想到腳下落空。</li>
<li>你多努力一点，获得的打击就多一点。</li>
<li>做好万全的准备，就是为了当机会来临时，你可以巧妙地避开它。</li>
<li>生活不止眼前的苟且，还有读不懂的诗和到不了的远方。</li>
<li>再不疯狂就老了，疯狂过后发现老的更快。</li>
<li>作为失败的典型，你实在是太成功了。</li>
<li>诗和远方越远越脏 以梦为马越骑越傻！</li>
<li>那些年立下的FLAG自己删了吧，反正也没人记得。</li>
<li>给你的梦想插上翅膀，虽然不一定飞得很远，但肯定摔的很重！</li>
<li>世界上本没有鸡汤，鸡死了，便做成了鸡汤。</li>
<li>上帝为你关上一道防盗门，还会顺手给你上了一把钛合金锁。</li>
<li>做任何事情一定要坚持下去，总会让你看到，失败的那一天。</li>
<li>没有什么事情能把人一次击倒，只要足够坚强，它会持续的把你击倒！</li>
<li>所有抱怨社会不公和制度的人翻译过来只有一句话：请给我金钱，女人和社会地位。</li>
<li>昨天一个小偷，来我家偷钱，我们一起找了一晚上。</li>
<li>谢谢你，在我每次需要你的时候都掉链子</li>
<li>厉害的不是你有多少后台，而是你能成为多少人的后台！</li>
<li>最近改掉了熬夜的壞習慣，改通宵了。</li>
<li>只要努力的时间足够长，搞不好，你还可以失败的更彻底。</li>
<li>自由从来不是什么理所当然的东西，而是一项需要极高成本的特权。</li>
<li>这年头放个假真不容易，连放假都要沾老祖宗的光。</li>
<li>虽然我学得慢，但是我放弃的快啊！</li>
<li>喜欢就去表白，不然你不会知道自己长得多丑。</li>
<li>只有努力过了才知道，智商上的差距是不可逾越的。</li>
<li>知道为什么天妒英才吗？ 因为没人去管笨蛋活了多久。</li>
<li>人人都想拯救世界，却没人帮妈妈洗碗。</li>
<li>做题前，先想想出题者的用意，我觉得他想我死。</li>
<li>最近一个月，总有那么三十天很不顺。</li>
<li>昨天遇见小学同班同学，没想到他混的这么差，只往我碗里放了一块钱。</li>
<li>不要以为世界抛弃了你，世界根本没空搭理你！</li>
<li>如果所有人都理解你，那你得普通成什么样！</li>
<li>终于中了500万，兑奖的时候，笑醒了。</li>
<li>先生，你这张卡上的钱也不够……</li>
<li>赚钱就像便秘 — 老难了，花钱就像拉稀 — 憋不住。</li>
<li>打趴下就不要爬起来了，反正还是会被打到趴下！</li>
<li>只要锄头挥得好，没有墙角挖不倒。</li>
<li>抱怨不会改变生活，但是钱可以！</li>
<li>死并不可怕，怕的是再也不能活了。</li>
<li>只有努力过了才知道，智商上的差距，是不可逾越的。</li>
<li>只是因为在人群中，多看了你一眼，你就以为我要坐你的摩的。</li>
<li>一些年轻人，通过高端消费来营造自己高端收入的形象。</li>
<li>一个姑娘的介绍：思想上的女流氓，生活中的好姑娘。 然而给我的感觉是：心思活络的丑逼。</li>
<li>自古情深留不住，总是套路得人心。</li>
<li>只有在车站大排长龙时，才能真正意识到，自己是龙的传人。</li>
<li>只要功夫深铁杵磨成针，但真把铁杵磨成针的，绝对是大傻瓜。</li>
<li>只要是石头，到哪里都不会发光。</li>
<li>别总骂恨铁不成钢，是你自己忘了，铁本来就不能成钢的啊。</li>
<li>女人假装高潮来维持恋爱，而男人假装恋爱以获得高潮。</li>
<li>正月初五迎财神，那都是有钱人的事，你就洗洗睡吧。</li>
<li>知识给你力量，无知会给你更强大无畏，且无法预测的力量。</li>
<li>长的美与不美不重要，想的美才是真的美！</li>
<li>只要有快递还在路上，就感觉这生活，还算有点希望。</li>
<li>只要能用钱解决的事情，我一件都解决不了。</li>
<li>只有多替领导背锅，领导才会把你，当成傻子啊。</li>
<li>只要坚持不懈，嘲笑你的人，迟早会被你笑死。</li>
<li>扎心？不存在的！心都没有扎哪里？</li>
<li>注重细节，从小事做起，因为你根本做不了大事。</li>
<li>正在输入…，给了多少人希望，又给了多少人失望。</li>
<li>只要选对了人生的方向，很容易就成功了，让我们恭喜只要和很容易。</li>
<li>至少在夏天，富得流油你已经做到了一半。</li>
<li>长得好看的才叫吃货，长得不好看的那叫饭桶！</li>
<li>只要你肯吃苦，肯努力，肯放下身段，去要饭，总会有人赶的</li>
<li>只要我肯努力，没什么事情是我搞不砸的。</li>
<li>这世上没谁离不开谁，就算是一条鱼离开水，也能烤着吃。</li>
<li>长的丑不是我的错，只是我在落地时太匆忙了，来不急打扮。</li>
<li>早睡早起身体好，可是晚睡晚起真的心情好。</li>
<li>这一秒不放弃，下一秒，就更绝望了。</li>
<li>挣钱是一种能力，花钱是一种技术，我能力有限技术却很高。</li>
<li>长的好看的才能叫吃货，长的不好看的只能叫饭桶。</li>
<li>真希望有一天我的钱包，可以和我的脸皮一样厚。</li>
<li>长得丑怎么了？我自己又看不到，恶心的是你们！</li>
<li>真正努力过的人才知道，智商上的差距是不可逾越的。</li>
<li>只有在，请假扣工资时，才觉得自己工资高。</li>
<li>只要我吃的夠快，体重绝对追不上我！</li>
<li>这么多年没掉入桃色陷阱，靠的就是两个字，没钱。</li>
<li>所谓成长，就是在听到波涛汹涌四个字，再也联想不到大海了。</li>
<li>余生不想请你指教了，领教够了</li>
<li>只要你每天坚持学习，最终胜利肯定是属于，在考场上发挥好的人。</li>
<li>早晨起来照镜子，安慰自己说没事，还有比我更丑的。</li>
<li>这辈子这么苦，别太拼，下辈子还会更苦的。</li>
<li>这次期末考，我会用实力告诉你，我们年级共有多少人。</li>
<li>这世上如果有什么真理，那就是活该！</li>
<li>这辈子最灿烂的笑容，大概都奉献给，我的手机屏幕了。</li>
<li>遇到喜欢的女生要勇敢表白，只有你主动了，才知道她名花有主。</li>
<li>真正的勇士，敢于直面银行卡上的余额，敢于正视磅秤上的数字。</li>
<li>在你最需要帮助的时候，只有鬼才来帮你。</li>
<li>愚人节，只是给说谎的人，一个说真话的机会。</li>
<li>这孩子不是笨，就是学习方法不对。学习方法都找不对还不是笨啊？</li>
<li>这年头有些人靠脸吃饭，而有些人，靠不要脸吃饭。</li>
<li>这年头，哪有不分手的恋爱，只有不伤手的立白。遇事得看开一点。</li>
<li>仗义每从屠狗辈，负心多是读书人。</li>
<li>再也沒有任何事情，比晚睡更快樂了，除了晚起。</li>
<li>攒了一年头皮屑，只为给你下场雪。</li>
<li>找对象还是眼光高点好，你总得为，没有人喜欢你找个借口吧。</li>
<li>这个年纪会在你耳边唱歌，喜欢你的肉体还会送你包的，只剩下蚊子了。</li>
<li>这两天雨水多，下雨记得打伞，否则脑袋容易进水。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 浅拷贝和深拷贝.md]]></title>
        <id>http://blog.kuranado.com/post/java-qian-kao-bei-he-shen-kao-bei-md/</id>
        <link href="http://blog.kuranado.com/post/java-qian-kao-bei-he-shen-kao-bei-md/">
        </link>
        <updated>2020-09-27T13:59:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="最普通的引用复制">最普通的引用复制：</h2>
<pre><code>import lombok.Data;

/**
 * @Author: Xinling Jing
 * @Date: 2019-07-20 12:57
 */
@Data
public class Student {

    private int no;
}
</code></pre>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2019-07-20 12:58
 */
public class Test {

    public static void main(String[] args)  {

        Student student = new Student();
        student.setNo(1);

        // 复制对象引用
        Student student2 = student;
        student2.setNo(2);

        System.out.println(student);
        System.out.println(student2);
    }
}
</code></pre>
<p>输出结果如下：</p>
<pre><code>Student(no=2)
Student(no=2)
</code></pre>
<p>更改一个 student 的 no 值，影响到了另一个 student 的 no</p>
<h2 id="浅拷贝">浅拷贝</h2>
<p>被拷贝的类需要实现 <code>Cloneable</code> 接口，并重写  <code>clone</code> 方法：</p>
<pre><code>import lombok.Data;

/**
 * @Author: Xinling Jing
 * @Date: 2019-07-20 12:57
 */
@Data
public class Student implements Cloneable {

    private int no;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2019-07-20 12:58
 */
public class Test {

    public static void main(String[] args) throws CloneNotSupportedException {

        Student student = new Student();
        student.setNo(1);

        Student student2 = (Student) student.clone();
        student2.setNo(2);

        System.out.println(student);
        System.out.println(student2);
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>Student(no=1)
Student(no=2)
</code></pre>
<p>更改一个 student 的 no 值，不会影响另一个 student 的 no</p>
<h2 id="深拷贝">深拷贝</h2>
<pre><code>import lombok.Data;

/**
 * @Author: Xinling Jing
 * @Date: 2019-07-20 12:57
 */
@Data
public class Student implements Cloneable {

    private int no;
    private Teacher teacher;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>
<pre><code>import lombok.Data;

/**
 * @Author: Xinling Jing
 * @Date: 2019-07-20 13:03
 */
@Data
public class Teacher {

    private String name;
}
</code></pre>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2019-07-20 12:58
 */
public class Test {

    public static void main(String[] args) throws CloneNotSupportedException {

        Student student = new Student();
        Teacher teacher = new Teacher();
        teacher.setName(&quot;汪老师&quot;);
        student.setNo(1);
        student.setTeacher(teacher);

        Student student2 = (Student) student.clone();
        student2.setNo(2);
        student2.getTeacher().setName(&quot;井老师&quot;);
        System.out.println(student);
        System.out.println(student2);
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code>Student(no=1, teacher=Teacher(name=井老师))
Student(no=2, teacher=Teacher(name=井老师))
</code></pre>
<p>两个 student 的 no 不同，但 teacher 却一起被改变了，说明 teacher 使用的是同一个引用。这是因为 Student 类下的 <code>super.clone()</code> 仅能拷贝 Student <strong>类本身及其中包含的值类型的成员变量，并不能拷贝引用类型的成员对象</strong></p>
<p>修改 Teacher 类如下：</p>
<pre><code>import lombok.Data;

/**
 * @Author: Xinling Jing
 * @Date: 2019-07-20 13:03
 */
@Data
public class Teacher implements Cloneable {

    private String name;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
</code></pre>
<p>修改 Student 类如下：</p>
<pre><code>import lombok.Data;

/**
 * @Author: Xinling Jing
 * @Date: 2019-07-20 12:57
 */
@Data
public class Student implements Cloneable {

    private int no;
    private Teacher teacher;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        Student student = (Student) super.clone();
        student.setTeacher((Teacher) teacher.clone());
        return student;
    }
}
</code></pre>
<pre><code>/**
 * @Author: Xinling Jing
 * @Date: 2019-07-20 12:58
 */
public class Test {

    public static void main(String[] args) throws CloneNotSupportedException {

        Student student = new Student();
        Teacher teacher = new Teacher();
        teacher.setName(&quot;汪老师&quot;);
        student.setNo(1);
        student.setTeacher(teacher);

        Student student2 = (Student) student.clone();
        student2.setNo(2);
        student2.getTeacher().setName(&quot;井老师&quot;);
        System.out.println(student);
        System.out.println(student2);
    }

}
</code></pre>
<p>输出结果：</p>
<pre><code>Student(no=1, teacher=Teacher(name=汪老师))
Student(no=2, teacher=Teacher(name=井老师))
</code></pre>
<p>一个 student 的 teacher 改变并不会影响另一个 student 的 teacher</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[土味情话.md]]></title>
        <id>http://blog.kuranado.com/post/tu-wei-qing-hua-md/</id>
        <link href="http://blog.kuranado.com/post/tu-wei-qing-hua-md/">
        </link>
        <updated>2020-09-27T03:53:08.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>你的笑容没有酒，我却醉的像条狗</li>
<li>我想你的时候阳光空气都很好。</li>
<li>喜欢被宠，如果哪天我过得好好的突然不小心被人宠死的话，我也一点意见都没有。</li>
<li>我对你的爱，就像拖拉机上山，轰轰烈烈……</li>
<li>我怀疑你的本质是一本书，不然为什么让我越看越想睡。</li>
<li>吃糖吗？我有你就已经很甜了。</li>
<li>你为什么要害我？害你什么？害我那么喜欢你。</li>
<li>动了情的小猪也会爬树喔</li>
<li>“我是可爱的女孩子。”“嗯？”“你是可爱啊。”</li>
<li>知道你跟我在一起叫什么吗？不知道啊，那你跟我在一起不就知道了</li>
<li>一直以来，我总是依赖于你的温柔。因为和你相遇，我的梦想才能够实现。所以这次轮到我帮你实现梦想了。</li>
<li>你的嘴真好看，特别适合说我爱你。</li>
<li>If you are still looking for that one person who will change you life ,take a look in the mirror.</li>
<li>你是方便面我是白开水 今生今世我泡定你了</li>
<li>我想要在茅亭里看雨、假山边看蚂蚁，看蝴蝶恋爱，看蜘蛛结网，看水，看船，看云，看瀑布，看你甜甜地睡觉。</li>
<li>你眼瞎吗？撞在我的心口上了。</li>
<li>你的口红我包了，但以后记得每天还我一点点。</li>
<li>坏男人渣一阵子，好男人渣一辈子</li>
<li>长话短说，爱我。</li>
<li>推荐一个0卡又很甜的零食，我的嘴巴</li>
<li>人说红颜薄命，你做我的红颜，我愿为你薄命。</li>
<li>我的酒量大概就是：八瓶香槟 七瓶伏特加 六瓶野格 五瓶威士忌 四瓶杰克丹尼 三瓶朗姆 两瓶生命之水 或者 你的一声：宝贝</li>
<li>你们那边家乡话的我喜欢你怎么说？</li>
<li>满心向你，却只字不提 ，你知道就知道 ，不知道也就算了，口里的爱不及心里的千分之一。</li>
<li>你知道我喜欢吃什么吗？痴痴地望着你</li>
<li>见什么世面，见见你就好了。</li>
<li>那些说星星好看的人一定没有看过你的眼睛</li>
<li>我很能干但有一件事不会。什么?不会离开你。</li>
<li>秋天该很好，你若尚在场，秋风即使带凉，亦漂亮。</li>
<li>虽然你没有我前女友漂亮 但我一见到你就有种想跟你定下来的感觉</li>
<li>最近都忙着学雷锋呢，你也做个好事帮我洗个东西吧，洗欢我</li>
<li>“我觉得你这个人不适合谈恋爱” “为什么?” “适合结婚。”</li>
<li>你是我最想和全世界炫耀却又最舍不得和别人分享的人</li>
<li>你这种人！我除了恋爱没什么和你好谈的</li>
<li>&quot;你猜我爱喝酒还是爱打王者&quot; &quot;爱打王者吧?&quot; &quot;不，爱你&quot;</li>
<li>这一辈子，还有没有可能，会有一个人，因为一句你想他，不远万里，不为别的，只为看看你。</li>
<li>请问去往你心里的路该怎么走</li>
<li>遇到你之前，我没有想过要结婚；遇到你之后，结婚没想过要和别人。</li>
<li>我不担心时光流逝，只因我坚信有你的日子将会越来越幸福，只到未来的某一天你我携手离开人世，我们的幸福将会达到巅峰。</li>
<li>傻逼在泰语里可是老公的意思哦</li>
<li>不要让别人喊我喊逗比，那是只属于你的专属。</li>
<li>不须耳鬓常厮伴，一笑低头意已倾</li>
<li>你猜我的心在哪边？左边？错了，在你那边。</li>
<li>我的愿望，就是希望你的愿望里，也有我。</li>
<li>谁会喜欢一米七的萌妹啊，还不是因为你是咖啡和奶茶的混合体。</li>
<li>你有打火机吗？没有啊，那你是怎么点燃我的心的？</li>
<li>我从不后悔一直喜欢你，那些孤独枯燥的时光岁月，因为你而变得温柔。</li>
<li>“520，我爱你”，“不对，是我爱您”，“要这么庄严的吗”，“不是庄严，是像爱祖国一样爱你，绵长悠久，休戚相关”。</li>
<li>和你在一起，我变得随心所欲，不再战战兢兢，担心忧虑。</li>
<li>情不知所起，一往而深。</li>
<li>你的脸上有点东西，有什么？有点漂亮。</li>
<li>猪撞树上了，你撞我心里了。</li>
<li>有人说，如果你在冬天遇到喜欢的人，他可以把你的冬天变成春天。</li>
<li>我生在南方，活在南方，栽在你手里，总算是去过不一样的地方。</li>
<li>猜猜我的心在哪边?左边。错了，在你那边</li>
<li>你像一个人 ，我的人</li>
<li>你是我自罚三杯，都不肯开口的秘密；</li>
<li>我们来玩木头人不许动吧！好！我输了！为什么？因为我心动了</li>
<li>这是西服，这是迷彩服，你是我的小幸福。</li>
<li>三十晚上的鞭炮再响，都没有我想想你那么想。</li>
<li>你的脸上有点东西，有什么? 有点漂亮</li>
<li>“孔子、孟子、老子，你知道你最适合当什么子吗？”“不知道。”“我的妻子。”</li>
<li>你喜欢喝水吗？那你已经喜欢上70%的我了。</li>
<li>被你赞过的朋友圈，叫甜甜圈。</li>
<li>我手上划了一道口子你也划一条吧 这样咱俩就是两口子了</li>
<li>你闻到空气中有烧焦的味道吗？那是我的心在为你燃烧</li>
<li>终会有人把你捧在心尖上，喜欢你喜欢的像个傻子，终会有人保护好你的少女心，让你再次相信爱情。</li>
<li>妙语连珠是猎物，支支吾吾是喜欢。</li>
<li>我好香，你要不要抱一下</li>
<li>我觉得你特像一款游戏，我的世界。</li>
<li>你喜欢大海，我爱过你。</li>
<li>想给自己颁一个最佳进步奖，毕竟我每天都爱你比昨天多一点。</li>
<li>有生之年 狭路相逢 终不能幸免</li>
<li>人的一生会遇到许许多多的人，很幸运我遇到了你。</li>
<li>你今天特别讨厌，讨人喜欢和百看不厌。</li>
<li>想说些漂亮的话哄你，但想来想去最漂亮的只有你。</li>
<li>如果你不怕麻烦的话，可以麻烦喜欢我一下吗？</li>
<li>我见过的最美的春天，是你穿过人群找到我的那个四月。</li>
<li>你忙归忙，什么时候有空娶我啊。</li>
<li>要不要来谈个恋爱啊，二缺一</li>
<li>你知道我最喜欢什么酒吗？和你的天长地久</li>
<li>讲真的你未对我半分好，偏巧这感情疯长似野草。</li>
<li>小猪佩奇，我配你。</li>
<li>你来时冬至，但眉上风止</li>
<li>我最近没有偷偷减肥哦，但是体重却下降了，因为我的心跑你那去了</li>
<li>刚刚地震了吗？没有啊，那为什么看到你，我心头一震。</li>
<li>每次你发朋友圈 我就又到了换手机桌面的时候。</li>
<li>“你能不能闭嘴?” “我没有说话啊” “那为什么我满脑子都是你的声音?”</li>
<li>我以前喜欢吃肉，但今天看到你我决定开始吃素，因为，你是我的菜。</li>
<li>我爱你就是这样的不讲道理</li>
<li>房产证写你名字，我妈会游泳，难产保大，余生多指教。</li>
<li>你这么完美，就是有一个缺点：什么缺点？缺点我</li>
<li>你是我临死前，拔掉氧气罐，想吻的人；</li>
<li>爱人，一定要适合的，因为那是一辈子相互扶持的柴米油盐。</li>
<li>我给你的备注是“一行”，因为干一行爱一行。</li>
<li>用铁做的门叫铁门，用木做的门叫木门，用幸福做的门叫什么门？叫我们</li>
<li>原谅我太贪心，陪了你情窦初开，还想陪你两鬓斑白。</li>
<li>生命那么短，世界那么乱，我不想争吵，不想冷战，不愿和你有一秒遗憾。</li>
<li>幸福是什么，幸福就是牵着一双想牵的手，一起走过繁华喧嚣，一起守候寂寞孤独；就是陪着一个想陪的人，高兴时一起笑，伤悲时一起哭；就是拥有一颗想拥有的心，重复无聊的日子不乏味，做着相同的事情不枯燥，只要我们心中有爱，我们就会幸福，幸福就在当初的承诺中，就在今后的梦想里。</li>
<li>不好意思，刚我对其他人动了心，因为她，很像你</li>
<li>你是我故事里的一往情深。</li>
<li>选择了你，就要坚持到死</li>
<li>你像夏至的分界线，是我一生里最长的那个白天。</li>
<li>“你会看手相吗?”“会一点，你命里缺我”</li>
<li>三十晚上的鞭炮再响，都没有我想你那么想。</li>
<li>这是弓箭，这是火箭，你是我的甜蜜饯。</li>
<li>你有没有看见过某个笑容，让你想倾尽所有去守护。</li>
<li>我的手被划了一道口子，你也划一道，这样我们就是两口子了。</li>
<li>你知道我的缺点是什么吗? 是缺点你。</li>
<li>你知不知道为什么我怕你？”“不知道”“因为我怕老婆</li>
<li>天空飘来五个字，爱你不是事儿。</li>
<li>我想以后可以先吻吻你迷迷糊糊不清醒的眼睛，再摁下闹钟的关闭按钮</li>
<li>我可以不为别人难过，但你不是别人，你是我的人。</li>
<li>你不知道在遇见你之前，我的世界天天都有雾霾，遇到你以后，他变得晴空万里</li>
<li>让我陪你去看匆匆人海，听平凡一生</li>
<li>我觉得你有点怪，怪可爱的。</li>
<li>这是我的手背，这是我的脚背，你是我的宝贝。</li>
<li>思念如白马，自别离，未停蹄</li>
<li>想你这件事，躲得过对酒当歌的夜，躲不过四下无人的街。</li>
<li>这世间的长情莫过于你和我挽手余生</li>
<li>土豆和洋芋，番茄和西红柿，我喜欢的人和你</li>
<li>我们来玩木头人不许动吧，好! 我输了，心动了。</li>
<li>最近体重上升了，绝对没有偷吃，只是把你偷偷放在了心里。</li>
<li>姑娘我想我们合二为一，尽情享受人间仙境</li>
<li>你可以笑一个吗？为什么呀？因为我的咖啡忘记加糖了。</li>
<li>从今以后我只能称呼你为您了，因为，你在我心上。</li>
<li>你知道你和猴子什么区别吗” “一个住在山洞，一个住在我心里”</li>
<li>晓看天色暮看云，行也思君，坐也思君</li>
<li>你猜我喜欢什么制服，被你制服。</li>
<li>我想问一条路 到你心里的路</li>
<li>要不要来谈恋爱啊，二缺一。</li>
<li>最近体重偷偷上升，绝对没有偷吃哦，只是偷偷把你放在了心上。</li>
<li>前天是小鹿，昨天是小兔，今天是你</li>
<li>我想去取一下东西，你等一下，我来娶你了。</li>
<li>你是我跑完五千米，还想拥抱的人；</li>
<li>做什么都十拿九稳，就差你一吻</li>
<li>你以后走路能不能看着点啊，都撞在我心上了。</li>
<li>既然你已经把我的心弄乱了，那么你准备什么时候来弄乱我的床</li>
<li>“三十岁是个坎？意思是过了30一切就好起来了是吧？”“意思是过了30岁，生活就结束前戏，开始狠狠操你了。”</li>
<li>我曾踏月而来，只因你在山中。</li>
<li>你知道你和星星有什么区别吗? 星星在天上，你在我心里。</li>
<li>东风夜放花千树，我想去你家里住</li>
<li>是福不是祸，是你老婆躲不过。</li>
<li>你猜我喜欢什么制服” “被你制服”</li>
<li>别让我看见你，不然我见你一次，就喜欢你一次。</li>
<li>在所有的道别里，还是最喜欢明天见。</li>
<li>做你自己，我来爱你。</li>
<li>我对你的喜欢就像手扶拖拉机上山，轰轰烈烈。</li>
<li>你就像破晓的那一束光，驱散了笼罩我的黑夜，至此，光芒万丈</li>
<li>我不想做你的盖世英雄，只想每天晚上帮你盖好被子。</li>
<li>你是属什么的？我属龙的，不，你是属于我的。</li>
<li>我发现昨天很喜欢你，今天也很喜欢你，而且有预感每天也会很喜欢你。</li>
<li>关于想你这件事，躲得过对酒当歌的夜，躲不过四下无人的街。</li>
<li>现在几点了？是我们幸福的起点。</li>
<li>天蓝蓝的云白白的都很可爱，就像捧着草莓味的冰淇淋圣代，吧唧吧唧吃着的我。</li>
<li>没有树的地方是沙漠，没有你的地方是寂寞。</li>
<li>你累不累啊？不累，可你都在我心里跑了一天了</li>
<li>我想你一定很忙，所以你只看前三个字就好</li>
<li>莫文蔚的阴天，孙燕姿的雨天，周杰伦的晴天，都不如你和我聊天。</li>
<li>倘若不是日有所思，哪里来的夜长梦多啊。</li>
<li>苦海无涯，回… 回头是我呀。</li>
<li>你是我不及的梦。</li>
<li>“我结婚你一定要来”“为什么？”“因为没有新娘会很尴尬。”</li>
<li>我可以许一个贪心的愿望吗?神明实现不了，只有你可以。</li>
<li>这是手心，这是笔芯，你是我的小甜心。</li>
<li>我想去个地方什么地方？去你心里！</li>
<li>惊鸿只一瞥，爱到死方休。</li>
<li>我有个九个亿的项目想跟你单独谈谈。</li>
<li>你能不能别说话了。”“我没有啊。”“那为什么我满脑子都是你的声音</li>
<li>秋天来了，你出现了，我心动了</li>
<li>“你最近是不是又胖了?” “没有啊，为什么这么说?” “那为什么在我心里的分量越来越重了?”</li>
<li>生活很苦，眼泪很咸；生活很苦，但你很甜</li>
<li>入目无别人 四下皆是你</li>
<li>下次见面敲你一下，为什么？因为你，敲好看。</li>
<li>你给我的备注是什么啊？” “一行。” “为什么啊？” “因为干一行，爱一行</li>
<li>我想在你这里买一块地。什么地？我对你的死心塌地。</li>
<li>为你的千千万万遍</li>
<li>“你今天早上是不是很累？”“你怎么知道？”“因为你昨天晚上一直在我心里跑来跑去啊。”</li>
<li>想多亲亲我身边的风，说不定哪天它就吹到你脸上了。</li>
<li>我发现昨天很喜欢你，今天也很喜欢你，而且有预感明天也会喜欢你。</li>
<li>“你为什么要害我?” “害你什么?” “害我那么喜欢你!”</li>
<li>你猜我什么星座” “白羊?” “错，我是为你量身定做”</li>
<li>（嗅嗅）你一来空气都变甜了呢</li>
<li>你近视吗? (不近视啊)那你怎么看不出我喜欢你。</li>
<li>孤烟无垠万里沙，幸能与你踏。</li>
<li>你闻到什么味道了吗？没有啊，怎么你一出来空气都是甜的了。</li>
<li>前世的五百次回眸换得今生的一次擦肩而过，我用一千次回眸换得今生在你面前的驻足停留。</li>
<li>遇见你的时候上帝在我耳边说了四个字 “在劫难逃”。</li>
<li>做饭做家务怕老婆，爱你的三大特征我都有</li>
<li>这是果冻，这是树洞，你是我的心动。</li>
<li>你眼瞎吗? 撞我心口上了</li>
<li>我发觉你今天有点怪，怪好看的。</li>
<li>从遇见你的那一天起，我所走的每一步都是为了更接近你。</li>
<li>我不是loli控，只是刚好喜欢的女孩子是loli而已</li>
<li>我愿将我余生燃烧，暖你未来的路。</li>
<li>你辛苦归辛苦，什么时候有空嫁给我。</li>
<li>Good night without you is just a night.</li>
<li>所爱隔山海，山海皆可平。</li>
<li>你有遇到让你哭笑不得的 事吗？哭也得不到你，笑也得不到你。</li>
<li>我们之间没有惊天动地的虐恋情深，但我有一颗真心，满满的全是你。</li>
<li>我还是爱你，就像风走了八万里，不问归期。</li>
<li>本是青灯不归客，却因浊酒流风尘</li>
<li>你是我的玫瑰你是我的花，小鸟的情话只给您夸。</li>
<li>莺莺燕燕，不过浮生一梦。遗世独立，不如烂醉花间。</li>
<li>我身体很好，可以扛米袋子，扛煤气罐，可就是扛不住想你。</li>
<li>你不觉得累吗？你已经在我的世界里跑了好几圈了</li>
<li>我愿意舍弃一切，以想念你终此一生。</li>
<li>我想要去看一看你下辈子的命簿，看你下辈子娶到哪家，我便投胎到那家。</li>
<li>“你知道我为什么感冒了吗?” “因为着凉了?” “不，因为我对你完全没有抵抗力。”</li>
<li>我的床不大不小，用来睡你刚刚好。</li>
<li>有的人说不清哪里好，但就是谁都替代不了。</li>
<li>你有没有闻到什么烧焦的味道？那是我的心在燃烧。</li>
<li>你现在不珍惜我，我告诉你，过了这个村，我在下个村等你。</li>
<li>刚刚地震了吗？没有啊，那为什么看到你，我心头一震。</li>
<li>会当凌绝顶，一… 一把搂住你。</li>
<li>最近有谣言说我喜欢你，我要澄清一下，那不是谣言，那是事实</li>
<li>想成为你这辈子，不管过了多少年，遇见了多少人，以后回想起来还会觉得妙不可言的人。</li>
<li>你知道五氧化二磷被氧化前是什么样子嘛，什么样子？五二磷。</li>
<li>面对你，我不仅善解人意，我还善解人衣。</li>
<li>前半生到处浪荡，后半生为你煲汤。</li>
<li>而对一个人纠结，就是喜欢一个人的开始。</li>
<li>我只愿凭这灵感的相通，带给彼此以慰藉，像流星的光辉，照耀我疲惫的梦寐，永远存一个安慰，纵然在别离时。</li>
<li>我玩了六年英雄联盟，后来才发现你才是我的英雄。</li>
<li>你是往日的情书，是日落的余情未了，是路人脚下不停生长的风，也是我喜欢的人。</li>
<li>“你知道世界上最冷的地方是哪吗?” “是没有你的地方”。</li>
<li>你是高处折不到的桃花，是跨不上的英俊白马。</li>
<li>我想买一块地。”“什么地”“你的死心塌地。”</li>
<li>现在几点了？12点，不，是我们幸福的起点。</li>
<li>宁不知倾城与倾国，佳人难再得</li>
<li>我也想遇见一个人，为他花开满城，为他明灯三千。</li>
<li>这一世，你是冰冷的永磁体，而我是你沟通世界的两极，纵你已粉身碎骨，我亦不离不弃……</li>
<li>“你知道这牛肉要怎么吃才好吃吗？我喂你吃。”</li>
<li>剑未佩妥，出门已是江湖；酒尚余温，入口不识乾坤；千帆过尽，愿您归来仍是少年。</li>
<li>为什么我的眼中常含泪水，因为我爱你爱的深沉</li>
<li>今天的天空是淡山茱萸粉的颜色，就像初次见你时，你的笑是我不曾见过的世外桃源</li>
<li>他们说这个世界上海最深邃，干净又透明，我想那是他们没见过你的眼睛。</li>
<li>你是我赴汤蹈火，都放不下的执着</li>
<li>我不喜欢喝酒，除了和你的天长地久</li>
<li>你这种人，我除了恋爱跟你也没什么好谈的。</li>
<li>我感觉你最近胖了，难怪你在我心中的分量变重了。</li>
<li>你猜我想吃什么?” “不知道啊。” “痴痴地望着你。”</li>
<li>无聊的时候多想想我，不要浪费时间，知道吗？</li>
<li>你会弹吉他吗？为什么拨动了我的心弦</li>
<li>有些事情在遇见你的时候就决定了，比如：我喜欢你~</li>
<li>哪有什么突然想起，只是一直放在心里。</li>
<li>愿你一生被爱 一生可爱 三月拾花酿春 六月流萤染夏 十月稻陌拾秋 腊月丛中吻雪 一年四季 四季最好都赠你</li>
<li>把手伸出来，这是我心房的钥匙，拿好</li>
<li>你知道相得益彰吗？就像你的美貌、气质和性格。</li>
<li>我看过很多书，但都没有你好看。</li>
<li>疏窗细雨，夜夜孤灯。</li>
<li>这辈子跟我在一起吧，不行我就等等，再不行的话，我就想想别的办法。</li>
<li>做腻了可爱的女孩子，我有点想做你的太太。</li>
<li>我看你挺笨的吹口哨都不会，要不要我嘴对嘴教你。</li>
<li>我的酒量大概就是一打啤酒或者半斤白酒，再或者你的四两微笑。</li>
<li>这是车票，这是发票，你是我最最最可爱的女票。</li>
<li>你知道我为什么会感冒吗？因为见到你就没有抵抗力呀，我爱你。</li>
<li>你是夏季限定，也是来日方长，也是秋季爆款，也只是一时之需</li>
<li>星光不问赶路人，岁月不负有心人</li>
<li>你知道你像什么人吗？什么人？我的女人。</li>
<li>你知道你和星星有什么区别吗？那就是星星在天上，而你在我心里</li>
<li>我听过最暖心的一句情话是：“你不用刻意去改变自己，我来适应你就好了。”</li>
<li>我可以称呼你为您吗？这样我就可以把你放在心上了</li>
<li>我很喜欢现在的我，和你一别两宽后的我。</li>
<li>寄给你全宇宙的爱和自太古至永劫的思念。</li>
<li>大年三十晚上的鞭炮再响，也没有我想你那么想</li>
<li>你是年少的欢喜，喜欢的少年是你</li>
<li>你可以帮我个忙么？什么忙？帮忙快点爱上我。</li>
<li>你今天能不能不洗澡，为什么？因为最近流行吃脏脏包。</li>
<li>你可以帮我个忙么? 什么忙? 帮忙快点爱上我!</li>
<li>我好像感冒了诶，怎么办，对你一点抵抗力都没有。</li>
<li>我寻了半生的春天，你一笑便是了。</li>
<li>猜猜我的心在哪边？左边错了，在你那边。</li>
<li>知道我和唐僧什么区别吗 唐僧取经我娶你</li>
<li>不要抱怨，抱我。</li>
<li>我还是喜欢你，像小时候吃辣条，不看日期。</li>
<li>你是不是喜欢我” 找到这句话的重复字</li>
<li>你来我信你不会走，你走我当你没来过——《失恋33天》</li>
<li>喜欢，就是知道对方最好的一面而喜欢他；爱，就是明知对方最差的一面，却仍然爱得义无反顾。</li>
<li>亲爱的，容我轻轻咬耳，遇见你便寻到了春天！</li>
<li>你知道我喜欢喝什么吗？ 呵护你</li>
<li>如果一千个人从我身边走过，我也可以听出你的脚步声，因为九百九十九个人都只是踩在地上，只有你踏在我心上。</li>
<li>你是可爱的男孩，我是可爱。</li>
<li>跟我在一起吧，行就行，不行我就再想办法。</li>
<li>这是我的手背，这是我的脚背，你是我的宝贝</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSS 基础总结.md]]></title>
        <id>http://blog.kuranado.com/post/css-ji-chu-zong-jie-md/</id>
        <link href="http://blog.kuranado.com/post/css-ji-chu-zong-jie-md/">
        </link>
        <updated>2020-09-26T08:11:07.000Z</updated>
        <content type="html"><![CDATA[<p>[TOC]</p>
<h2 id="css-引入方式">CSS 引入方式</h2>
<ul>
<li>内部样式表（嵌入式），<code>&lt;style&gt;&lt;/style&gt;</code> 标签放在 <code>&lt;head&gt;&lt;/head&gt;</code> 标签内，练习、测试时使用</li>
<li>行内样式表，直接在标签内部使用 style 属性定义样式，使用很少</li>
<li>外部样式表，使用最多，<code>&lt;head&gt;&lt;/head&gt;</code> 标签内 <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;./css/style.css&quot;/&gt;</code><br>
优先级：内部样式表 &gt; 行内样式表 &gt; 外部样式表</li>
</ul>
<h2 id="属性">属性</h2>
<h3 id="宽高">宽/高</h3>
<ul>
<li>width 宽度</li>
<li>height 高度</li>
<li>color 文本颜色</li>
<li>background-color 背景颜色</li>
</ul>
<h3 id="字体">字体</h3>
<ul>
<li>font-family 字体，如宋体、Microsoft YaHei、Arial、sans-serif、Times New Roman 等，尽量使用系统自带字体，字体相关属性通常用在 body 标签上，可同时设置多个字体，以逗号分隔，浏览器优先使用前面的字体，当字体不存在时，再依次尝试后面的字体</li>
</ul>
<pre><code>body {
    font-family: 'Times New Roman', 'Microsoft YaHei';
}
</code></pre>
<ul>
<li>font-size 字体大小，一定要记得加上单位，如 px</li>
</ul>
<pre><code>body {
    font-family: 'Times New Roman', 'Microsoft YaHei';
    font-size: 16px;
}
/** 虽然 body 标签已设置了字体大小，但标题标签比较特殊，需要单独再次设置字体大小
h1: {
    font-size: 16px;
}
</code></pre>
<ul>
<li>font-weigth 字体粗细，实际开发中更喜欢用数字而不是用单词
<ul>
<li>normal 不加粗（默认值，400）</li>
<li>bold 加粗（700）</li>
</ul>
</li>
</ul>
<pre><code>p {
    font-weigth: 700;
}
/** 或 **/

p {
    font-weigth: bold;
}
</code></pre>
<ul>
<li>font-style 字体样式
<ul>
<li>normal 不倾斜（默认值）</li>
<li>italic 倾斜</li>
</ul>
</li>
<li>font 字体复合属性，格式：<code>font: font-style font-weigth font-size/line-height font-family</code></li>
</ul>
<pre><code>/** 注意不可更改属性顺序，且 font-style 和 font-weigth 属性可以省略，font-size/line-height 和 font-family 属性不可省略 **/
p {
    font: italic 700 16px/26px 'Times New Roman', 'Microsoft YaHei';
}
</code></pre>
<h3 id="文本">文本</h3>
<ul>
<li>text-align 文本对齐，
<ul>
<li>left 左对齐（默认值）</li>
<li>right 右对齐</li>
<li>center 居中对齐</li>
</ul>
</li>
</ul>
<pre><code>h1 {
    /** 让 h1 盒子里的文本居中对齐 **/
    text-align: center;
}
p {
    text-align: center;    
}
&lt;h1&gt;Hello&lt;/h1&gt;
/** 图片也相当于是普通文字，要想图片在其父元素中居中对齐，需要为其父元素设置 text-align: center; 而不是为 img 标签设置该属性
&lt;p&gt;
    &lt;img src=&quot;./images/1.jpg&quot;/&gt;
&lt;/p&gt;
</code></pre>
<ul>
<li>text-decoration 文本装饰
<ul>
<li>none 没有装饰线（默认值，最常用）</li>
<li>underline 下划线（常用）</li>
<li>overline 上划线（几乎不用）</li>
<li>line-throne 删除线（不常用）</li>
</ul>
</li>
<li>text-indent 文本的第一行缩进多少距离</li>
</ul>
<pre><code>/** 如果字体大小设置为 16px，按照中国人的传统，段落首行缩进 2 个文字，则写法如下：**/
p {
    text-indet: 32px;
}
/** 或者直接写成 2em（推荐写法，em 是相对单位，相对当前标签 font-size 1 个文字的大小，如果当前标签没有设置 font-size，则相对父元素的 1 个文字大小） **/
p {
    text-index: 2em;
}
</code></pre>
<ul>
<li>vertical-align 用于设置一个元素的垂直对齐方式，但它只针对于行内元素或行内块元素有效。图片、表单都是行内块元素，默认的 vertical-align 为基线对齐
<ul>
<li>baseline 默认，元素放置在父亲的基线上</li>
<li>top 把元素的顶端与行中最高元素的顶端对齐</li>
<li>middle 常用，把此元素放置在父元素的中部</li>
<li>bottom 把元素的顶端与行中最低的元素的底端对齐<br>
<img src="http://image.kuranado.com/blog/1601107979.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy"></li>
<li>图片底部会有空白缝隙，原因是因为 img 是行内块元素，而行内块元素会和文字的基线对齐，为了去除该空白，可使用如下两种方法：
<ul>
<li>给图片添加 vertical-align: middle|top|bottom;，即只要不是 baselien 就可以（推荐方法）</li>
<li>把图片转换为行块级元素 display: block;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="行高">行高</h3>
<ul>
<li>line-height 行高（行间距），控制行与行之间的距离<br>
![](http://image.kuranado.com/blog/1601107997.png?imageMogr2/thumbnail/!70p<br>
行高由 3 部分组成：文本高度和上、下间距，由于文本高度有字体大小决定，所以当增加或减小行高时，实际文本高度不会变化，变化的只是上、下间距</li>
</ul>
<pre><code>/** 字体大小 16px，行高 26 px，所以上边距和下边距各位 5px **/
p {
font: italic 700 16px/26px 'Times New Roman', 'Microsoft YaHei';
   text-indent: 2em;
   line-height: 26px;
}
</code></pre>
<h3 id="背景">背景</h3>
<ul>
<li>background-color 背景色，默认值为 transparent，表示透明的</li>
<li>background-image 背景图片（如果既设置了背景颜色，又设置了背景图片，则背景颜色显示在下方，背景图片显示在上方）
<ul>
<li>none 没有图片，默认值</li>
<li>url 指定图片地址</li>
</ul>
</li>
<li>background-repeat 背景图片平铺方式
<ul>
<li>repeat 默认值，水平方向和垂直方向上平铺</li>
<li>no-repeat 不平铺</li>
<li>repeat-x 水平方向上平铺</li>
<li>repeat-y 垂直方向上平铺</li>
</ul>
</li>
<li>background-position 设置图片在背景中的位置，取值可以为方位名词，也可以为坐标，也可以方位名词和坐标混用
<ul>
<li>方位名词 top bottom left right center
<ul>
<li>单词顺序没有影响，如：<code>background-position: center right;</code> 和 <code>background-position: right center;</code> 没有任何区别</li>
<li>如果只指定一个方位名词，另一个方位名词省略，则另一个方位名词默认为 center，如 <code>background-position: center;</code> 等价于 <code>background-position: center center;</code></li>
</ul>
</li>
<li>坐标 x y
<ul>
<li>如：<code>background-position: 20px 50px;</code>；第一个参数为 x 表示距离盒子左边的距离，第二个参数为 y 表示距离盒子右边的距离</li>
<li>如果只指定一个坐标，则这个坐标<strong>一定</strong>是 x，此时 y 默认为 center。如 <code>background-position: 20px;</code> 等价于 <code>background-position: 20px center;</code></li>
</ul>
</li>
</ul>
</li>
<li>background-attachment 背景固定
<ul>
<li>scroll 默认值，背景图像随内容滚动</li>
<li>fixed 背景图像固定</li>
</ul>
</li>
<li>background 背景属性复合写法，没有特定书写顺序，一般习惯约定顺序为：<code>background: 背景颜色 背景图片地址 背景平铺方式 背景固定方式 背景图片位置</code>，如：</li>
</ul>
<pre><code>body {
    background-image: url(&quot;./images/bg.jpg&quot;);
    background-position: top center;
    background-repeat: no-repeat;
    background-attachment: fixed;
    background-color: gray;
}
p{Hello}*100Tab
</code></pre>
<p>等价于：</p>
<pre><code>body {
    background: gray url(&quot;./images/bg.jpg&quot;) no-repeat fixed top center;
}
p{Hello}*100Tab
</code></pre>
<ul>
<li>background
<ul>
<li>rgba CSS3 新增属性，可以设置盒子背景色半透明，盒子里面的内容不受影响，如 background: rgba(0, 0, 0, 0.3) 最后一个参数为 alpha 透明度，取值范围 0 ~ 1，习惯上会把 0.3 简写为 .3</li>
</ul>
</li>
<li>list-style: none 去除 li 的符号</li>
<li>border-radius 定义圆角边框（CSS3 新增），单位可以是像素，也可以是百分比
<ul>
<li>像素，如让一个正方形变成圆形，只要让 border-radius 等于宽度的一半即可：</li>
</ul>
<pre><code>.circle {
    width: 200px;
    height: 200px;
    background-color: skyblue;
    border-radius: 100px;
}  
&lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;      
</code></pre>
<ul>
<li>百分比，同样让一个正方形变成圆形，只要让 border-radius 等于宽度的一半，也就是 50%：</li>
</ul>
<pre><code>.circle {
    width: 200px;
    height: 200px;
    background-color: skyblue;
    border-radius: 50%;
}  
&lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;      
</code></pre>
<ul>
<li>如果要把矩形变成圆角矩形，只要把 border-radius 设置为矩形高度的一半就可以了</li>
<li>跟一个值，表示 4 个边框的圆角大小</li>
<li>跟两个值，第一个值表示左上角和右下角边框的圆角大小，第二个值表示右上角和左下角的圆角大小</li>
<li>跟四个值，分别表示左上角、右上角、右下角、左下角的圆角大小</li>
<li>border-top-left-radius 设置左上角圆角大小，注意 top 和 left 顺序不能颠倒</li>
<li>border-top-right-radius 设置右上角圆角大小，注意 top 和 right 顺序不能颠倒</li>
<li>border-bottom-right-radius 设置右下角圆角大小，注意 bottom 和 right 顺序不能颠倒</li>
<li>border-bottom-left-radius 设置左下角圆角大小，注意 bottom 和 left 顺序不能颠倒</li>
</ul>
</li>
<li>border-shadow 盒子阴影，格式：box-shadow: h-shadow v-shadow blur spread color inset;
<ul>
<li>h-shadow 水平方向阴影</li>
<li>v-shadow 垂直方向阴影</li>
<li>blur 表示模糊程度</li>
<li>spread 表示阴影尺寸</li>
<li>color 一般使用 rgba，以便设置阴影的透明度</li>
<li>inset 默认为外部阴影，inset 表示内部阴影，一般不会设置为 inset</li>
<li>盒子阴影是不占用盒子空间的，不会影响其它盒子排列</li>
</ul>
</li>
</ul>
<pre><code>div {
    width: 200px;
    height: 200px;
    background-color: skyblue;
    margin: 100px auto;
}
div:hover {
    box-shadow: 10px 10px 10px 5px rgba(0, 0, 0, .2);
}
&lt;div&gt;&lt;/div&gt;
</code></pre>
<ul>
<li>text-shadow 文字阴影（不常用），格式：text-shadow: h-shadow v-shadow blur color;</li>
</ul>
<h3 id="显示隐藏">显示/隐藏</h3>
<ul>
<li>display 常用
<ul>
<li>none 隐藏元素，<strong>隐藏后，不再占有原来的位置</strong></li>
<li>block 除了转换为块级元素外，还有显示元素的意思</li>
</ul>
</li>
<li>visibility
<ul>
<li>hidden 隐藏元素，<strong>隐藏后，元素继续占有原来的位置</strong></li>
<li>block 显示元素</li>
</ul>
</li>
<li>overflow 对溢出的部分设置显示或隐藏（如果是有定位的盒子，需慎用 overflow:hidden）
<ul>
<li>visible 默认值，不剪切内容，也不添加滚动条</li>
</ul>
<pre><code>div {
    /* 默认值，等于不设置 */
    overflow: visible;
    width: 400px;
    height: 100px;
    background-color: skyblue;
}
&lt;div&gt;《小猪佩奇》，又名《粉红猪小妹》（台湾名为粉红猪），英文名为《Peppa Pig》，是由英国人阿斯特利（Astley）、贝克（Baker）、戴维斯（Davis）创作、导演和制作的一部英国学前电视动画片，也是历年来最具潜力的学前儿童品牌。故事围绕小猪佩奇与家人的愉快经历，幽默而有趣，藉此宣扬传统家庭观念与友情，鼓励小朋友们体验生活。&lt;/div&gt;
</code></pre>
<img src="http://image.kuranado.com/blog/1601108024.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy">
<ul>
<li>hidden 隐藏掉超出的部分</li>
</ul>
<pre><code>    div {
    /* 自动隐藏掉超出的部分 */
    overflow: hidden;
    width: 400px;
    height: 100px;
    background-color: skyblue;
}
</code></pre>
<img src="http://image.kuranado.com/blog/1601108059.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy">
<ul>
<li>auto 当内容超出时，自动显示滚动条</li>
</ul>
<pre><code>div {
    /* 当内容超出时，自动显示滚动条 */
    overflow: auto;
    width: 400px;
    height: 100px;
    background-color: skyblue;
}
</code></pre>
<img src="http://image.kuranado.com/blog/1601108068.png?imageMogr2/thumbnail/!70p" alt="" loading="lazy">
<ul>
<li>scroll 不管超出与否，总是显示滚动条</li>
</ul>
</li>
</ul>
<h3 id="鼠标">鼠标</h3>
<ul>
<li>cursor
<ul>
<li>default 箭头</li>
<li>pointer 小手</li>
<li>move 移动</li>
<li>text 文本</li>
<li>not-allowed 禁止</li>
</ul>
</li>
</ul>
<h3 id="表单">表单</h3>
<ul>
<li>outline: none; 取消表单框获取焦点时的高亮边框</li>
<li>resize: none; 禁用 textarea 文本域的调节大小功能</li>
</ul>
<h2 id="继承">继承</h2>
<ul>
<li>行高的继承</li>
</ul>
<pre><code>body {
    /** 行高既可以指定单位像素，也可以不指定，如果不指定，则表示行高为当前字体的多少倍，所以此处 1.5 表示 body 的行高为 12px * 1.5 = 18px（Chrome 中计算会有一定误差，Safari 计算正常）**/
    font: 12px/1.5 &quot;Microsoft YaHei&quot;;
}
div {
    /** 继承 body 的行高 1.5，所以 div 的行高为 14px * 1.5 = 21px **/
    font-size: 14px;
}
p {
    /** 继承 body 的行高 1.5，所以 p 的行高为 16px * 1.5 = 24px **/
    font-size: 16px;
}
&lt;body&gt;
    &lt;div&gt;Hello&lt;/div&gt;
    &lt;p&gt;Hello&lt;/p&gt;
    &lt;ul&gt;
        &lt;!-- 继承 body 的字体大小 12px 和行高 1.5，所以此处 li 的行高为 12px * 1.5 = 18px --&gt;
        &lt;li&gt;Hello&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre>
]]></content>
    </entry>
</feed>