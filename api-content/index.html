{"posts":[{"title":"装饰器模式.md","content":"装饰器模式也称为包装器模式，往往以 Decorator 或 Wrapper 结尾的类都是使用的装饰器模式 什么是装饰器模式？ 装饰器模式又称装饰模式、包装模式。用于动态的给一个对象添加一些额外的职责。就增加功能来说，装饰器模式比生成子类更为灵活 装饰模式结构 Component 组件对象的接口，可以给这些对象动态的添加职责 ConcreteComponent 具体的组件对象，实现组件对象接口，通常就是被装饰器装饰的原始对象，可以给这个对象添加职责 Decorator 所有装饰器的抽象父类，需要定义一个与组件接口一致的接口，并持有一个 Component 对象，也就是持有一个被装饰的对象（注意这个被装饰的对象不一定是最原始的那个对象了，有可能是被其它装饰器装饰过后的对象） ConcreateDecorator 实际的装饰器对象，实现具体要向被装饰对象添加的功能 装饰器模式实现简单示例 1. 定义组件接口 import lombok.Data; /** * @Author: Xinling Jing * @Date: 2019-07-21 15:59 */ @Data public abstract class BasePerson { private String name; public abstract String show(); } 2. 定义具体组件类，该组件类的对象将被装饰器装饰 所有人开始都是一丝不挂 /** * @Author: Xinling Jing * @Date: 2019-07-21 16:01 */ public class ConcretPerson extends BasePerson { @Override public String show() { return this.getName() + &quot;裸体&quot;; } } 3. 定义装饰器接口，需要和被装饰的对象实现同样的接口 /** * @Author: Xinling Jing * @Date: 2019-07-21 16:01 */ public abstract class BaseDecorator extends BasePerson { private BasePerson person; public BaseDecorator(BasePerson person) { this.person = person; } @Override public String show() { return person.show(); } } 4. 定义具体装饰器类 穿内裤的装饰器 /** * @Author: Xinling Jing * @Date: 2019-07-21 16:14 */ public class PantsDecorator extends BaseDecorator { public PantsDecorator(BasePerson person) { super(person); } @Override public String show() { return String.join(&quot; -&gt; &quot;, super.show(), &quot;穿上了红胖次&quot;); } } 穿裤子的装饰器 /** * @Author: Xinling Jing * @Date: 2019-07-21 16:21 */ public class TrousersDecorator extends BaseDecorator { public TrousersDecorator(BasePerson person) { super(person); } @Override public String show() { return String.join(&quot; -&gt; &quot;, super.show(), &quot;穿上了裤子&quot;); } } 穿 T 恤的装饰器 /** * @Author: Xinling Jing * @Date: 2019-07-21 16:23 */ public class TShirtDecorator extends BaseDecorator { public TShirtDecorator(BasePerson person) { super(person); } @Override public String show() { return String.join(&quot; -&gt; &quot;, super.show(), &quot;穿上了 T 恤&quot;); } } 梳头发的装饰器 /** * @Author: Xinling Jing * @Date: 2019-07-21 16:25 */ public class HairstyleDecorator extends BaseDecorator { public HairstyleDecorator(BasePerson person) { super(person); } @Override public String show() { return String.join(&quot; -&gt; &quot;, super.show(), &quot;梳了一个性感的发型&quot;); } } 5. 客户端调用 客户端首先创建被装饰的组件对象，然后创建一种或多种装饰器对象，然后把装饰器对象组合起来： /** * @Author: Xinling Jing * @Date: 2019-07-21 16:26 */ public class Client { public static void main(String[] args) { // 小明家很穷，出门只能穿得起一条内裤 PantsDecorator decorator = new PantsDecorator(new ConcretPerson(&quot;小明&quot;)); System.out.println(decorator.show()); // 康康不仅穿了内裤，还穿了裤子和 T 恤 TShirtDecorator decorator2 = new TShirtDecorator(new TrousersDecorator(new PantsDecorator(new ConcretPerson( &quot;康康&quot;)))); System.out.println(decorator2.show()); // 西瓜个头比较小，只需要穿条内裤，然后梳理下发型就可以了 HairstyleDecorator decorator3 = new HairstyleDecorator(new PantsDecorator(new ConcretPerson(&quot;西瓜&quot;))); System.out.println(decorator3.show()); } } 输出结果如下： 小明裸体 -&gt; 穿上了红胖次 康康裸体 -&gt; 穿上了红胖次 -&gt; 穿上了裤子 -&gt; 穿上了 T 恤 西瓜裸体 -&gt; 穿上了红胖次 -&gt; 梳了一个性感的发型 结构如下： 常见装饰器模式实现 IO 流 结构如下： 各个类在装饰器中扮演的角色如下： InputStream 对应 Component FileInputStream 对应 ConcretComponent FilterInputStream 对应 Decorator DataInputStream、BufferedInputStream、PushbackInputStream 均是具体的装饰器实现 示例代码： /** * @Author: Xinling Jing * @Date: 2019-07-21 18:21 */ public class IOTest { public static void main(String[] args) { DataInputStream dataInputStream = null; try { dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(&quot;/Users/jing/Desktop&quot; + &quot;/IOTest.txt&quot;))); byte[] buff = new byte[dataInputStream.available()]; dataInputStream.read(buff); System.out.println(new String(buff)); } catch (IOException e) { e.printStackTrace(); } finally { try { if (dataInputStream != null) { dataInputStream.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 总结 下面开始装饰器模式的技术总结： 装饰器模式的本质是动态组合 装饰器用来装饰组件，装饰器一定要实现和组件类一致的接口，保证它们是同一个类型，并且具有同一个外观，这样组合完成的装饰才能递归调用下去 各个装饰器之间最好是完全独立的功能，不要有依赖，以在装饰组合的时候，可以随心所欲，不受先后顺序的限制，也就是说先装饰谁和后装饰谁都应该是一样的，否则会大大降低装饰器组合的灵活性。虽然在实际应用中，可以根据具体的功能要求而有顺序的限制，但应该尽量避免这种情况 优点 装饰模式比继承更灵活。继承是静态的，一旦继承，所有子类都有一样的功能，然而有时候有些子类可能并不需要这些继承而来的功能；装饰模式把功能分离到多个装饰器中，然后通过对象组合的方式，在运行时动态的组合功能，每个被装饰的对象最终拥有哪些功能，是由运行时期动态组合的功能来决定的 功能容易复用。一个对象可以使用多个装饰器，一个装饰器也可以用来装饰多个对象，从而实现功能复用 缺点 会产生很多细粒度的对象。装饰模式是把一系列复杂的功能分散到多个装饰器当中，一般每个装饰器只实现一个功能，这样会产生很多细粒度的对象，而且功能越复杂，需要的细粒度对象也就越多，大量小对象占据内存，一定程度上会影响性能 参考资料 《研磨设计模式》 源码 https://github.com/KURANADO2/DesignPatterns ","link":"http://blog.kuranado.com/post/guan-cha-zhe-mo-shi/"},{"title":"LeetCode - 面试题 01.06. 字符串压缩","content":"面试题 01.06. 字符串压缩 2020年3月16日星期一 月度打卡题 因为没注意看题目描述（题目要求：若“压缩”后的字符串没有变短，则返回原先的字符串），把 if (result.length() &gt;= S.length()) 写成了 if (result.length() &gt; S.length()) ，导致提交错误了一次 题目还是比较简单的，不再赘述了 完整代码 6ms class Solution { public String compressString(String S) { if (&quot;&quot;.equals(S)) { return S; } int sum = 1; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; S.length() - 1; i ++) { char m = S.charAt(i); char n = S.charAt(i + 1); if (n == m) { sum++; } else { sb.append(m).append(sum); sum = 1; } } sb.append(S.charAt(S.length() - 1)).append(sum); String result = sb.toString(); if (result.length() &gt;= S.length()) { return S; } return sb.toString(); } } ","link":"http://blog.kuranado.com/post/leetcode-mian-shi-ti-0106-zi-fu-chuan-ya-suo/"},{"title":"LeetCode - 2 两数相加","content":"2 两数相加 2020年3月16日星期一 太久没做过算法题，题目看了好久愣是没搞懂什么意思，昨天晚上想了好久，今天又在平板上画了好多遍，最后直接一边写代码一边思考独立做出来了，使用了递归，最后提交结果用时 2ms，战胜 99.98% 的 Java 提交记录，还是蛮有成就感的，嘻嘻😬 下面为我的思路： 根据题目可以大概知道需要处理以下几个问题： 进位问题 两个链表长度不相等问题 第一步，不考虑进位，并且假设输入数据的两个链表长度是相同的，可简单写出如下代码： public static ListNode addTwoNumbers2(ListNode l1, ListNode l2) { int x = l1.val + l2.val; ListNode r = new ListNode(x % 10); if (l1.next != null) { r.next = addTwoNumbers2(l1.next, l2.next); } return r; } 第二步，如果两个链表的长度是不相同的，只要其中一个链表还没有被遍历完，就继续递归，并为另一个已遍历完的链表创建下一节点，只不过把节点值设置为 0，就可以将两个链表变为相同长度链表： public static ListNode addTwoNumbers2(ListNode l1, ListNode l2) { if (l1 == null) { l1 = new ListNode(0); } if (l2 == null) { l2 = new ListNode(0); } int x = l1.val + l2.val; ListNode r = new ListNode(x % 10); if (l1.next != null || l2.next != null) { r.next = addTwoNumbers2(l1.next, l2.next); } return r; } 最后再考虑进位问题，下面为完整代码： 完整代码：2ms /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { if (l1 == null) { l1 = new ListNode(0); } if (l2 == null) { l2 = new ListNode(0); } int x = l1.val + l2.val; ListNode r = new ListNode(x % 10); if (l1.next != null || l2.next != null) { if (x &gt;= 10) { if (l1.next != null) { l1.next.val += 1; } else { l2.next.val += 1; } } r.next = addTwoNumbers(l1.next, l2.next); } else { if (x &gt;= 10) { r.next = new ListNode(1); } } return r; } } ","link":"http://blog.kuranado.com/post/leetcode-2-liang-shu-xiang-jia/"},{"title":"CSS 制作三角.md","content":"在很多网站，鼠标悬浮在某个按钮上，都会出现一个带有小箭头的小浮框，接下来就来讲解这样一个小箭头的实现原理： 京东： 小米 编写如下代码： .box { /* 盒子宽高一定要都设置为 0 */ width: 0; height: 0; /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */ font-size: 0; line-height: 0; border-top: 50px solid red; border-right: 50px solid green; border-bottom: 50px solid blue; border-left: 50px solid skyblue; } &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 效果图： 生成了 4 个箭头，箭头的大小取决于 border 的粗细 那如果只想生成一个小箭头，只需要将其他边框颜色设置为透明即可： .box { width: 0; height: 0; /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */ font-size: 0; line-height: 0; /* 生成向下的箭头 */ border: 50px solid transparent; border-top: 50px solid skyblue; } &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 综上，想要实现京东或小米的箭头效果，只要一个相对定位的大盒子上放一个绝对定位的小箭头就可以了，遂编写如下代码： .box { position: relative; width: 300px; height: 100px; background-color: #A1E75A; border-radius: 5px; } .arrow { position: absolute; /** 此处为了让向右的箭头能垂直居中，所以 top 设置为大盒子的高度的一半 - 等腰三角形的底边的一半即可（等腰直角三角形高 = 底边的一半）= 100/2 - 10 = 40px **/ top: 40px; left: 300px; width: 0; height: 0; /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */ font-size: 0; line-height: 0; border: 10px solid transparent; border-left: 10px solid #A1E75A; } &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;arrow&quot;&gt;&lt;/div&gt; &lt;/div&gt; 怎么样，是不是有点像微信的聊天框呢，哈哈哈！ 有时还可以看到这样的形状： 左边部分是一个梯形，根据我们上面分析问题的经验，这个梯形可以分解成一个红色矩形加一个白色的直角三角形实现，可是我们上面的代码得到的是一个普通等腰三角形，应该如何设置 border 才能得到这样一个直角三角形呢？不妨按照如下思路来一步步实现： boder-bottom 设置为 0 去除下边框 .box { /* 盒子宽高一定要都设置为 0 */ width: 0; height: 0; /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */ font-size: 0; line-height: 0; border-top: 50px solid red; border-right: 50px solid green; /* border-bottom: 50px solid blue; */ border-left: 50px solid skyblue; } &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 2. 增大 boder-top 为了得到一个高大于地板的直角三角形，所以这里调大 border-top .box { /* 盒子宽高一定要都设置为 0 */ width: 0; height: 0; /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */ font-size: 0; line-height: 0; border-top: 100px solid red; border-right: 50px solid green; /* border-bottom: 50px solid blue; */ border-left: 50px solid skyblue; } &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 3. boder-left 设置为 0 去除左边框 .box { /* 盒子宽高一定要都设置为 0 */ width: 0; height: 0; /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */ font-size: 0; line-height: 0; border-top: 100px solid red; border-right: 50px solid green; /* border-bottom: 50px solid blue; */ /* border-left: 50px solid skyblue; */ } &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 4. border-top 改为透明色 .box { /* 盒子宽高一定要都设置为 0 */ width: 0; height: 0; /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */ font-size: 0; line-height: 0; border-top: 100px solid transparent; border-right: 50px solid green; /* border-bottom: 50px solid blue; */ /* border-left: 50px solid skyblue; */ } &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 这样我们就得到了想要的高大于底边的直角三角形，当然代码可以简写成如下形式： .box { /* 盒子宽高一定要都设置为 0 */ width: 0; height: 0; /* 设置 font-size 和 line-height 是为了兼容性，一般不用加 */ font-size: 0; line-height: 0; border-style: solid; border-width: 100px 50px 0 0; border-color: transparent green transparent transparent; } 有了上面的基础，现在回到京东的案例，我们只需要为该三角形设置绝对定位，将其定位到红色矩形的最右侧，然后将其颜色改为白色即可，具体代码如下： * { margin: 0; padding: 0; } .price { width: 160px; height: 24px; line-height: 24px; border: 1px solid red; } .price .miaosha { float: left; position: relative; width: 90px; height: 100%; text-align: center; color: white; font-weight: 700; background-color: red; } .price .miaosha i { position: absolute; top: 0; left: 80px; width: 0; height: 0; font-size: 0; line-height: 0; border-style: solid; border-width: 24px 10px 0 0; border-color: transparent white transparent transparent; } .origin { padding-left: 10px; font-size: 14px; color: gray; text-decoration: line-through; } &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;price&quot;&gt; &lt;sapn class=&quot;miaosha&quot;&gt; ¥1650&lt;i&gt;&lt;/i&gt; &lt;/sapn&gt; &lt;span class=&quot;origin&quot;&gt;¥5650&lt;/span&gt; &lt;/div&gt; ","link":"http://blog.kuranado.com/post/css-zhi-zuo-san-jiao-md/"},{"title":"CSS 字体图标.md","content":"[TOC] 常用字体图标网站 icomoon.io iconfont.cn 字体图标格式 为了兼容性而存在 .ttf/.woff/.eot/.svg 字体 字体图标的引入 以 icomoon 举例： 进入 icomoon.io，选择字体后下载，解压如下： 把下载包中的 fonts 文件夹放入页面根目录下 在 CSS 样式中全局声明字体：简单理解就是将字体文件通过 CSS 引入到我们的页面中，一定要注意文件路径是否正确，把下面这段代码（可从下载包中的 style.css 得到）复制到 CSS 文件中 /** 字体声明 **/ @font-face { font-family: 'icomoon'; src: url('fonts/icomoon.eot?bypbup'); src: url('fonts/icomoon.eot?bypbup#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?bypbup') format('truetype'), url('fonts/icomoon.woff?bypbup') format('woff'), url('fonts/icomoon.svg?bypbup#icomoon') format('svg'); font-weight: normal; font-style: normal; font-display: block; } 打开下载包中的 demo.html，复制需要的图标到代码中 /** 字体声明 **/ @font-face { font-family: 'icomoon'; src: url('fonts/icomoon.eot?bypbup'); src: url('fonts/icomoon.eot?bypbup#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?bypbup') format('truetype'), url('fonts/icomoon.woff?bypbup') format('woff'), url('fonts/icomoon.svg?bypbup#icomoon') format('svg'); font-weight: normal; font-style: normal; font-display: block; } span { /** 指定字体为 icomoon **/ font-family: 'icomoon'; /** 既然是图标是字体，当然也可以为其设置字体的相关属性 **/ color: skyblue; font-size: 16px; } &lt;body&gt; &lt;!-- 虽然下面的图标看起来好像一样，但其实是不一样的，如果是在 CSS3 中，使用伪元素选择器 ::after/::before，content 中都可以使用转义图标，如 content: '\\e905' 将同样会显示正确的图标 --&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/body&gt; 字体图标的追加 如果项目中想要在原来的基础上引入新的字体图标，可进入 icomoon.io，导入原来字体包的 selection.json 文件 这时 icomoon 就会加载出我们以前下载的图标 之后在此基础上选择其他想要的新图标，选完后下载字体包，解压，将 fonts 文件夹复制到页面根目录下，替换原先的 fonts 文件夹即可（替换文件夹，需把旧文件夹删掉，然后把新文件夹复制进去即可，以完成彻底替换，否则字体可能会不生效） ","link":"http://blog.kuranado.com/post/css-zi-ti-tu-biao-md/"},{"title":"Mac - Hammerspoon.md","content":"最近在学长博客中发现一个非常好玩的效率软件：Hammerspoon，通过编写 Lua 脚本，完成各种有趣的小功能 [TOC] Hammerspoon 作用 替代 Magnet 进行窗口移动 之前一直用 Magnet 移动窗口，使用 Hammerspoon 之后完全可以替代 Magnet，以下为 Magnet 横屏和竖屏分别支持的快捷键截图 横屏： 竖屏： 为应用配置快捷键，比 ⌘⇥ 和 Alfred 切换程序更高效（建议只为高频使用的一些软件分配快捷键） 个人配置快捷键列表 快捷键 功能 ⌃⌥← 左半屏 ⌃⌥→ 右半屏 ⌃⌥↑ 上半屏 ⌃⌥↓ 下半屏 ⌃⌥D 左 1/3（横屏）或上 1/3（竖屏） ⌃⌥F 中 1/3 ⌃⌥G 右 1/3（横屏）或下 1/3（竖屏） ⌃⌥E 左 2/3（横屏）或上 2/3（竖屏） ⌃⌥T 右 2/3（横屏）或下 2/3（竖屏） ⌃⌥C 居中 ⌃⌥= 等比例放大窗口 ⌃⌥- 等比例缩小窗口 ⌃⌥↩︎ 最大化 ⌃⌥⌘← 窗口由主屏移动到副屏 ⌃⌥⌘→ 窗口由副屏移动到主屏 ⌥Q 打开 QQ ⌥W 打开 WeChat ⌥V 打开 Visual Studio Code ⌥F 打开 Finder ⌥C 打开 Chrome ⌥J 打开 Intellij IDEA ⌥N 打开 WizNote ⌥G 打开 Gridea ⌥D 打开 DataGrip ⌥T 打开 iTerm2 ⌥M 打开 MailMaster ⌥P 打开 Postman ⌥O 打开 Word ⌥E 打开 Excel 个人配置文件 见 GitHub：https://github.com/KURANADO2/hammerspoon-kuranado/blob/main/init.lua 关于应用 bundle id 上面配置中使用快捷键切换应用，需要拿到应用的 bundle id（请注意 bundle id 配置到 hammerspoon 中需要区分大小写，否则 console 会报错），可通过如下方式拿到： osascript -e 'id of app &quot;Name of App&quot;' 参考 学长博客 - OSX--OSX应用快速切换方案 官方 Quick Start 官方文档 少数派 - 免费又强大的 macOS 自动化工具，Hammerspoon 可以让你少买很多 App V2EX - 推荐一个 MacOS 上用了就无法自拔的神器 Hammerspoon - 岂止于窗口管理 hammerspoon-init 菜鸟教程 - Lua 教程 Easily see any app’s bundle identifier ","link":"http://blog.kuranado.com/post/mac-hammerspoonmd/"},{"title":"Builder 模式.md","content":"Builder 模式又称为建造者、生成器模式。日常开发中，很多类名包含 Builder 的都是生成器模式，例如 StringBuilder 的 append 方法 生成器模式的本质 分离了对象子组件的单独构造和装配，从而可以构造出复杂的对象。建造者模式适用于某个对象的构建过程较为复杂的情况 由于实现了构建和装配的解耦，不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。构建和装配的解耦，实现了更好的复用 生成器模式的构成 生成器模式的构成分为两个部分： Builder 接口：定义如何构建各个部件，了解每个部件的构建实现细节 Director 接口：定义如何装配各个部件，负责产品的整体构建算法 举个栗子 下面以生产电脑为例，讲解 Builder 模式： Computer 类 package com.kuranado.builder; import lombok.Getter; import lombok.Setter; /** * 电脑类 * @Author: Xinling Jing * @Date: 2018-12-21 15:01 */ @Setter @Getter public class Computer { private CPU cpu; private Graphics graphics; private HardDisk hardDisk; public Computer(CPU cpu, Graphics graphics, HardDisk hardDisk) { this.cpu = cpu; this.graphics = graphics; this.hardDisk = hardDisk; } public void start() { System.out.println(&quot;开机中...&quot;); } } class Hardware { /** * 品牌 */ private String brand; /** * 型号 */ private String model; public Hardware(String brand, String model) { this.brand = brand; this.model = model; } } /** * CPU */ class CPU extends Hardware { /** * Cache */ private String cache; public CPU(String brand, String model, String cache) { super(brand, model); this.cache = cache; } } /** * 显卡 */ class Graphics extends Hardware { /** * 显存 */ private String videoMemory; public Graphics(String brand, String model, String videoMemory) { super(brand, model); this.videoMemory = videoMemory; } } /** * 硬盘 */ class HardDisk extends Hardware { /** * 硬盘容量 */ private String capacity; public HardDisk(String brand, String model, String capacity) { super(brand, model); this.capacity = capacity; } } ComputerBuilder 接口 package com.kuranado.builder; /** * @Author: Xinling Jing * @Date: 2018-12-22 10:17 */ public interface ComputerBuilder { CPU buildCPU(); Graphics buildGraphics(); HardDisk buildHardDisk(); } MacComputerBuilder 实现类 具体的 Builder 知道每个部件的实现细节。可以定义很多种 Builder，每种 Builder 在部件细节实现上都不尽相同，从而构建出不同的对象 package com.kuranado.builder; /** * @Author: Xinling Jing * @Date: 2018-12-22 10:19 */ public class MacComputerBuilder implements ComputerBuilder { @Override public CPU buildCPU() { System.out.println(&quot;构建 Mac CPU&quot;); return new CPU(&quot;Intel&quot;, &quot;Xeon W&quot;, &quot;19MB&quot;); } @Override public Graphics buildGraphics() { System.out.println(&quot;构建 Mac 显卡&quot;); return new Graphics(&quot;AMD&quot;, &quot;Radeon Pro Vega 56&quot;, &quot;8GB&quot;); } @Override public HardDisk buildHardDisk() { System.out.println(&quot;构建 Mac 硬盘&quot;); return new HardDisk(&quot;三星&quot;, &quot;SM128C&quot;, &quot;2TB&quot;); } } ComputerDirector 接口 package com.kuranado.builder; /** * @Author: Xinling Jing * @Date: 2018-12-22 10:39 */ public interface ComputerDirector { Computer directorComputer(); } MacComputerDirector 实现类 具体的 Director 负责将部件装配起来，Director 知道整个产品的装配细节。可以定义很多 Director，从而装配出不同的对象 package com.kuranado.builder; import lombok.Getter; import lombok.Setter; /** * @Author: Xinling Jing * @Date: 2018-12-22 10:40 */ @Setter @Getter public class MacComputerDirector implements ComputerDirector { private ComputerBuilder computerBuilder; public MacComputerDirector(ComputerBuilder computerBuilder) { this.computerBuilder = computerBuilder; } @Override public Computer directorComputer() { // 调用 Builder 构建每个部件 CPU cpu = computerBuilder.buildCPU(); Graphics graphics = computerBuilder.buildGraphics(); HardDisk hardDisk = computerBuilder.buildHardDisk(); // 装配电脑 return new Computer(cpu, graphics, hardDisk); } } 实际应用中 Director 需要进行复杂的运算，然后根据需要，调用 Builder 中的方法生成需要的部件对象并按照某种算法装配这些部件。实际开发中可能会有如下几种情况(摘自《研磨设计模式》)： 在运行指导者的时候，会按照整体构建算法的步骤进行运算，可能先运行前几步运算，到了某一步骤，需要具体创建某个部件对象了，然后就调用 Builder 中创建相应部件调度方法来创建具体的部件。同时把前面运算得到的数据传递给 Builder，因为在 Builder 内部实现创建和组装部件的时候，可能会需要这些数据 Builder 创建完具体的部件对象后，会把创建好的部件对象返回给装配者，装配者继续后续的算法运算，可能会用到已经创建好的对象 如此反复下去，直到整个构建算法完成，整个产品也就创建好了 客户端调用 package com.kuranado.builder; /** * @Author: Xinling Jing * @Date: 2018-12-17 21:12 */ public class Client { public static void main(String[] args) { ComputerDirector director = new MacComputerDirector(new MacComputerBuilder()); Computer computer = director.directorComputer(); computer.start(); } } 程序运行结果： 构建 Mac CPU 构建 Mac 显卡 构建 Mac 硬盘 开机中... 生成器模式的优点 松散耦合：生成器模式可以用同一个构建算法构建出表现上完全不同的产品，实现产品构建和产品表现上的分离。 可以很容易的改变产品的内部表示：Builder 对象提供接口给 Director 使用，所以具体不见的创建和装配方式被 Builder 接口隐藏了，Director 并不知道具体的实现细节。 复用性好：因为实现了构建算法和具体产品实现的分离，所以构建算法和具体的产品装配两者都可以复用。同一个构建算法可以应用到不用的具体产品实现中，同一个具体产品实现，也可以配合不同的构建算法。 这就是生成器模式，是不是很简单呢！ 思考 现在在考虑一个问题，在 directorComputer 方法中我们组装电脑使用了这样一行代码： return new Computer(cpu, graphics, hardDisk); 想想这里有没有可以优化的地方呢？ 想不到？ 那倘若 Computer 类不止 CPU、Gragphics、HardDisk 这三个属性呢，比如 Computer 类还有 NetworkCard、SoundCard、MainBoard、Power、CDRom、Memory 等属性，那这时我们是不是要写这样一行代码来创建 Computer 对象： return new Computer(cpu, graphics, hardDisk, networkCard, soundCard, mainBoard, power, cdRom, memory); 遇到这种参数较多的情况，很多人还会重叠构造器： public Computer(CPU cpu) { this(cpu, null); } public Computer(CPU cpu, Graphics graphics) { this(cpu, graphics, null); } public Computer(CPU cpu, Graphics graphics, HardDisk hardDisk) { this(cpu, graphics, hardDisk, null) } ... public Computer(cpu, graphics, hardDisk, networkCard, soundCard, mainBoard, power, cdRom, memory) { this.cpu = cpu; this.graphics = graphics; this.hardDisk = hardDisk; ... } 在参数很多的情况下，重叠构造器有很多缺点： 层层嵌套，代码不灵活 不优雅 如果增加参数那就是噩梦 这时候就有人说了：可以提供空参构造方法，然后一个个调 setter 方法设置属性就不用重叠构造器了！ Computer computer = new Computer(); computer.setCPU(cpu); computer.setGragphics(gragphics); computer.setHardDisk(hardDisk); computer.setNetworkCard(networkCard); computer.setSoundCard(soundCard); computer.setMainBoard(mainBoard); computer.setPower(power); computer.setCDRom(cdRom); computer.setMemory(memory); 事实上，我们项目组的同事都是通过这种 set 的形式设置对象的，然而这真的是一个好的代码风格吗？《阿里 Java 开发手册》中推荐方法代码不超过 80 行，照这样创建对象很难符合规范。在工作中发现了这一点，想到了 Android 的 Api 中存在大量的链式调用，我们也可以将自己的代码修改成链式调用： package com.kuranado.builder; import lombok.Getter; import lombok.Setter; /** * 电脑类 * @Author: Xinling Jing * @Date: 2018-12-21 15:01 */ @Setter @Getter public class Computer { private CPU cpu; private Graphics graphics; private HardDisk hardDisk; public Computer(Builder builder) { this.cpu = builder.cpu; this.graphics = builder.graphics; this.hardDisk = builder.hardDisk; } public void start() { System.out.println(&quot;开机中...&quot;); } public static class Builder { private CPU cpu; private Graphics graphics; private HardDisk hardDisk; public Builder setCpu(CPU cpu) { this.cpu = cpu; return this; } public Builder setGraphics(Graphics graphics) { this.graphics = graphics; return this; } public Builder setHardDisk(HardDisk hardDisk) { this.hardDisk = hardDisk; return this; } Computer build() { return new Computer(this); } } } 内部类中的每个 set 方法都返回内部类自己，对于 set 方法可以使用 IDEA 自动生成，但需要注意需要选择 Builder 模板，而不要选择 Intellij Default： 然后创建 Computer 对象： new Computer.Builder().setCpu(cpu).setGraphics(graphics).setHardDisk(hardDisk).build(); 这样即便在属性很多时代码看起来也很简洁，当然这种链式调用也存在一定缺点，比如： 每次创建外部类对象，都需要再创建一个内部类，所以需要消耗更多的内存 每个属性要同时在内部类和外部类中定义 所以大家具体根据使用场景而定 参考资料 《Effective Java》 《研磨设计模式》 学长博客 【GOF23设计模式】 建造者模式详解 ","link":"http://blog.kuranado.com/post/builder-mo-shi-md/"},{"title":"CSS 定位.md","content":"[TOC] 为什么需要定位 使用标准流或浮动很难快速实现如下效果： 某个元素可以自由的在一个盒子内移动位置，并且压住其它盒子 当我们滚动窗口的时候，盒子可以固定在屏幕的某个位置 而定位具有如下特性： 定位可以让盒子自由的在某个盒子内移动位置或者固定在屏幕中某个位置，并且可以压住其它盒子 定位组成 定位 = 定位模式 + 边偏移 边偏移 边偏移决定了元素的最终位置，也就是定位的盒子移动到的最终位置 top 顶部偏移量，定义元素相对其父元素上边线的距离 bottom 底部偏移量，定义元素相对其父元素下边线的距离 left 左侧偏移量，定义元素相对其父元素左边线的距离 right 右侧偏移量，定义元素相对其父元素右边线的距离 如果一个定位盒子既设置了 left，又设置了 right，则默认会执行 left；如果一个定位盒子既设置了 top，又设置了 bottom，则默认会执行 top。不过一般情况，我们也不会为同一个定位盒子这样设置边偏移 定位模式 定位模式用于指定一个元素在文档中的定位方式 position static 静态定位（了解） relative 相对定位（重要） absolute 绝对定位（重要） fixed 固定定位（重要） sticky 粘性定位（了解） static 静态定位 静态定位就是元素的默认定位方式，无定位的意思。静态定位按照标准流特性摆放位置，它没有边偏移 relative 相对定位 相对定位在元素移动位置时，是相对于它原来的位置来移动的 相对定位最典型的应用就是给绝对定位当爹的 移动前在标准流的位置会继续占有，也就是不脱标 .one { position: relative; top: 100px; left: 100px; width: 200px; height: 200px; background-color: purple; } .two { width: 200px; height: 200px; background-color: gray; } &lt;div class=&quot;one&quot;&gt;&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;&lt;/div&gt; absolute 绝对定位 绝对定位是相对于它的祖先元素来移动位置的 如果绝对定位的元素没有祖先元素，或者祖先元素没有定位，则以浏览器为准定位 .father { width: 200px; height: 200px; background-color: purple; } .son { position: absolute; top: 100px; right: 100px; width: 200px; height: 200px; background-color: gray; } 如果祖先元素有定位（相对定位、绝对定位、固定定位都可以），则以最近一级有定位的祖先元素为参考点移动位置 绝对定位不再占有原先的位置，也就是会脱标 子绝父相：子绝父相是开发中常用的定位方式，即：子级使用相对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其它兄弟的盒子；父盒子需要加定位限制子盒子在父盒子内的显示；父盒子布局时，需要占有位置，因此父亲只能是相对定位，这就是父觉子相的由来。总结：因为父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位 fixed 固定定位 固定定位用于指定元素固定于浏览器可视窗口的位置 以浏览器的可视窗口为参照点移动元素 div { position: fixed; top: 20px; right: 100px; } &lt;div&gt;&lt;img src=&quot;./images/pvp.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt; 缩小浏览器窗口： 跟父元素没有任何关系 不会随滚动条滚动 固定定位不占有原先的位置，也就是会脱标 固定定位小技巧：固定在版心右侧位置： 让固定定位的盒子 left: 50%，也就是走到浏览器可视区域（也可以看做版心）的一半的位置 为固定定位的盒子添加 margin-left: 版心宽度一般的距离，当然也可以再多加几像素，保留一定空间 这样就可以让固定定位的盒子贴着版心右侧对齐了 /* 版心 */ .w { margin: 0 auto; width: 800px; height: 1400px; background-color: hotpink; } /* 固定定位盒子 */ .fixed { position: fixed; top: 200px; left: 50%; margin-left: 405px; width: 50px; height: 100px; background-color: skyblue; } &lt;div class=&quot;w&quot;&gt;&lt;/div&gt; &lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt; 粘性定位 粘性定位可以被认为是相对定位和固定定位的混合 以浏览器的可视窗口为参照点移动元素（固定定位的特点） 粘性定位占有原先的位置（相对定位的特点） 必须添加 top、left、right、bottom 中的其中一个才生效 兼容性较差（IE 完全不支持） body { height: 3000px; } .nav { position: sticky; top: 0; width: 800px; height: 50px; margin: 200px auto; background-color: skyblue; } &lt;div class=&quot;nav&quot;&gt;我是粘性定位&lt;/div&gt; 起始位置： 鼠标滚动到为粘性定位盒子设置的 top 值时，盒子将黏住不再跟着滚动： 定位的层叠次序 在使用定位布局时，可能会出现盒子重叠的情况，这时需要使用 z-index 属性控制盒子的上下顺序 z-index 属性值可以是整数、0 或负数，数值越大，盒子越靠上，如果没有指定数值，则默认值为 auto 如果属性值相同，则按照书写顺序，后来居上 数字后面不能加单位 只有定位的盒子才有 z-index 属性 未加 index 按照书写顺序，后来居上： div { position: absolute; top: 0; left: 0; } .one { width: 100px; height: 100px; background-color: red; } .two { width: 75px; height: 75px; background-color: green; } .three { width: 50px; height: 50px; background-color: blue; } &lt;div class=&quot;one&quot;&gt;我是第一个盒子&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;我是第二个盒子&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;我是第三个盒子&lt;/div&gt; 指定 z-index： div { position: absolute; top: 0; left: 0; } .one { z-index: 3; width: 100px; height: 100px; background-color: red; } .two { z-index: 2; width: 75px; height: 75px; background-color: green; } .three { z-index: 1; width: 50px; height: 50px; background-color: blue; } &lt;div class=&quot;one&quot;&gt;我是第一个盒子&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;我是第二个盒子&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;我是第三个盒子&lt;/div&gt; 总结 定位模式 是否脱标 移动位置 是否常用 static 静态定位 否 不能使用边偏移 很少 relative 相对定位 否（占有位置） 相对于自身位置移动 常用 absolute 绝对定位 是（不占有位置） 带有定位的父级 常用 fixed 固定定位 是（不占有位置） 浏览器的可视窗口 常用 stick 粘性定位 否（占有位置） 浏览器可视窗口 很少 拓展 如何让绝对定位的盒子水平居中/垂直居中 首先加了绝对定位的盒子不能通过 margin: 0 auto; 水平居中，但是可以通过如下算法实现水平居中： left: 50%; 让盒子的左侧移动到父级元素的水平中心位置 margin-left: 负的盒子自身宽度一半的px; 让盒子向左移动自身宽度的一半 div { position: absolute; left: 50%; margin-left: -100px; width: 200px; height: 200px; background-color: skyblue; } &lt;div&gt;&lt;/div&gt; 改变浏览器窗口大小，盒子也始终处于水平居中位置 同理如果让盒子垂直居中，则算法如下： top: 50%; 让盒子的上侧移动到父级元素的垂直中心位置 margin-top: 负的盒子自身高度一半的px; 让盒子向上移动自身高度的一半 如果想让盒子既水平又垂直居中，算法如下： left: 50%; margin-left: 负的盒子自身宽度一半的px; top: 50%; margin-top: 负的盒子自身高度一半的px; 绝对定位或固定定位的特殊特性 行内元素添加绝对定位或固定定位，可以直接设置宽度和高度 span { position: absolute; width: 100px; height: 100px; background-color: skyblue; } &lt;span&gt;Hello&lt;/span&gt; 块级元素添加绝对定位或固定定位，如果不给宽度或高度，则默认大小是内容的大小 div { position: absolute; background-color: skyblue; } &lt;div&gt;Hello&lt;/div&gt; 3. 绝对定位或固定定位会完全压住盒子 和浮动元素不同，浮动元素只会压住下面标准流的盒子，而不会压住下面标准流盒子里的文字或图片，但绝对定位或固定定位会压住下面标准流所有的内容： * { margin: 0; padding: 0; } div { position: absolute; width: 100px; height: 100px; background-color: skyblue; } &lt;div&gt;&lt;/div&gt; &lt;p&gt;绝对定位或固定定位会压住下面标准流所有的内容&lt;/p&gt; ","link":"http://blog.kuranado.com/post/css-ding-wei-md/"},{"title":"CSS 属性书写顺序.md","content":"建议遵循以下规则： 布局定位属性：display/position/float/clear/visibility/overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width/heigth/margin/padding/border/background 文本属性：color/font/text-decoration/text-align/vertical-align/white-space/break-word 其它属性（CSS3）：content/cursor/border-radius/box-shadow/text-shadow/background:linear-gradient/... ","link":"http://blog.kuranado.com/post/css-shu-xing-shu-xie-shun-xu-md/"},{"title":"LeetCode - 1 两数之和","content":"1 两数之和 2020年3月15日星期日 在 LeetCode 做的第一题，比起以前做的 OJ 系统，省去了编写繁琐、无脑的读取文件操作部分的代码，很人性化 解法一 92ms 暴力遍历 class Solution { public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[i] + nums[j] == target) { result[0] = i; result[1] = j; return result; } } } return result; } } 时间复杂度 O(n2) 空间复杂度 O(1) 解法二 4ms 借助 Hash 表 class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(nums.length); for (int i = 0; i &lt; nums.length; i++) { int a = target - nums[i]; if (map.containsKey(a)) { return new int[]{map.get(a), i}; } map.put(nums[i], i); } throw new IllegalArgumentException(); } } 个人观点 题目并没有明确提到给定数组中不会出现重复元素，但根据题意，如果真的有重复元素，那结果就可能会有多个，真的有重复数据，就会自动覆盖掉，代码仍可以返回其中一组答案，所以把数组元素当作 map 的 key 也是没有问题的 时间复杂度 O(n) 遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间 空间复杂度 O(n) 所需的额外空间取决于哈希表中存储的元素数量，最多存储 n 个元素 ","link":"http://blog.kuranado.com/post/leetcode-1-liang-shu-zhi-he/"},{"title":"CSS 浮动.md","content":"[TOC] 什么是浮动 float 属性用于创建浮动框，将其移动到一边，直到左边边缘或右边边缘及包含块或另一个浮动框的边缘 浮动最典型的应用：可以让多个块级元素在一行内并列显示（把块级元素转换为行内块元素虽然也可以在一行内并列显示，但行内块元素之间有间隙，而这个间隙是不可控的） div { width: 200px; height: 200px; background-color: skyblue; float: left; } &lt;div&gt;第一个盒子&lt;/div&gt; &lt;div&gt;第二个盒子&lt;/div&gt; div { width: 200px; height: 200px; background-color: skyblue; } .left { float: left; } .right { float: right; } &lt;div class=&quot;left&quot;&gt;第一个盒子&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;第二个盒子&lt;/div&gt; 浮动特性（重难点） 浮动的元素会脱离标准流（脱标） 浮动的元素脱标后，浮动的盒子不再保留原先的位置 .left { width: 100px; height: 100px; background-color: skyblue; float: left; } .standard { width: 300px; height: 300px; background-color: peru; } &lt;div class=&quot;left&quot;&gt;浮动的盒子&lt;/div&gt; &lt;div class=&quot;standard&quot;&gt;标准流的盒子&lt;/div&gt; 如上图，浮动的元素会压住下面标准流的盒子，但是，浮动的盒子不会压住下面标准流的图片或文字，因为浮动产生的最初目的是为了做文字环绕效果的（如果想让盒子压住文字或图片，应该为盒子添加绝对定位或固定定位）： div { float: left; width: 100px; height: 100px; background-color: skyblue; } &lt;div&gt;&lt;/div&gt; &lt;p&gt;浮动的元素不会压住标准流盒子里的文字或图片&lt;/p&gt; 浮动的元素会一行内显示并且元素顶部对齐 如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列 div { width: 200px; height: 200px; float: left; } .one { background-color: pink; } .two { background-color: orange; height: 220px; } .three { background-color: gray; } .four { background-color: skyblue; } &lt;div class=&quot;one&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;four&quot;&gt;4&lt;/div&gt; 浮动的元素是相互贴靠在一起，不会有缝隙，如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐 浮动的元素具有行内块元素的特性 任何元素都可以浮动，不管原先是什么模式的元素，添加浮动之后具有与行内块元素相似的特性 span { float: left; width: 100px; height: 100px; background-color: pink; } &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; span 为行内元素，行内元素直接指定高度或宽度是无效的，但是为其添加浮动后，便具有了与行内块元素相似的特性，因为行内块元素的宽度、高度、外边距、内边距都可以设置，所以上面代码的宽度和高度将会生效。 所以如果行内元素有了浮动，则不需要转换为块级元素或行内块元素，便可以直接为其设置高度和宽度。 span { float: left; width: 100px; height: 100px; background-color: pink; } p { height: 200px; background-color: purple; } &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;p&gt;p&lt;/p&gt; p 是块状元素，没有浮动，是标准流的盒子，没有为其指定宽度，其宽度默认为容器（父元素）的 100%，下面为 p 添加浮动： span { float: left; width: 100px; height: 100px; background-color: pink; } p { float: left; height: 200px; background-color: purple; } &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;p&gt;p&lt;/p&gt; 为 p 元素添加浮动后，它便拥有了与行内块元素相似的特性，如果没有为行内块元素指定宽度，则行内块元素的默认宽度为它本身内容的宽度 浮动元素经常和标准流父级搭配使用 为了约束浮动元素位置，网页布局一般采取的策略是：先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置，这也刚好符合网页布局第一准则 一个元素浮动了，理论上，应该为其余的兄弟元素也设置浮动 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流 .one { width: 100px; height: 100px; background-color: pink; } .two { width: 200px; height: 200px; background-color: orange; float: left; } .three { width: 300px; height: 300px; background-color: skyblue; } &lt;div class=&quot;one&quot;&gt;标准流&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;浮动&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;标准流&lt;/div&gt; 清除浮动 为什么要清除浮动 如果为父盒子定义高度，父盒子内子元素都设置浮动没问题，然而子元素的数据往往是不确定的，如果子元素数量较多，很可能会超出父盒子的范围，所以父盒子一般不方便指定高度 由于很多情况下，父盒子不方便指定高度，父盒子内浮动的子盒子又不占有位置，所以父盒子的高度就会变成 0，进而影响页面上其它标准流盒子的排版 清除浮动的本质 清除浮动的本质是清除浮动元素造成的影响 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父盒子就会根据浮动的子盒子自动检测高度。标准流的父盒子有了高度，就不会影响下面的标准流了 语法 clear: 属性值 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 最常用，同时清除左右两侧浮动的影响 清除浮动的四种方法 1. 额外标签法（不常用） 也称隔墙法，W3C 推荐做法 在浮动元素末尾添加一个空的块级标签，例如：&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;（不一定必须是 div 标签，只要是块级元素即可） 优点：通俗易懂，书写方便 缺点：添加许多无意义的标签，结构化较差 .box { width: 230px; background-color: #ccc; } .one { width: 100px; height: 100px; background-color: pink; float: left } .two { width: 100px; height: 100px; background-color: orange; float: left; } .three { width: 300px; height: 300px; background-color: skyblue; } .clear { clear: both; } &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;one&quot;&gt;浮动1&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;浮动2&lt;/div&gt; &lt;div class=&quot;one&quot;&gt;浮动3&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;浮动4&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;three&quot;&gt;标准流&lt;/div&gt; 2. 为父盒子添加 overflow 属性 可以给父级元素添加 overflow 属性，将其属性设置为 hidden 或 auto 或 scroll 优点：代码简洁 缺点：无法显示溢出的部分 .box { width: 230px; background-color: #ccc; overflow: hidden; } .one { width: 100px; height: 100px; background-color: pink; float: left } .two { width: 100px; height: 100px; background-color: orange; float: left; } .three { width: 300px; height: 300px; background-color: skyblue; } .clear { clear: both; } &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;one&quot;&gt;浮动1&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;浮动2&lt;/div&gt; &lt;div class=&quot;one&quot;&gt;浮动3&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;浮动4&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;three&quot;&gt;标准流&lt;/div&gt; 3. 为父盒子添加 after 伪元素 本质是 CSS 为父元素内最后添加一个子元素，原理和额外标签法类似 为父元素添加如下样式（类名一般约定为 clearfix）： .clearfix:after { content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix:after { /** 兼容 IE6、IE7 专用**/ *zoom: 1; } 优点：没有增加标签，结构更简单 缺点：需要照顾低版本的浏览器 代表网站：百度、淘宝网、网易等 .clearfix:after { content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; } .clearfix { /** 兼容 IE6、IE7 专用**/ *zoom: 1; } .box { width: 230px; background-color: #ccc; } .one { width: 100px; height: 100px; background-color: pink; float: left } .two { width: 100px; height: 100px; background-color: orange; float: left; } .three { width: 300px; height: 300px; background-color: skyblue; } .clear { clear: both; } &lt;div class=&quot;box clearfix&quot;&gt; &lt;div class=&quot;one&quot;&gt;浮动1&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;浮动2&lt;/div&gt; &lt;div class=&quot;one&quot;&gt;浮动3&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;浮动4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;three&quot;&gt;标准流&lt;/div&gt; 4. 为父元素添加双伪元素 为父元素添加如下样式： .clearfix:before, .clearfix:after { content: &quot;&quot;; display: table; } .clearfix:after { clear: both; } .clearfix { /** 兼容 IE6、IE7 专用**/ *zoom: 1; } 优点：代码更简洁 缺点：需要照顾低版本浏览器 .clearfix:before, .clearfix:after { content: &quot;&quot;; display: table; } .clearfix:after { clear: both; } .clearfix { /** 兼容 IE6、IE7 专用**/ *zoom: 1; } .box { width: 230px; background-color: #ccc; } .one { width: 100px; height: 100px; background-color: pink; float: left } .two { width: 100px; height: 100px; background-color: orange; float: left; } .three { width: 300px; height: 300px; background-color: skyblue; } .clear { clear: both; } &lt;div class=&quot;box clearfix&quot;&gt; &lt;div class=&quot;one&quot;&gt;浮动1&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;浮动2&lt;/div&gt; &lt;div class=&quot;one&quot;&gt;浮动3&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;浮动4&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;three&quot;&gt;标准流&lt;/div&gt; ","link":"http://blog.kuranado.com/post/css-fu-dong-md/"},{"title":"CSS 盒子模型.md","content":"[TOC] CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，包括：边框、外边距、内边距和实际内容 边框 border-width 边框粗细 border-style 边框样式 none 默认，无边框 solid 最常用，实线边框 dashed 虚线边框 double 双线边框 dotted 电线边框 border-color 边框颜色 border 边框简写，没有先后顺序要求，但一般写成：border: 边框粗细 边框样式 边框颜色，如 border: 1px solid red; border-top 只设置上边框 border-bottom 只设置下边框 border-left 只设置左边框 border-right 只设置右边框 border-collapse 合并相邻边框 注意： 边框会改变盒子大小，如： /** 200px * 200px 的盒子 **/ div { width: 200px; height: 200px; background-color: pink; } &lt;div&gt;&lt;/div&gt; 加上 border 后，将会使盒子变大： /** 220px * 220px 的盒子 **/ div { width: 200px; height: 200px; background-color: pink; border: 10px solid red; } &lt;div&gt;&lt;/div&gt; 如果加上边框后，并不想改变盒子原有大小，则可以用盒子原有宽度/高度减去 2 * 边框的宽度： /** 200px * 200px 的盒子 **/ div { width: 180px; height: 180px; background-color: pink; border: 10px solid red; } &lt;div&gt;&lt;/div&gt; 内边距 padding 设置内边距，即边框与内容之间的距离 跟一个值，表示上下左右的内边距 跟两个值，第一个值表示上、下内边距，第二个值表示左、右内边距 跟三个值，第一个值表示上内边距，第二个值表示左、右内边距，第三个值表示下内边距 跟四个值，依次表示上、右、下、左内边距 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 注意： 内边距会改变盒子大小，如： /** 200px * 200px 的盒子 **/ div { width: 200px; height: 200px; background-color: pink; } &lt;div&gt;&lt;/div&gt; 加上 padding 后，将会撑大盒子： /** 220px * 220px 的盒子 **/ div { width: 200px; height: 200px; background-color: pink; padding: 10px; } &lt;div&gt;&lt;/div&gt; 如果加上边框后，并不想改变盒子原有大小，则可以用盒子原有宽度/高度减去 2 * padding 的宽度： /** 200px * 200px 的盒子 **/ div { width: 180px; height: 180px; background-color: pink; padding: 10px; } &lt;div&gt;&lt;/div&gt; 如何盒子本身没有指定 width 或 height 属性，则此时 padding 不会撑开盒子大小，如： div { height: 200px; background-color: pink; padding: 30px; } &lt;body&gt; &lt;!-- div 只指定了高度，没有指定宽度，所以该盒子高度将变成 260px，但是宽度保持不变 --&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; div { width: 100%; height: 200px; background-color: pink; padding: 30px; } &lt;body&gt; &lt;!-- div 既指定了高度，也指定了宽度，所以该盒子高度将变成 260px，宽度在父元素宽度的基础上增加 2 * 30px --&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt; div { width: 200px; height: 200px; background-color: pink; } div p { padding: 30px; background-color: purple; } &lt;body&gt; &lt;div&gt; &lt;!-- p 是块状元素，没有为其指定宽度，则其宽度默认是容器（父元素）的 100%，所以此处 p 的宽度是 200px；也没有为其指定高度，所以此处 p 的高度是 2 * 30px = 60px --&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; div { width: 200px; height: 200px; background-color: pink; } div p { width: 100%; padding: 30px; background-color: purple; } &lt;body&gt; &lt;div&gt; &lt;!-- p 是块状元素，为其指定了高度是容器（父元素）的 100%，所以此处 p 的宽度是 200px + 2 * 30px = 260px；没有为其指定高度，所以此处 p 的高度是 2 * 30px = 60px --&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; 外边距 margin 设置外边距，即控制盒子与盒子之间的距离 跟一个值，表示上下左右的外边距 跟两个值，第一个值表示上、下外边距，第二个值表示左、右外边距 跟三个值，第一个值表示上外边距，第二个值表示左、右外边距，第三个值表示下外边距 跟四个值，依次表示上、右、下、左外边距 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 外边距的典型应用 外边距可以让块级盒子水平居中，但必须满足如下两个条件： 盒子必须指定了宽度 盒子左右的外边距都设置为 auto，如：margin: 0 auto; div { width: 900px; height: 200px; background-color: pink; margin: 0 auto; } &lt;div&gt;&lt;/div&gt; 行内元素或者行内块元素水平居中，只要给其父元素添加 text-align: center; 即可 div { width: 900px; height: 200px; background-color: pink; margin: 0 auto; text-align: center; } &lt;div&gt; &lt;!-- 行内元素 --&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- 行内块元素 --&gt; &lt;img src=&quot;./images/logo.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; 外边距可能造成的问题 相邻块元素垂直外边距合并问题（元素浮动后不会出现此问题） 使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top，则它么之间的垂直间距不是 margin-bottom 和 margin-top 之和。而是取两个值中的较大者 针对此问题的解决方案：尽量只给一个盒子添加 margin 值 嵌套块元素垂直外边距的塌陷问题（元素浮动后不会出现此问题） 对于两个嵌套（父子关系）的块元素，父元素有上外边距，同时子元素也有上外边距，此时父元素会塌陷成较大的上外边距 .father { width: 200px; height: 200px; background-color: pink; margin-top: 50px; } .son { width: 40px; height: 40px; background-color: purple; margin-top: 100px; } &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; 针对此问题的解决方案有 3 个： 为父元素定义上边框 .father { width: 200px; height: 200px; background-color: pink; margin-top: 50px; border-top: 1px solid transparent; } .son { width: 40px; height: 40px; background-color: purple; margin-top: 100px; } &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; 为父元素定义上内边距 为父元素添加 overflow:hidden 兼容性 内外边距 清除浏览器默认内外边距 /** CSS 的第一行代码 **/ * { margin: 0; padding: 0; } 行内元素的内外边距兼容性 行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块元素或行内块元素就没有这个问题 span { /** span 为行内元素，只有左右内外边距生效为 20px，上下内外边距没有生效 **/ margin: 20px padding: 20px; } &lt;span&gt;Hello&lt;/span&gt; ","link":"http://blog.kuranado.com/post/css-he-zi-mo-xing-md/"},{"title":"电影 & 电视剧.md","content":"已看 Rango 蓝戈 超能陆战队 忠犬八公的故事 肖申克的救赎 魔女宅急变 致命魔术 机器人瓦利 超级大坏蛋 功夫熊猫 1、2、3 龙猫 冰雪奇缘 1、2 冰雪奇缘-生日惊喜 恐怖游轮 天空之城 千与千寻 哈尔的移动城堡 杀死比尔 1、2 速度与激情 3、4、5、6、7、8 天将雄师 神偷奶爸 1、2、3 小黄人大冒险 钢铁侠 海扁王 1 东成西就 起风了 婚纱 天降美食 1、2 指环王-护戒使者 指环王-双塔奇兵 指环王-王者归来 霍比特人-意外之旅 霍比特人-史矛革荒漠 霍比特人-五军之战 头脑特工队 源代码 记忆碎片 妈妈再爱我一次 青春派 黑客帝国 1、2 模仿游戏 天才眼镜狗 穿靴子的猫 穿靴子的猫番外篇-萌猫三剑客 盗梦空间 逆世界 终结者 碟中谍 1、2、3、4、5 黑衣人 1、2、3 少年班 教父 1、2、3 阿甘正传 剪刀手爱德华 第九区 人工智能 惊天魔盗团 1、2 大圣归来 马达加斯加的企鹅 1、2 狮子王 百万富翁 驯龙高手 1、2、3 怪物史莱克 1、2、3、4 机器管家 返老还童 飞屋环游记 像素大战 蚁人 侏罗纪公园 憨豆特工 憨豆的黄金周 玛丽与马克思 海上钢琴师 功夫之王 四大名捕 天下无贼 那些年我们一起追过的女孩 功夫 长江7号 后天 2012 我是传奇 超人汉考克 哥斯拉 暮光之城 1、2、3、4 破晓上、4 破晓下 风之谷 叶问 1、2、3、4 海绵宝宝历险记 十月围城 一代宗师 师父 镖门 极速蜗牛 史蒂夫乔布斯 乔布斯传 疯狂动物城 美人鱼 楚门的世界 雷蒙-斯尼奇的不幸历险 机械姬 拯救大兵瑞恩 入殓师 盗走达芬奇 蝴蝶效应 1、2、3 偷天换日 十二只猴子 星际穿越 死侍 1、2 异邦人-无皇刃谭 饥饿游戏 1 机械心（法国） 怪兽大学 美国队长 3 神战 - 权利之眼 心灵捕手 头文字D剧场版-梦现 哆啦A梦-伴我同行 BAT MAN VS SUPER MAN 鲁滨逊漂流记 泰迪熊 1、2 爱宠大机密 生化危机 1 - 变种生还 生化危机 2 - 启示录 生化危机 3 - 灭绝 生化危机 4 - 战神再生 生化危机 5 - 惩罚 生化危机 6 - 终章 生化危机-恶化 这个杀手不太冷 生化危机-诅咒 茱莉亚的眼睛 你的名字 秒速五厘米 机械师 2 佩小姐的奇幻城堡 猫的报恩 权力的游戏 杀戮都市 1、2 热血高校 1、2 言叶之庭 加勒比海盗 1、2、3、4、5 萤火虫之墓 变形金刚 1、2、3、4、5 当幸福来敲门 少年派的奇幻漂流 美丽心灵 序列之争 凉宫春日的消失 境界的彼方-未来篇 菊次郎的夏天 环太平洋 1、2 轻音少女剧场版 玉子的爱情故事 寻梦环游记 明日边缘 土拨鼠之日 魁拔 1 - 十万火急 魁拔 2 - 大战元泱界 魁拔 3 - 战神崛起 英伦对决 奇幻森林 唐人街探案 1、2 电锯惊魂 1、8 艺伎回忆录 猫汤 伊豆的舞女 神鞭 达芬奇密码 哈利波特 1 - 魔法师 哈利波特 2 - 密室 西虹市首富 奇异博士 失恋 33 天 情书 朝花夕誓 风雨哈佛路 飓风营救 摩天营救 摄影机不要停 阿尔法-狼伴归途 疯狂的麦克斯 1、4 流浪地球 海王 特种部队 2 - 全面反击 白蛇缘起 花牌情缘 上之句 花牌情缘 下之句 神探夏洛克 惊奇队长 X 战警 银河护卫队 1、2 帕丁顿熊 2 复仇者联盟 1、2、3、4 阿丽塔 蜘蛛侠 - 英雄远征 哪吒之魔童降世 中国机长 天气之子 生死狙击 星际探索 猩球崛起 全民风暴 忍者神龟-变种时代 荒野猎人 调音师 忍者神龟 2 - 破影而出 2020年4月25日星期六 灭绝 - 烂片 Hello World 黑金 灵魂摆渡 画壁 诸神之怒 诸神之战 2020年7月11日星期六 X 特遣队 王牌特工 2 黄金圈 2020年10月1日星期四 王牌特工 1 特工学院 2020年10月1日星期四 待看 幽灵公主 种下星星的日子 蜘蛛侠-英雄归来 匆匆那年 泰坦尼克号 罗马假日 红猪 侧耳倾听 小美人鱼 玩具总动员 怪兽大战外星人 料理鼠王 ET 硅谷传奇 卧虎藏龙 阿凡达 1、2 冰河世纪 疯狂原始人 守护者联盟 贫民窟的百万富翁 银翼杀手 彗星来的那一夜 希特勒的名单 十二怒汉 异次元骇客 感官游戏 冒名顶替 无姓之人 香草的天空 星际迷航 独立日 荒野猎人 第三种爱情 拉登日记 乱世佳人 苔丝 霸王别姬 美丽人生 三傻大闹宝莱坞 放牛班的春天 怦然心动 V字仇杀队 被嫌弃的松子的一生 穿越时空的少女 荒野生存 叛逆的物语 沉默的羔羊 控方证人 锅匠 裁缝 士兵 间谍（Tinker Tailor Soldier Spy） 第六感 傲慢与偏见 刺客联盟 末日崩塌 隧道 感冒 铁线虫入侵 恐怖直播 万物理论 社交网络 缩小人生 地球停转之日 恋空 黑镜 死亡诗社 和莎莫的 500 天 饮食男女 我是大哥大 星运里的错 突袭 无敌破坏王 1 无敌破坏王 2 - 大闹互联网 回到未来 刺客信条 死亡笔记 金田一 安德的游戏 最终幻想 阿拉丁神灯 木乃伊 国家宝藏 博物馆奇妙夜 舞出我人生 赌博默示录 1、2 超体 蓝色大海的传说 来自星星的你 巨额来电 二代妖精 可可西里的美丽传说 信条 摩天大楼 ","link":"http://blog.kuranado.com/post/dian-ying-and-dian-shi-ju-md/"},{"title":"正则表达式总结.md","content":"基本 正则表达式区分字母大小写 . 字符可以匹配任意单个字符、字母、数字、空格甚至是 . 字符本身。但在绝大多数正则表达式实现里，. 不能匹配换行符 \\ 用于转义 \\. 匹配字符 . 本身 \\\\ 匹配字符 \\ 字符区间 [abc] 匹配字符 a 或 b 或 c， [0-9] 等价于 [0123456789] [a-z] 等价于 [abcdefghijklmnopqrstuvwxyz]，[A-Z] 等价于 [ABCDEFGHIJKLMNOPQRSTUVWXYZ]，[A-z] 等价于 [ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz]（按照 Ascii 顺序），[A-Za-z0-9] 等价于 [ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789] 很多程序员喜欢把一个字符也定义为一个字符区间，如 [a] 等价于 a，[\\r]? 等价于 \\r?，但前者可以避免产生误解、增加可读性，所以建议一个字符也定义为字符区间 排除 [^a-c] 排除 a 或 b 或 c 空白字符 [\\b] 匹配回退（并删除）一个字符（Backspace 键） \\f 匹配换页符 \\r 匹配回车符 \\n 匹配换行符 \\t 匹配制表符（Tab 键） \\v 匹配垂直制表符 在 Unix 或 Linux 上使用 \\n 匹配行尾标记，Windows 上使用 \\r\\n 匹配行尾标记 特定字符类型 \\d 匹配任何一个数字字符，等价于 [0-9] \\D 匹配任何一个非数字字符，等价于 [^0-9] \\w 匹配任何一个字母（大小写均可）或数字类型或下划线字符，等价于 [A-z0-9_] \\W 匹配任何一个非字母（大小写均可）或数字类型或下划线字符，等价于 [^A-z0-9_] \\s 匹配任何一个空白字符，等价于 [\\f\\r\\n\\t\\v ]，注意包含空格 \\S 匹配任何一个非空白字符，等价于 [^\\f\\r\\n\\t\\v ] 转义 .、[、]、\\、+、*、?、(、) 等具有特殊含义的符号被称为元字符，如果要匹配元字符，则需要对元字符进行转义，如 \\. 匹配字符 .，\\[ 匹配字符 [，\\] 匹配字符 ]，\\\\ 匹配字符 \\ / 字符并不是元字符，在绝大多数正则表达式解析器中如果要匹配字符 / 并不需要转义，但有些解析器却要求必须转义才能够匹配，所以建议总是在需要匹配字符 / 时对其进行转义，即使用 \\/ 匹配字符 /，这样在所有解析器中都能够正常工作 像 .、+ 这样的元字符出现在字符区间内部时，将会被解释为普通字符，可以不用转义，如 [\\w\\.] 等价于 [\\w.]，但为了防止误解，建议显示转义 重复匹配 + 元字符匹配一个或多个字符，如 a+ 匹配一个或多个连续的 a，[0-9]+ 匹配一个或多个连续的数字 * 元字符匹配 0 个或多个字符 ? 元字符匹配 0 个或 1 个字符 {n} 重复匹配 n 次 {m,n} 重复匹配 m ~ n 次，如 {0,1} 表示最少匹配 0 次，最多匹配 1 次，等价于 ? {m,} 重复匹配至少 m 次 * 和 + 是贪婪型元字符，它们会尽可能地从一段文本的开头一致匹配到末尾，而不是碰到一个匹配时就停止，如果想要碰到第一个匹配时就停止，则应该使用元字符对应的懒惰型。* 元字符对应的懒惰型为 *?，+ 元字符对应的懒惰型为 +?。如想要匹配 HTML &lt;b&gt; 标签中的文本，贪婪型正则如下：&lt;[Bb]&gt;.*&lt;\\/[Bb]&gt; 但对于如下文本匹配却有问题： 正确写法是使用懒惰型：&lt;[Bb]&gt;.*?&lt;\\/[Bb]&gt; 匹配结果： 在为字符区间加后缀的时候，必须把后缀放到区间外面，如 [0-9]+ 是正确的，而 [0-9+] 是错误的，同理 [0-9]*、[0-9]? 是正确的，而 [0-9*]、[0-9?] 是错误的 注意 {m,n} 是正确的，{m, n} 是不正确的，因为个人习惯在英文 , 后加一个空格，但在使用此正则时需要注意避免 位置匹配 \\b 表示边界（boundary），匹配单词的开头或结尾。这里所谓的单词是指能够被 \\w 匹配的内容即称为单词，\\b 匹配的时字符之间的一个位置：一边是单词（能够被 \\w 所匹配的），一边是其它内容（能够被 \\W 所匹配的）。b 匹配的是一个位置，而不是任何实际字符 \\B 不匹配单词边界 ^ 匹配字符串开头位置。^ 用于字符区间中表示排除，如 [^abc] [^a-c] 排除 a 或 b 或 c，但当 ^ 用于字符区间之外时，则表示匹配字符串的起始位置 $ 匹配字符串结尾位置 (?m) 用于开启多行模式，(?m) 必须出现在整个模式的最前面，但实际包括 JavaScript 在内的许多正则表达式都不支持 (?m) 子表达式 前面介绍的重复匹配只作用于紧挨着它的前一个字符或元字符，为了能够重复匹配多个字符，需要使用子表达式 子表达式必须出现在元字符 ( 和 ) 之间 对于不需要使用子表达式的地方，如果加上元字符 ( 和 ) 使其成为子表达式，虽然对匹配结果不会有任何影响，但可能会影响性能，如把 \\d{1,3} 如果写成子表达式：(\\d{1,3})，匹配结果完全一样，但后者可能会影响性能 因为模式是从左到右进行评估的，首先测试第一个，然后测试第二个，只要有任何一个模式匹配，就不再测试选择结构中的其它模式。比如 IP 地址的匹配： IP 地址范围为 0.0.0.0 ~ 255.255.255.255，总结如下： 任意的 1 位或 2 位数字 任意的以 1 开头的 3 位数字 任意的以 2 开头，第二位数字在 0 到 4 之间的 3 位数字 任意的以 25 开头，第三位数字在 0 到 5 之间的 3 位数字 很容易写出如下正则： (((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5]))\\.){3}((\\d{1,2})|(1\\d{2})|(2[0-4]\\d)|(25[0-5])) 但这个正则却是错误的，如 IP 地址：12.159.46.200 的匹配结果如下图，最后的 0 无法被匹配，这是因为 20 已经被子表达式 (\\d{1, 2}) 匹配，并没有被 (25[0-5]) 匹配 正确的写法如下：((((25[0-5])\\d)|(2[0-4]\\d)|(1\\d{2})|(\\d{1,2}))\\.){3}(((25[0-5])\\d)|(2[0-4]\\d)|(1\\d{2})|(\\d{1,2})) 匹配结果： 反向引用 反向引用允许正则表达式模式引用之前匹配的结果，如想要匹配所有的 HTML 标题，正则如下： (&lt;[Hh]1&gt;.*?&lt;\\/[Hh]1&gt;)|(&lt;[Hh]2&gt;.*?&lt;\\/[Hh]2&gt;)|(&lt;[Hh]3&gt;.*?&lt;\\/[Hh]3&gt;)|(&lt;[Hh]4&gt;.*?&lt;\\/[Hh]4&gt;)|(&lt;[Hh]5&gt;.*?&lt;\\/[Hh]5&gt;)|(&lt;[Hh]6&gt;.*?&lt;\\/[Hh]6&gt;) 匹配结果也的确是正确的： 但是这样写未免过于臃肿，所以有人可能会这样写： &lt;[Hh][1-6]&gt;.*?&lt;\\/[Hh][1-6]&gt; 但实际这却是错误的，因为他会将 &lt;h2&gt; 和 &lt;/h3&gt; 匹配到一块，而这是错误的 HTML 标题： 正确的写法是使用反向引用： &lt;[Hh]([1-6])&gt;.*?&lt;\\/[Hh]\\1&gt; 匹配结果： 使用了 \\1 引用了第 1 个子表达式 ([1-6])，如果有第 2 个、第 3 个等子表达式，则使用 \\2、\\3 引用 反向引用只能引用括号里的子表达式 不同的正则实现中，反向引用的语法存在很大差异，如 JavaScript 和 vim 在搜索时使用 \\ 标识反向引用，在替换时使用 $ 标识反向引用，Perl 搜索和替换都使用 $ 标识反向引用 反向引用替换 如将文档中的所有邮箱地址全替换为 HTML 链接 先写出正则表达式，找出所有的邮箱地址，为了能够使用反向引用，加 ( 和 ) 让其变成子表达式：(\\w+[\\w\\.]*@[\\w\\.]+\\.\\w+) 编写替换的表达式：&lt;a href=&quot;mailto:$1&quot;&gt;$1&lt;/a&gt; 开始替换，可以使用编程语言，如 JavaScript，这里简单直接以 VsCode 操作为例（注意要选择正则表达式模式）： 点击替换按钮，替换结果如下： 反向引用替换大小写转换（并不是所有正则表达式实现都支持）： \\U 把 \\U 到 \\E 之间的字符全部转换为大写 \\L 把 \\L 到 \\E 之间的字符全部转换为小写 \\E 结束 \\U 或 \\L 转换 u 把下一个字符转换为大写 l 把下一个字符转换为小写 环视 ?= 表示向前查看，如：?=: 匹配字符 : 但不消耗字符 :，所谓的不消耗是指匹配到的 : 不会在最终的匹配结果中返回。如对于如下文本：http://www.baidu.com 表达式 http: 匹配 http:，而如果使用向前查看，表达式为：http(?=:)，匹配结果为：http，不包含字符 : ?&lt;= 表示向后查看，如：?&lt;=\\$ 匹配字符 $，但不消耗字符 $，如对于如下文本：ABC01: $253.00 表达式 \\$[\\d\\.]+\\d{2} 匹配 $253.00，而如果使用向后查看，表达式为：(?&lt;=\\$)[\\d\\.]+\\d{2}，匹配结果为：253.00，不包含字符 $ 向前查看和向后查看的否定式分别为：?! 和 ?&lt;!，即将肯定式中的 = 换成 ! 所有主流正则表达式实现都支持向前查看，但有些语言不支持向后查看，如 JavaScript 正则测试网站 https://regex101.com/ https://www.regextester.com/ 参考 《正则表达式必知必会修订版》 ","link":"http://blog.kuranado.com/post/zheng-ze-biao-da-shi-zong-jie-md/"},{"title":"CSS 元素的显示模式.md","content":"[TOC] 块元素 div、p、h1 ~ h6、ul、ol、li 标签都是典型的块元素 独占一行 宽度、高度、外边距、内边距都可以控制 宽度默认是容器（父元素）的 100% 不会继承父元素的高度 是一个容器或盒子，里面可以放块元素或行内元素 注意： 文字类的元素内不能再放块元素，如 p 标签内不能再放块元素，特别是不能再放 div 标签，同理，h1 ~ h6 也是文字类块元素，里面不能再放其它块元素 行内元素 a、strong、b、em、i、del、s、ins、u、span 标签都是典型的行内元素，行内元素也称为内联元素 相邻行内元素显示在一行上，一行可以显示多个行内元素 为行内元素设置宽度、高度是不生效的 默认宽度就是它本身内容的宽度 行内元素只能容纳文本或其它行内元素（a 标签除外，a 标签内可以再放块元素，如 div 标签） 注意： a 标签内不能再放其它 a 标签 a 标签内可以再放块元素，如 div 标签，但是一般的做法是将 a 标签转换为块元素，然后再在 a 标签内放块元素（这种情况下，a 不转换为块级元素也可以，但是安全起见，建议当 a 标签内包含块级元素时，将 a 标签转换为块级元素） 行内块元素 img、input、td 都是典型的行内块元素，它们同时具有块元素和行内元素的特点 相邻行内块元素显示在一行上，但是它们之间会有空白缝隙，一行可以显示多个行内块元素 默认宽度就是它本身内容的宽度 宽度、高度、外边距、内边距都可以控制 元素显示模式转换 转换为行内元素（使用的很少） div { background-color: skyblue; display: inline; } &lt;div&gt;转行内元素一&lt;/div&gt; &lt;div&gt;转行内元素二&lt;/div&gt; 转换为块元素（最常用） span { width: 200px; height: 200px; background-color: pink; display: block; } &lt;span&gt;转块元素一&lt;/span&gt; &lt;span&gt;转块元素二&lt;/span&gt; 转换为行内块元素（常用） span { width: 200px; height: 200px; background-color: pink; display: inline-block; } &lt;span&gt;转行内块元素一&lt;/span&gt; &lt;span&gt;转行内块元素二&lt;/span&gt; 单行文字垂直居中原理 行高等于文字本身高度 + 上边距 + 下边距，如果盒子高度等于行高，文字显然会垂直居中，如： a { display: block; width: 200px; height: 40px; font-size: 14px; line-height: 40px; color: white; font-weight: 700; text-decoration: none; padding-left: 30px; background-color: #434648; } a:hover { background-color: #F74E00; } &lt;a href=&quot;#&quot;&gt;手机 电话卡&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;电视 盒子&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;笔记本 平板&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;出行 穿戴&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;智能 路由器&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;健康 儿童&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;耳机 音箱&lt;/a&gt; 如果行高小于盒子高度，则文字会偏上；如果行高大于盒子高度，则文字会偏下 ","link":"http://blog.kuranado.com/post/css-yuan-su-de-xian-shi-mo-shi-md/"},{"title":"VsCode 中 Emmet 语法快速生成HTML 和 CSS 代码.md","content":"[TOC] 敲完简写后，按 Tab 自动完成 HTML div &lt;div&gt;&lt;/div&gt; div*3 &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; {} 定义标签内的内容，div{Hello} &lt;div&gt;Hello&lt;/div&gt; div{Hello}*3 &lt;div&gt;Hello&lt;/div&gt; &lt;div&gt;Hello&lt;/div&gt; &lt;div&gt;Hello&lt;/div&gt; 父子关系标签，使用 &gt;，如 ul&gt;li： &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; div&gt;p： &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; 兄弟关系标签，使用 +，如 div+p： &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; () 指定优先级，如 ul&gt;(li+bq)： &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;blockquote&gt;&lt;/blockquote&gt; &lt;/ul&gt; (ul&gt;li)+bq： &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;blockquote&gt;&lt;/blockquote&gt; 带有类选择器，如 .gray，默认生成 class 为 gray 的 div： &lt;div class=&quot;gray&quot;&gt;&lt;/div&gt; 如果要生成其它标签 class 为 gray，则 p.gray： &lt;p class=&quot;gray&quot;&gt;&lt;/p&gt; 一次生成多个 class 选择器，如 .box1.box2.box3： &lt;div class=&quot;box1 box2 box3&quot;&gt;&lt;/div&gt; p.box1.box2.box3： &lt;p class=&quot;box1 box2 box3&quot;&gt;&lt;/p&gt; 带有 ID 选择器，如 #gray，默认生成 id 为 gray 的 div： &lt;div id=&quot;gray&quot;&gt;&lt;/div&gt; 如果要生成其它标签 id 为 gray，则 p#gray： &lt;p id=&quot;gray&quot;&gt;&lt;/p&gt; 既有类选择器，又有 id 选择器，如 p.box1.box2#gray： &lt;p class=&quot;box1 box2&quot; id=&quot;gray&quot;&gt;&lt;/p&gt; [] 表示属性，如 ul&gt;li&gt;a[href=&quot;#&quot;]： &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; $ 表示自增，如 div{$}*3： &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; div.gray$*3： &lt;div class=&quot;gray1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gray2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;gray3&quot;&gt;&lt;/div&gt; p.gray${$}*3： &lt;p class=&quot;gray1&quot;&gt;1&lt;/p&gt; &lt;p class=&quot;gray2&quot;&gt;2&lt;/p&gt; &lt;p class=&quot;gray3&quot;&gt;3&lt;/p&gt; ul&gt;li.gray${Hello$}*3： &lt;ul&gt; &lt;li class=&quot;gray1&quot;&gt;Hello1&lt;/li&gt; &lt;li class=&quot;gray2&quot;&gt;Hello2&lt;/li&gt; &lt;li class=&quot;gray3&quot;&gt;Hello3&lt;/li&gt; &lt;/ul&gt; CSS CSS 中一般取每个单词首字母，然后 Tab 即可自动补全/生成： w200： width: 200px; h200： height: 200px; lh26px： line-height: 26px; ti2em： text-indent: 2em; tdn： text-decoration: none; tac： text-align: center; ","link":"http://blog.kuranado.com/post/vscode-zhong-emmet-yu-fa-kuai-su-sheng-cheng-html-he-css-dai-ma-md/"},{"title":"CSS 选择器.md","content":"[TOC] 基础选择器 标签选择器 /** 选择所有 p 标签 **/ p { color: red; } 类选择器 /** 选择所有 class 属性值为 red 的标签 **/ .red { color: red; } &lt;p class=&quot;red&quot;&gt;Hello&lt;/p&gt; 类选择器-多类名 .box { width: 100px; height: 100px; font-size: 35px; } .red { color: red; } .green { color: green; } &lt;div class=&quot;box red&quot;&gt;红色&lt;/div&gt; &lt;div class=&quot;box green&quot;&gt;绿色&lt;/div&gt; &lt;div class=&quot;box red&quot;&gt;红色&lt;/div&gt; ID 选择器 #pink { color: pink; } &lt;p id=&quot;pink&quot;&gt;Hello&lt;/p&gt; 通配符选择器 /** 选择页面所有标签 **/ * { maring: 0; padding: 0; } 复合选择器 后代选择器（又称包含选择器，重要） /** 选择 ol 下的所有 li 标签（包括子元素、孙子元素、重孙等） **/ ol li { color: pink; } 子选择器（重要） /** 只选择第一代子元素（只选择亲儿子） **/ div &gt; a { color: red; } 并集选择器（重要） /** 选择 div 标签、 p 标签和 .nav 下的 ul 下的 li 标签 **/ div, p, .nav ul li { color: red; } 伪类选择器 链接伪类选择器 /** 选择所有未被点击过的链接（不常用，一般直接用 a 标签选择器选择） **/ a:link { color: black; } /** 选择所有点击过的链接 **/ a:visited { color: orange; } /** 选择鼠标悬浮的链接，最常用 **/ a:hover { color: blue; } /** 选择鼠标按下，还没有抬起的链接 **/ a:active { color: green; } 一般只会用到 a:hover 选择器，如果 4 个链接伪类选择器都要使用，则一定要按照 LVHA 的先后顺序定义，否则将不会生效 focus 伪类选择器 /** 选择获取焦点的表单元素 **/ input:focus { background-color: yellow; } 选择器权重（优先级） !import &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器，伪类选择器 &gt; 标签选择器 &gt; 继承或者 * 选择器 权重 继承或者 * 0 0 0 0 标签选择器，伪元素选择器 0 0 0 1 类选择器，伪类选择器，属性选择器（CSS3） 0 0 1 0 ID 选择器 0 1 0 0 行内样式 1 0 0 0 !import 无穷大 浏览器为 a 标签默认指定了蓝色、带下划线的样式，如： body { color: red; } &lt;body&gt; &lt;!-- 显示为蓝色带下划线，因为浏览器默认为 a 标签指定了蓝色下划线，而标签选择器优先级 &gt; 继承，所以最终显示为蓝色带下划线 --&gt; &lt;a href=&quot;#&quot;&gt;链接&lt;/a&gt; &lt;/body&gt; 复合选择器会有权重叠加，如： ul li { color: red; } li { color: green; } &lt;ul&gt; &lt;!-- 显示为红色，而不是绿色，因为标签选择器的权重为 0 0 0 1，所以复合选择器 ul li 的权重为 0 0 0 1 + 0 0 0 1 = 0 0 0 2，0 0 0 2 &gt; 标签选择器 li 的权重 0 0 0 1，所以最后显示为红色而不是绿色 --&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;/ul&gt; 再如： .nav li { color: pink; } ul li { color: red; } li { color: green; } &lt;ul class=&quot;nav&quot;&gt; &lt;!-- 显示为粉色，不是红色也不是绿色，复合选择器 .nav li 的权重为 0 0 1 0 + 0 0 0 1 = 0 0 1 1，该值大于复合选择器 ul li 的权重 0 0 0 2，也大于标签选择器 li 的权重 0 0 0 1，所以最后显示为粉色 --&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;/ul&gt; 权重虽然会有叠加，但一定不会有进位，如 0 0 0 9 + 0 0 0 2 = 0 0 0 11 而不是 0 0 1 1 ","link":"http://blog.kuranado.com/post/css-xuan-ze-qi-md/"},{"title":"同时管理 GitHub/GitLab/Gitee 等多个 SSH  Key.md","content":"平时在 GitHub 拉取、提交代码时都是通过本地放置 ~/.ssh/id_rsa 私钥，GitHub 账号下配置公钥 id_rsa.pub 完成的 但除了 GitHub，有时候还需要用到 GitLab、Gitee 等代码托管平台，如何在同一台电脑上配置多对秘钥呢？ 生成 ssh key 生成并添加第一个ssh key cd ~/.ssh ssh-keygen -t rsa -C &quot;youremail@163.com&quot; 这时可以一路回车，不输入任何字符，将自动生成 id_rsa 和 id_rsa.pub 文件 然后把 id_rsa.pub 内容添加到 GitHub 账号下，私钥保留在 ~/.ssh 目录 生成并添加第二个ssh key $ ssh-keygen -t rsa -C &quot;youremail@163.com&quot; 注意，这时不能一路回车，否则邮箱将覆盖上一次生成的 ssh key，给这个文件起一个名字， 比如叫 id_rsa_gitlab, 相应的也会生成一个 id_rsa_gitlab.pub 文件。 此时查看 ~/.ssh 下的目录文件，发现多了 id_rsa_gitlab 和 id_rsa_gitlab.pub 两个文件 同样，将 id_rsa_gitlab.pub 文件内容复制到 GitLab 账号下，id_rsa_gitlab 文件留在 ~/.ssh 目录下 增加/修改配置文件 在 ~/.ssh 目录下新建一个 config 文件 touch config 并添加以下内容 # gitlab Host gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github 需要注意的是，公司一般都是自建 GitLab，如公司自建 GitLab 地址为 http://gitlab.companyname.com，则 Host 和 HostName 就需要配置为 gitlab.companyname.com 才可以： # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa # gitlab Host gitlab.companyname.com HostName gitlab.companyname.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitlab 同理可以继续为其它代码托管平台生成公私钥 测试 $ ssh -T git@github.com 如果输出：Hi xxx You've successfully authenticated, but GitHub does not provide shell access.，说明成功的连上 github 了，以后可以自由从 GitHub 克隆、拉取、提交代码 但是如果提示：Bad owner or permissions on /home/jing/.ssh/config，则是因为 ~/.ssh/config 文件的权限不对，执行 chmod 600 ~/.ssh/config 修改权限即可 参考 GitHub/GitLab 同时管理多个ssh key ","link":"http://blog.kuranado.com/post/githubgitlab-tong-shi-guan-li-duo-ge-ssh-keymd/"},{"title":"Java 泛型总结.md","content":"泛型类 我们知道使用泛型可以使类型错误在编译时就被检测到，从而能够增加程序的健壮性。 定义泛型类 public class Generic&lt;T&gt; { private T key; public Generic(T key) { this.key = key; } public T getKey() { return key; } public void setKey(T key) { this.key = key; } } 实例化泛型类 Generic&lt;String&gt; genericString = new Generic&lt;&gt;(&quot;abc&quot;); Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123); System.out.println(genericString.getKey()); System.out.println(genericInteger.getKey()); 需要注意的是泛型的类型参数必须是引用类型（类、接口、数组等都是 引用类型）而不能是简单类型，如 Generic&lt;int&gt; generic = new Generic&lt;&gt;(123); 是不允许的。 当然和 List 等一样，实例化泛型类可以传入任意类型而并不一定非要传入泛型类实参，只不过既然我们将类定义为泛型类，其目的就是希望开发者们能够传入确定的类型实参，以增加程序健壮性： Generic generic = new Generic(&quot;abc&quot;); Generic generic2 = new Generic(123); Generic generic3 = new Generic(true); 泛型接口 定义泛型接口 public interface Generator&lt;T&gt; { public T fun(); } 实现泛型接口 public class PersonGenerator&lt;T&gt; implements Generator&lt;T&gt; { @Override public T fun() { return null; } } 可见当类实现泛型接口时若没有传入泛型实参，则需要将泛型也加到类的定义中，否则像下面的代码将会出现编译错误： public class PersonGenerator implements Generator&lt;T&gt; { @Override public T fun() { return null; } } 如果实现泛型接口时传入了泛型实参，则该类中所有使用泛型的地方都要替换成传入的泛型实参： public class PersonGenerator implements Generator&lt;String&gt; { @Override public String fun() { return null; } } 泛型方法 为了判断数组中是否包含某值写了如下两个重载方法： public static void main(String[] args) { Integer[] integers = new Integer[]{1, 2, 3}; String[] strings = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; System.out.println(contains(2, integers)); System.out.println(contains(&quot;b&quot;, strings)); } public static boolean contains(Integer integer, Integer[] integers) { return Arrays.asList(integers).contains(integer); } public static boolean contains(String s, String[] strings) { return Arrays.asList(strings).contains(s); } 但如果还想要判断 Float 类型的数组中是否包含某个值就有需要编写一个重载方法，好在我们可以通过泛型方法有效的避免这些冗余的方法： public static void main(String[] args) { Integer[] integers = new Integer[]{1, 2, 3}; String[] strings = new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}; Float[] floats = new Float[]{0.1f, 0.2f, 0.3f}; System.out.println(contains(2, integers)); System.out.println(contains(&quot;b&quot;, strings)); System.out.println(contains(0.2f, floats)); } public static &lt;T&gt; boolean contains(T t, T[] ts) { return Arrays.asList(ts).contains(t); } 需要注意的是方法返回值前需要包含形式参数，如 &lt;T&gt;， 否则该方法不能被称为泛型方法，编译也将出错。 值得一提的是，如果同时保留以下两个方法： public static &lt;T&gt; boolean contains(T t, T[] ts) { return Arrays.asList(ts).contains(t); } public static boolean contains(Integer integer, Integer[] integers) { return Arrays.asList(integers).contains(integer); } contains(&quot;b&quot;, strings) 会自动匹配泛型方法，而 contains(2, integers) 匹配的是普通方法而不是泛型方法。 泛型通配符 无限定通配符-Unbounded Wildcard 我们知道 Integer、Double、Float 等都是 Number 类的子类，所以下面的代码完全没问题： public static void main(String[] args) { printMsg(123); } public static void printMsg(Number number) { System.out.println(number); } 基本类型 123 被自动装箱成 Integer 类型，而 Integer 又是 Number 类的子类，所以可以作为 printMsg 方法的实参。 但泛型类 Generic&lt;Number&gt; 和 Generic&lt;Integer&gt; 可以认为是两个完全没有关联的新类型，两者之间不具有任何继承关系，所以下面的代码会出现编译错误： public static void main(String[] args) { Generic&lt;Number&gt; genericNumber = new Generic&lt;&gt;(123); Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123); printMsg(genericNumber); // 编译通过 printMsg(genericInteger); // 编译出错，因为 Generic&lt;Integer&gt; 和 Generic&lt;Number&gt; 二者之间没有任何继承关系 } public static void printMsg(Generic&lt;Number&gt; generic) { System.out.println(generic.getKey()); } 而如果就是希望 printMsg 方法既能接收 Generic&lt;Number&gt; 又能够接收 Generic&lt;Integer&gt;类型，甚至是能够接收传入了任意实参类型的 Generic 泛型类（如 Generic&lt;String&gt;、Generic&lt;Random&gt;等），则需要用到泛型通配符 ? 了： public static void main(String[] args) { Generic&lt;Number&gt; genericNumber = new Generic&lt;&gt;(123); Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123); printMsg(genericNumber); // 编译通过 printMsg(genericInteger); // 编译通过 } public static void printMsg(Generic&lt;?&gt; generic) { System.out.println(generic.getKey()); } 上限通配符-Upper Bounded Wildcard 为泛型添加上边界，即传入的类型实参必须是指定类型或指定类型的子类。使用 extends 指定上限通配符 public static void main(String[] args) { Generic&lt;Number&gt; genericNumber = new Generic&lt;&gt;(123); Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123); Generic&lt;Float&gt; genericFloat = new Generic&lt;&gt;(0.5f); Generic&lt;String&gt; genericString = new Generic&lt;&gt;(&quot;Hello&quot;); printMsg(genericNumber); // 编译通过 printMsg(genericInteger); // 编译通过 printMsg(genericFloat); // 编译通过 printMsg(genericString); // 编译出错 } public static void printMsg(Generic&lt;? extends Number&gt; generic) { System.out.println(generic.getKey()); } 因为 Generic&lt;? extends Number&gt; generic 指定了传入的类型实参必须是 Number 类或 Number 类的子类，所以printMsg(genericString); 出错，因为 String 不是 Number 的子类 下限通配符-Lower Bounded Wildcard 和上限通配符类似，下限通配符使用 super 关键字实现： public static void main(String[] args) { Generic&lt;Number&gt; genericNumber = new Generic&lt;&gt;(123); Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123); Generic&lt;Float&gt; genericFloat = new Generic&lt;&gt;(0.5f); Generic&lt;String&gt; genericString = new Generic&lt;&gt;(&quot;Hello&quot;); printMsg(genericNumber); // 编译通过 printMsg(genericInteger); // 编译通过 printMsg(genericFloat); // 编译出错 printMsg(genericString); // 编译出错 } public static void printMsg(Generic&lt;? super Integer&gt; generic) { System.out.println(generic.getKey()); } 因为 Generic&lt;? super Integer&gt; generic 指定了传入的类型实参必须是 Integer 类或 Integer 类的父类，所以 printMsg(genericFloat); 和 printMsg(genericString); 出现编译错误，因为 Float 和 String 都不是 Integer 类的父类 类型擦除-Type Erasure Java 的泛型只在编译阶段有效，编译过程中正确检验泛型结果后，会将泛型相关信息擦除，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法，即泛型信息不回进入运行时阶段： public static void main(String[] args) { Generic&lt;Integer&gt; genericInteger = new Generic&lt;&gt;(123); Generic&lt;String&gt; genericString= new Generic&lt;&gt;(&quot;Hello&quot;); System.out.println(genericInteger.getClass() == genericString.getClass()); // 返回 true } 结果返回 true ，说明虽然编译时 Generic&lt;Integer&gt; 和 Generic&lt;String&gt; 是不同的类型，但因为泛型的类型擦除，所以编译后 genericInteger 和 genericString 为相同的类型 命名规则 JDK 中文档经常能看到 T、K、V、E、N 等类型参数，而我们在编写泛型相关代码时，这些符号都可以随意使用，实际上还可以使用 JDK 文档中从来没用过的符号，如 A、B、C 等，但却极力不推荐这样做 JDK 文档中各符号的含义： T：类型 K：键 V：值 E：元素（如集合类中的元素全部用该符号表示） N：Number 我们应该遵循 JDK 中已有的规范 参考资料 java泛型详解 java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一 ","link":"http://blog.kuranado.com/post/java-fan-xing-zong-jie-md/"},{"title":"适配器模式.md","content":" 适配器模式又叫 Adapter 模式 什么是适配器模式 将一个类的接口转换成客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的类可以在一起工作 适配器模式中的角色： Target：目标接口。客户所期望的接口，可以是具体的类，也可以是抽象类或接口 Adaptee：需要适配的类 Adapter：适配器。通过包装一个需要适配的对象，把原接口转换成目标接口 栗子 网购一块键盘，收到货时却是这样的： ......，黑心店家竟然发了块 PS2 接口的键盘 可把我给气坏了！！！ 因为笔记本接口是这样的： 只有 USB 接口 黑心店家不给退货，没办法，翻箱倒柜，DIY 了一个 PS2 转 USB 的转换器： 最终如愿以偿的用上了新键盘 好了，就以这个场景为例，简单写下代码吧： Adaptee 拥有 PS2 接口的键盘是需要被适配的类 package com.kuranado.adaptor; /** * PS2 键盘（要被适配的对象） * @Author: Xinling Jing * @Date: 2018-12-23 13:28 */ public class PS2KeyboardAdaptee { public void specificRequest() { System.out.println(&quot;处理打字请求&quot;); } } Target 客户（也就是笔记本）所期望的 USB 接口 package com.kuranado.adaptor; /** * USB 接口（目标接口，客户所期望的接口） * @Author: Xinling Jing * @Date: 2018-12-23 13:33 */ public interface USBTarget { void handleRequest(); } Adapter PS2 和 USB 的转换器，通过组合的方式包装了被适配的对象，并调用被适配对象所具有的功能。 因为客户端只关心 USB 接口的使用，所以需要实现 USBTarget package com.kuranado.adaptor; /** * PS2 到 USB 转接口（适配器） * @Author: Xinling Jing * @Date: 2018-12-23 13:43 */ public class PS22USBAdapter implements USBTarget { private PS2KeyboardAdaptee adaptee; @Override public void handleRequest() { adaptee.specificRequest(); } public PS22USBAdapter(PS2KeyboardAdaptee adaptee) { this.adaptee = adaptee; } } Client 客户端调用 Target 接口 package com.kuranado.adaptor; /** * 电脑客户端类 * @Author: Xinling Jing * @Date: 2018-12-23 13:31 */ public class ComputerClient { public void test(USBTarget target) { target.handleRequest(); } public static void main(String[] args) { ComputerClient client = new ComputerClient(); PS2KeyboardAdaptee adaptee = new PS2KeyboardAdaptee(); USBTarget target = new PS22USBAdapter(adaptee); client.test(target); } } 程序运行效果： 处理打字请求 总结适配器模式各个角色的的关系如下图： 实际业务中的栗子 上面的例子比较简单，但真正业务中该如何应用适配器模式呢？此处把《研磨设计模式》中的例子拿过来与大家一起学习 1. LogModel：日志类，用于保存日志相关信息： /** * 日志类 * @Author: Xinling Jing * @Date: 2018-12-23 19:01 */ @Data public class LogModel implements Serializable { private static final long serialVersionUID = -2324527735778406382L; private String logId; /** * 日志内容 */ private String logContent; /** * 操作人 */ private String operateUser; /** * 操作时间 */ private String operateTime; public LogModel() { } public LogModel(String logId, String logContent, String operateUser, String operateTime) { this.logId = logId; this.logContent = logContent; this.operateUser = operateUser; this.operateTime = operateTime; } } 2. LogFileOperateApi：从文件中读取日志或向文件中写入日志的接口： /** * * @Author: Xinling Jing * @Date: 2018-12-23 19:08 */ public interface LogFileOperateApi { List&lt;LogModel&gt; readLogFile(); void writeLogFile(List&lt;LogModel&gt; logModels); } 3. LogFileOperateApi 接口的实现类： /** * * @Author: Xinling Jing * @Date: 2018-12-23 19:10 */ public class LogFileOperateApiImpl implements LogFileOperateApi { // 默认的日志路径 private String logFilePathName = &quot;/Users/jing/Code/GitHub/DesignPatterns/src/main/resources/AdaptorLog.log&quot;; public LogFileOperateApiImpl(String logFilePathName) { if (logFilePathName != null &amp;&amp; logFilePathName.trim().length() &gt; 0) { this.logFilePathName = logFilePathName; } } @Override @SuppressWarnings(&quot;unchecked&quot;) public List&lt;LogModel&gt; readLogFile() { File file; ObjectInputStream objectInputStream = null; List&lt;LogModel&gt; logModels = null; try { file = new File(logFilePathName); if (file.exists()) { InputStream inputStream = new FileInputStream(file); if (inputStream.available() != 0) { objectInputStream = new ObjectInputStream(new BufferedInputStream(new FileInputStream(file))); logModels = (List&lt;LogModel&gt;) objectInputStream.readObject(); } else { return null; } } } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } finally { if (objectInputStream != null) { try { objectInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } return logModels; } @Override public void writeLogFile(List&lt;LogModel&gt; logModels) { ObjectOutputStream objectOutputStream = null; File file; try { file = new File(logFilePathName); objectOutputStream = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(file))); objectOutputStream.writeObject(logModels); } catch (IOException e) { e.printStackTrace(); } finally { if (objectOutputStream != null) { try { objectOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 4. Client: /** * 客户端 * @Author: Xinling Jing * @Date: 2018-12-23 19:01 */ public class Client { public static void main(String[] args) { LogModel logModel = new LogModel(&quot;0001&quot;, &quot;这是第一条测试日志&quot;, &quot;JING&quot;, &quot;2018-08-03 09:44:35&quot;); List&lt;LogModel&gt; logModels = new ArrayList&lt;&gt;(); logModels.add(logModel); LogFileOperateApi logFileOperateApi = new LogFileOperateApiImpl(&quot;&quot;); logFileOperateApi.writeLogFile(logModels); List&lt;LogModel&gt; models = logFileOperateApi.readLogFile(); System.out.println(models); } } 客户端创建了一个日志对象，并将该日志对象写入了文件，然后从文件中读取出日志，并打印出来： [LogModel(logId=0001, logContent=这是第一条测试日志, operateUser=JING, operateTime=2018-08-03 09:44:35)] 这样程序正常运行着，可是突然有一天 leader 说为了方便日志管理，要求把日志存储到数据库中，于是你快速定义了将日志存取到数据库的接口： 5. LogDbOperateApi: /** * * @Author: Xinling Jing * @Date: 2018-12-23 19:15 */ public interface LogDbOperateApi { /** * 将日志保存到数据库 * @param logModel */ void createLog(LogModel logModel); /** * 更新数据库中的日志 * @param logModel */ void updateLog(LogModel logModel); /** * 删除数据库中的日志 * @param logModel */ void removeLog(LogModel logModel); /** * 获取数据库中的所有日志 * @return */ List&lt;LogModel&gt; getAllLog(); } 然后实现该接口： 6. LogDbOperateApiImpl： /** * @Author: Xinling Jing * @Date: 2018-12-23 19:48 */ public class LogDbOperateApiImpl implements LogDbOperateApi { @Override public void createLog(LogModel logModel) { System.out.println(&quot;成功插入日志:&quot; + logModel.toString() + &quot;到数据库中&quot;); } @Override public void updateLog(LogModel logModel) { System.out.println(&quot;成功更新数据库中日志:&quot; + logModel.toString()); } @Override public void removeLog(LogModel logModel) { System.out.println(&quot;成功删除数据库中日志:&quot; + logModel.toString() + &quot;到数据库中&quot;); } @Override public List&lt;LogModel&gt; getAllLog() { System.out.println(&quot;已找到数据库中的所有日志&quot;); return null; } } 7. Client: /** * 客户端 * @Author: Xinling Jing * @Date: 2018-12-23 19:01 */ public class Client { public static void main(String[] args) { LogModel logModel = new LogModel(&quot;0001&quot;, &quot;这是一条测试日志&quot;, &quot;JING&quot;, &quot;2018-08-03 09:44:35&quot;); LogDbOperateApi logDbOperateApi = new LogDbOperateApiImpl(); logDbOperateApi.createLog(logModel); } } 程序运行结果： 成功插入日志:LogModel(logId=0001, logContent=这是一条测试日志, operateUser=JING, operateTime=2018-08-03 09:44:35)到数据库中 到这里我们把 LogFileOperateApi 叫做第一版接口，LogDbOperateApi 叫做第二版接口 好啦，所有的工作都做完了，终于可以开开心心的去撩妹啦 刚和妹子约好晚上共度良宵，leader 却又找到了你，因为他觉得还 是 把 日 志 存 储 到 文 件 中 比 较 好！！！ 此刻内心想法：I have a line of MMP to tell you when the perfect timing comes to us. （╯' - ')╯︵ ┻━┻ 工作还得继续，硬着头皮想到了这么几个解决办法： 方法一：修改客户端调用，重新修改为调用第一版的接口 方法二：按照第二版的接口重新实现一个将日志存取到文件的实现类 方法三：不修改客户端调用，编写一个适配器，将第二版的接口适配到第一版的实现上，也就是使用适配器模式 这三个方法哪个更可取呢？ 方法一：现在所有的业务都使用第二版接口，要更改为第一版接口的话，即要更改整个项目所有地方，费时费力 方法二：已经完成的功能何必再重做一遍呢 方法三：复用已有代码，省时省力 8. Adapter /** * * @Author: Xinling Jing * @Date: 2018-12-23 19:59 */ public class Adapter implements LogDbOperateApi { private LogFileOperateApi adaptee; public Adapter(LogFileOperateApi adaptee) { this.adaptee = adaptee; } @Override public void createLog(LogModel logModel) { List&lt;LogModel&gt; logModels = adaptee.readLogFile(); logModels.add(logModel); adaptee.writeLogFile(logModels); } @Override public void updateLog(LogModel logModel) { List&lt;LogModel&gt; logModels = adaptee.readLogFile(); for (int i = 0; i &lt; logModels.size(); i ++) { if (logModels.get(i).getLogId().equals(logModel.getLogId())) { logModels.set(i, logModel); break; } } adaptee.writeLogFile(logModels); } @Override public void removeLog(LogModel logModel) { List&lt;LogModel&gt; logModels = adaptee.readLogFile(); logModels.remove(logModel); } @Override public List&lt;LogModel&gt; getAllLog() { return adaptee.readLogFile(); } } 9. Client 此时客户端只要做一点小修改即可： /** * 客户端 * @Author: Xinling Jing * @Date: 2018-12-23 19:01 */ public class Client { public static void main(String[] args) { LogModel logModel = new LogModel(&quot;0002&quot;, &quot;这是第二条测试日志&quot;, &quot;JING&quot;, &quot;2019-09-04 10:55:46&quot;); List&lt;LogModel&gt; logModels = new ArrayList&lt;&gt;(); logModels.add(logModel); LogFileOperateApi logFileOperateApi = new LogFileOperateApiImpl(&quot;&quot;); LogDbOperateApi target = new Adapter(logFileOperateApi); target.createLog(logModel); System.out.println(target.getAllLog()); } } [LogModel(logId=0001, logContent=这是第一条测试日志, operateUser=JING, operateTime=2018-08-03 09:44:35), LogModel(logId=0002, logContent=这是第二条测试日志, operateUser=JING, operateTime=2019-09-04 10:55:46)] 整体结构： 第二版接口对应适配器中的 Target，第一版的实现扮演适配器中的 Adaptee。整个适配器模式中最关键的就是 Adapter，它需要实现第二版的接口，但在内部实现的时候通过对象组合的方式调用第一版已经实现的功能。 好啦，这回终于可以结束工作，时间也还早，可以放心的去陪妹子逛街啦！ 工作中的应用场景 旧系统的改造和升级 系统维护 常见实现 Java IO java.io.InputStreamReader(InputStream)：通过适配器将字节流转换为我们需要的字符流 参考资料 【GOF23设计模式】 适配器模式 学长博客 《研磨设计模式》 ","link":"http://blog.kuranado.com/post/gua-pei-qi-mo-shi-md/"},{"title":"Java 多线程 - 内存可见性.md","content":"JMM JMM(Java Memory Model) 即 Java 内存模型，描述了 Java 程序中各种变量（线程共享变量）的访问规则，以及在 JVM中将变量存储到内存和从内存中读取出变量这样的底层细节，JMM 有如下几条规则： 所有的变量都存储在主内存中 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝） 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成 根据上图也可以发现：线程不能直接与主内存进行交互，工作内存负责与线程和主内存进行交互 共享变量 如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量 可见性 一个线程对共享变量值的修改，能够及时被其他线程看到则称这个共享变量在线程之间是可见的 重排序 代码书写的顺序与实际执行的顺序不同,指令重排序是编译器或处理器为了提高程序性能而做的优化 as-if-serial语义 无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致，Java 编译器、运行时和处理器都会保证 Java 在单线程下遵循 as-if-serial 语义，所以重排序不会给单线程带来内存可见性问题，但是在多线程中程序交错执行时，重排序可能会造成内存可见性问题 int num1 = 3; int num2 = 5; int sum = num1 + num2; 在单线程中，第 1 行和第 2 行代码可以进行重排序，但第 3 行代码不可以进行重排序，也就是说代码实际执行顺序可能是1 -&gt; 2 -&gt; 3 或 2 -&gt; 1 -&gt; 3，但绝不可能是3 -&gt; 1 -&gt; 2 或 3 -&gt; 2 -&gt; 1，因为这和代码顺序执行的结果不一致，不满足 as-if-serial 语义 实现共享变量可见性 要实现共享变量的可见性，必须保证两点： 线程修改后的共享变量值能够及时从该线程的工作内存刷新到主内存中 其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中 而 Java 保证共享变量可见性主要通过 synchronized 或 volatile 关键字实现： synchronized synchronized 能够实现： 原子性（同步） 内存可见性 JMM 关于 synchronized 的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存中 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时，需要从主内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁） 可见 synchronized 的这两条规定刚好满足要实现共享变量可见性所必须要保证的两点 synchronized 实现可见性过程如下： 获得互斥锁 清空工作内存 从主内存拷贝变量的最新副本到工作内存 执行代码 将更改后的共享变量的值刷新到主内存 释放互斥锁 下面上一段代码： public class Synchronpublic class SynchronizedDemo { // 共享变量 private boolean ready = false; private int result = 0; private int number = 1; // 写操作 public void write(){ ready = true; // 1.1 number = 2; // 1.2 } // 读操作 public void read(){ if(ready){ // 2.1 result = number * 3; // 2.2 } System.out.println(&quot;result的值为：&quot; + result); } // 内部线程类 private class ReadWriteThread extends Thread { // 根据构造方法中传入的flag参数，确定线程执行读操作还是写操作 private boolean flag; public ReadWriteThread(boolean flag){ this.flag = flag; } @Override public void run() { if(flag){ // 构造方法中传入true，执行写操作 write(); }else{ // 构造方法中传入false，执行读操作 read(); } } } public static void main(String[] args) { SynchronizedDemo synDemo = new SynchronizedDemo(); // 启动线程执行写操作 synDemo.new ReadWriteThread(true).start(); // 启动线程执行读操作 synDemo.new ReadWriteThread(false).start(); } } 执行这段代码输出结果可能为 6，可能为 0，也可能为 3，而不论哪种结果，都可能有多种执行顺序 result = 6 1.1-&gt;1.2-&gt;2.1-&gt;2.2 result = 6 1.1-&gt;2.1-&gt;1.2-&gt;2.2 result = 6 1.2-&gt;1.1-&gt;2.1-&gt;2.2 result = 3 1.1-&gt;2.1-&gt;2.2-&gt;1.2 result = 0 1.2-&gt;2.1-&gt;2.2-&gt;1.1 （1.1 和 1.2 进行了重排序，先执行了 1.2，然后写线程让出 CPU 资源执行读线程 ） result = 0 1.2-&gt;2.2-&gt;2.1-&gt;1.1 （1.1 和 1.2 进行了重排序，2.1 和 2.2 也进行了重排序） ... 注：代码 2.1 和代码 2.2 也可以进行重排序，因为在单线程中，2.1 和 2.2 无论谁先执行，都不会影响 result 的值 上面的例子简单说明了导致共享变量在线程中不可见的原因可能是线程的交叉执行或重排序，通过 synchronized 可以解决： 导致共享变量在线程间不可见的原因|synchronized解决方案 -| 线程的交叉执行（比如先执行 1.1 后执行 2.1）|原子性，synchronized保证了锁内部代码的原子性，避免了锁内部代码在线程之间交叉执行 重排序结合线程交叉执行|原子性 共享变量更新后的值没有在工作内存与主内存之间及时更新|可见性 synchroized 实现可见性代码： //写操作 public synchronized void write(){ ready = true; //1.1 number = 2; //1.2 } //读操作 public synchronized void read(){ if(ready){ //2.1 result = number * 3; //2.2 } System.out.println(&quot;result的值为：&quot; + result); } 这样程序的输出结果将总是 6 volatile volatile 关键字： 能够保证 volatile 变量的可见性 在 JDK 1.5 之后，volatile 变量能够禁止指令重排序 不能保证 volatile 变量复合操作的原子性 volatile 如何实现内存可见性： volatile 变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存，这样任何时刻，不同的线程总能看到该变量的最新值 线程写 volatile 变量的过程: 改变线程工作内存中 volatile 变量副本的值 将改变后的副本的值从工作内存刷新到主内存 线程读 volatile 变量的过程: 从主内存中读取 volatile 变量的最新值到线程的工作内存中 从工作内存中读取 volatile 变量的副本 上代码： public class VolatileDemo { private volatile int number = 0; private Lock lock = new ReentrantLock(); public void increase() { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } this.number++; } public int getNumber() { return this.number; } public static void main(String[] args) { VolatileDemo volatileDemo = new VolatileDemo(); for (int i = 0; i &lt; 500; i ++) { new Thread(new Runnable() { @Override public void run() { volatileDemo.increase(); } }).start(); } //如果还有子线程在运行，主线程就让出CPU资源， //直到所有子线程都运行完了，主线程再继续往下执行 while (Thread.activeCount() &gt; 2) { //在IDEA中设置大于2，在Eclipse中设置为大于1即可，因为IDEA除了主线程之外还会有一个监视线程在运行 Thread.yield(); } System.out.println(&quot;number:&quot; + volatileDemo.getNumber()); } } 这段代码的执行结果可能为 500，也可能小于 500，而问题就出在 number ++; 上，因为 number ++ 实际要分为如下 3 步执行： 读取 number 的值 将 number 的值加 1 写入最新的 number 值 而 volatile 虽然能够保证共享变量的内存可见性，但却不能保证复合操作的原子性，假设有两个线程 A 和 B，volatile int number = 5，线程 A 和 B 并发执行 number ++; 操作时就可能产生下面的执行顺序： 线程 A 从主内存读取 number 的值 线程 B 从主内存读取 number 的值 线程 B 执行加 1 操作 线程 B 向主内存写入最新的 number 值 线程 A 执行加 1 操作 线程 A 向主内存写入最新的 number 值 两个线程都执行了 number ++;，但主内存中共享变量 number 的值却是 6 而不是 7 解决办法有两种，一是通过 synchronized 加锁保证自增操作原子性，二是通过 ReentrantLock 对象加锁保证自增操作原子性 使用 synchronized 关键字保证 number 自增操作的原子性 public synchronized void increase() { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } this.number++; } 当然加锁的范围应该尽量更小一些： public void increase() { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (this) { this.number++; } } 使用 ReentrantLock 保证 number 自增操作的原子性 public void increase() { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } lock.lock(); // 加锁 try { this.number ++; } finally { lock.unlock(); // 释放锁 } } 使用上面两种方法的任意一种输出结果将总是 500 synchronized 和 volatile 比较： volatile 不需要加锁，比 synchronized 更轻量级，不会阻塞线 程，执行效率更高 synchronized 既能保证共享变量的可见性，又能保证共享变量的原子性，而 volatile只能保证共享变量的可见性，无法保证共享变量的原子性。 最后，我们知道 Java 中 long 和 double 都是64 位的数据类型，而 JMM 允许 JVM 将没有被 volatile 修饰的 64 位数据类型的读写操作划分为两次 32 位的读写操作来进行，这就可能会导致读取到“半个变量”的情况，为了预防这种情况，最好为 long 和 double 类型的变量加上 volatile 关键字 参考 细说Java多线程之内存可见性 ","link":"http://blog.kuranado.com/post/java-duo-xian-cheng-nei-cun-ke-jian-xing-md/"},{"title":"单例模式.md","content":"什么是单例模式 所谓单例模式即单例类只能有一个实例，并向外部提供一个访问该实例的全局访问点。 单例模式优点： 可以避免类的频繁创建与销毁 只创建一个实例，节省系统资源 饱汉式-单线程 饱汉式又称懒汉式（吃饱了可不就懒得动弹了嘛）： public class Test { public static void main(String[] args) { Singleton singleton = Singleton.getSingleton(); Singleton singleton2 = Singleton.getSingleton(); // 输出 true System.out.println(singleton == singleton2); } } class Singleton { private static Singleton singleton; private Singleton () {} public static Singleton getSingleton() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } 这就是最简单的单例模式，为了防止外部通过 new 创建多个 Singleton 类的对象，将构造方法设为 private；向外部提供 getSingleton 方法，通过 if 判断，即便外部多次调用该方法也只会创建一次实例；因为 new 关键字已被禁用，无法通过 new Singleton().getSingleton() 的形式创建实例，所以该方法为静态方法，可以直接通过 Singleton.getSingleton() 调用该方法创建实例；因为静态方法不能访问普通变量，所以 Singleton 变量也使用 static 修饰。 饱汉式-多线程 饱汉式-单线程的代码在单线程下的执行效率很高，同时也实现了懒加载（外部调用 getInstance() 方法时才创建 Singleton 类的实例），但缺点也很明显，那就是在多线程情况下，并不能保证只创建一次实例，如两个线程 A 和 B，A 执行完 if (singleton == null) 后，线程 B 获得处理器资源也执行到 if (singleton == null) ，这样线程 A 和 B 将都会创建一次实例。解决办法也很简单，使用 synchronized 修饰 getSingleton 方法即可： public static synchronized Singleton getSingleton() { if (singleton == null) { singleton = new Singleton(); } return singleton; } 这样即可保证多线程下也只会创建一次实例，但同样存在很大的缺陷：加锁会影响效率，实际应该在创建完第一个实例后就解锁，否则每个线程调用 getSingleton 时都要上锁阻塞其他线程，导致执行效率极低。 双重检验锁(Double Checked Locking) 双重检验锁是对饱汉式-多线程的优化，做到一旦创建完第一个实例后就不再加锁的效果： class Singleton { private volatile static Singleton singleton; private Singleton () {} public static Singleton getSingleton() { // 可能会有多个线程都进入了此 if if (singleton == null) { // 第一次检查 // 加锁 synchronized (Singleton.class) { // 第一个进入锁内的线程才会进入此 if if (singleton == null) { // 第二次检查 singleton = new Singleton(); } } } return singleton; } } 关键点在于 volatile 关键字的使用，此处为何要使用 volatile 关键字呢？ 问题在于 singleton = new Singleton(); 这行代码上，这行代码在底层可以粗略的分为以下几步执行： 栈内存开辟空间给 singleton 引用 堆内存开辟空间准备初始化对象 初始化对象 栈中引用指向这个堆内存空间地址 因为指令重排序的原因，这行代码的执行顺序可能是 1 -&gt; 2 -&gt; 3 -&gt; 4，也可能是 1 -&gt; 2 -&gt; 4 -&gt; 3。在某个时刻，确实可以保证只有一个线程进入同步代码块，如果进入同步代码块的线程刚好执行到 1 -&gt; 2 -&gt; 4，并没有执行到 3，但此时 singleton 已经非空，如果这时还有一个线程抢占资源调用 getInstance() 方法，则该线程执行到第一个 if 判断时，由于 singleton 非空，直接返回该 singleton，而实际上，该 singleton 所指向的堆内存空间地址并没有存放初始化后的对象，造成我们并没有拿到正确的对象实例。 volatile 刚好可以解决上述问题，我们知道 volatile 有 3 个特点： 能够保证 volatile 变量的可见性 在 JDK 1.5 之后，volatile 变量能够禁止指令重排序 不能保证 volatile 变量复合操作的原子性。 其中禁止指令重排序的特性正是我们所需要的。 饥汉式 饥汉式又称饿汉式，实现代码最为简单： class Singleton { private static Singleton singleton = new Singleton(); private Singleton () {} public static Singleton getSingleton() { return singleton; } } 饥汉式一上来就在类加载时创建好对象，由于 Java 的类加载机制避免了多线程的同步问题（类的加载方式是按需加载，且只加载一次，因为这个类在整个生命周期中只会被加载一次，所以只会创建一个实例），所以执行效率非常高。但饥汉式也存在如下两个缺点： 没有实现懒加载，即便根本没有人主动调用 getSingleton 方法，不管三七二十一，也会在类加载时就创建 Singleton 类实例。假设 Singleton 类实例的创建非常消耗系统资源的话，则会造成系统资源浪费。 像 Spring 等框架的设计中也都用到了单例模式，但这些框架常常需要通过参数进行配置，如果直接像饥汉式一样 private static Singleton singleton = new Singleton(); 将创建对象写死，将无法传入配置参数。 静态内部类 class Singleton { private Singleton() {} // 私有静态内部类，用到时才加载，所以时懒加载 private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getSingleton() { return SingletonHolder.INSTANCE; } } 静态内部类的加载不需要依附外部类，在使用到静态内部类时才加载，所以实现了懒加载。同时和饥汉式一样，类加载时就创建好对象，Java 的类加载机制也避免了多线程的同步问题，区别只在于这里是内部类 枚举 常有人说实现单例模式的最佳方法是使用枚举，这是因为枚举拥有以下特性，且代码实现简洁： 枚举类的构造器只能使用 private 修饰，若省略 private，则默认也是使用 private 修饰，如果省略构造器，默认也会提供一个 private 修饰的构造器，这和我们前面 5 种写法完全吻合 枚举类的每个实例系统都会自动为其添加 public static final 修饰，保证了枚举中的实例都只会被实例化一次 线程安全 public class Test { public static void main(String[] args) { Singleton singleton = Singleton.SINGLETON; Singleton singleton2 = Singleton.SINGLETON; // 输出 true System.out.println(singleton == singleton2); } } enum Singleton { SINGLETON } 遗憾的是枚举类加载时就开始加载枚举实例，所以并没有实现懒加载。 总结 各种写法特性总结如下： s 饱汉式-单线程 饱汉式-多线程 双重检验锁 饥汉式 静态内部类 枚举 支持多线程 ✘ ✔ ✔ ✔ ✔ ✔ 懒加载 ✔ ✔ ✔ ✘ ✔ ✘ 效率 高 低 高 高 高 高 综合来说我更倾向于使用双重检验锁方式，但每种写法各有其优缺点，在开发中应该根据需求选择，引用一段话： 既应当考虑到需求可能出现的扩展与变化，也应该避免无谓的提升设计、实现复杂度，最终反而会带来工期、性能和稳定性的损失，设计不足与设计过度都是危害，正所谓：没有最好的单例模式，只有最合适的单例模式。 参考资料 《Java 疯狂讲义》 菜鸟教程单例模式 如何正确地写出单例模式 Java并发：volatile内存可见性和指令重排 Java多线程之内存可见性 The &quot;Double-Checked Locking is Broken&quot; Declaration Java枚举enum以及应用：枚举实现单例模式 ","link":"http://blog.kuranado.com/post/dan-li-mo-shi-md/"},{"title":"毒鸡汤.md","content":" 做人如果没点追求，那么，该多轻松啊… 做一天的好人并不难，难的是做一辈子有钱人。 你每天都那么努力，忍受了那么多的寂寞和痛苦。可我也没见你有多优秀！ 今天的事不用放在今天做，万一明天死了呢，就可以不用做了。 其实只要不要脸，很多人生难题都能迎刃而解。 做人要谦虚，多听听他人的意见，然后认真记下他们的名字。 真正的吃货，是可以把月供看成月饼的。 总是在重复，尤其是错误！ 很多时候，乐观的态度和好听的话帮不了你。 狗是人类最好的朋友。 然而狗最好的朋友是「屎」。 最怕你一生碌碌无为，还安慰自己说平凡可贵。 当你觉得生活对你不公时，秤秤体重，照照镜子，你会觉得一切又合乎情理。 谁说我不会乐器？我退堂鼓打的可好了。 世界这么大，我想去看看，什么地方要饭比较方便！ 知道为何自古红颜多薄命吗？因为没人在意丑的人活多久。 别人问你有谈恋爱吗？就说现在没有。可以机智地掩盖过去也没有的事实。 做事一定要考虑别人的感受，千万不能让他们太开心了。 就算睡得晚，不会找你的人还是不会找你！ 纵然人生坎坷，但我从不向命运屈服！我通常都是直接屈膝Orz。 曾经我也是打算靠脸吃饭的，后来差点饿死才放弃的。 众里寻她千百度，蓦然回首，那人依旧对我不屑一顾。 做人要安安稳稳本本分分，因为，你也根本搞不出什么幺蛾子。 没有人能让那你放弃减肥，你自己想想就会放弃了。 做梦梦到自己在考试，然后被吓醒，发现自己真的在考试。 白天嘈杂得不愿意醒，夜晚安静得舍不得睡。 人生不如意，十之有十！ 做政治试卷，是我这辈子，说谎最多的时候。 转角一般不会遇到爱，只会遇到乞丐。 总结一下你的2018，留下你的不开心，让大家开心开心。 做好人没希望，做坏人不擅长。 如果十年之后你未娶，我未嫁，那真是太惨了！ 别看我平时对你漠不关心，其实私下里我每天都盼着你出事！ 只有努力过的人才知道，背景是多么重要！ 真正努力过的人，就会明白，天赋是有多么重要。 做了一个风险非常大的投资，要是成功一下就能挣几个亿，要失败我这两块就打水漂了。 总是在凌晨想通很多事情，又在天亮之后，忘得一干二净。 装逼只是瞬间，不要脸那才是永恒。 總以為退一步海闊天空，沒想到腳下落空。 你多努力一点，获得的打击就多一点。 做好万全的准备，就是为了当机会来临时，你可以巧妙地避开它。 生活不止眼前的苟且，还有读不懂的诗和到不了的远方。 再不疯狂就老了，疯狂过后发现老的更快。 作为失败的典型，你实在是太成功了。 诗和远方越远越脏 以梦为马越骑越傻！ 那些年立下的FLAG自己删了吧，反正也没人记得。 给你的梦想插上翅膀，虽然不一定飞得很远，但肯定摔的很重！ 世界上本没有鸡汤，鸡死了，便做成了鸡汤。 上帝为你关上一道防盗门，还会顺手给你上了一把钛合金锁。 做任何事情一定要坚持下去，总会让你看到，失败的那一天。 没有什么事情能把人一次击倒，只要足够坚强，它会持续的把你击倒！ 所有抱怨社会不公和制度的人翻译过来只有一句话：请给我金钱，女人和社会地位。 昨天一个小偷，来我家偷钱，我们一起找了一晚上。 谢谢你，在我每次需要你的时候都掉链子 厉害的不是你有多少后台，而是你能成为多少人的后台！ 最近改掉了熬夜的壞習慣，改通宵了。 只要努力的时间足够长，搞不好，你还可以失败的更彻底。 自由从来不是什么理所当然的东西，而是一项需要极高成本的特权。 这年头放个假真不容易，连放假都要沾老祖宗的光。 虽然我学得慢，但是我放弃的快啊！ 喜欢就去表白，不然你不会知道自己长得多丑。 只有努力过了才知道，智商上的差距是不可逾越的。 知道为什么天妒英才吗？ 因为没人去管笨蛋活了多久。 人人都想拯救世界，却没人帮妈妈洗碗。 做题前，先想想出题者的用意，我觉得他想我死。 最近一个月，总有那么三十天很不顺。 昨天遇见小学同班同学，没想到他混的这么差，只往我碗里放了一块钱。 不要以为世界抛弃了你，世界根本没空搭理你！ 如果所有人都理解你，那你得普通成什么样！ 终于中了500万，兑奖的时候，笑醒了。 先生，你这张卡上的钱也不够…… 赚钱就像便秘 — 老难了，花钱就像拉稀 — 憋不住。 打趴下就不要爬起来了，反正还是会被打到趴下！ 只要锄头挥得好，没有墙角挖不倒。 抱怨不会改变生活，但是钱可以！ 死并不可怕，怕的是再也不能活了。 只有努力过了才知道，智商上的差距，是不可逾越的。 只是因为在人群中，多看了你一眼，你就以为我要坐你的摩的。 一些年轻人，通过高端消费来营造自己高端收入的形象。 一个姑娘的介绍：思想上的女流氓，生活中的好姑娘。 然而给我的感觉是：心思活络的丑逼。 自古情深留不住，总是套路得人心。 只有在车站大排长龙时，才能真正意识到，自己是龙的传人。 只要功夫深铁杵磨成针，但真把铁杵磨成针的，绝对是大傻瓜。 只要是石头，到哪里都不会发光。 别总骂恨铁不成钢，是你自己忘了，铁本来就不能成钢的啊。 女人假装高潮来维持恋爱，而男人假装恋爱以获得高潮。 正月初五迎财神，那都是有钱人的事，你就洗洗睡吧。 知识给你力量，无知会给你更强大无畏，且无法预测的力量。 长的美与不美不重要，想的美才是真的美！ 只要有快递还在路上，就感觉这生活，还算有点希望。 只要能用钱解决的事情，我一件都解决不了。 只有多替领导背锅，领导才会把你，当成傻子啊。 只要坚持不懈，嘲笑你的人，迟早会被你笑死。 扎心？不存在的！心都没有扎哪里？ 注重细节，从小事做起，因为你根本做不了大事。 正在输入…，给了多少人希望，又给了多少人失望。 只要选对了人生的方向，很容易就成功了，让我们恭喜只要和很容易。 至少在夏天，富得流油你已经做到了一半。 长得好看的才叫吃货，长得不好看的那叫饭桶！ 只要你肯吃苦，肯努力，肯放下身段，去要饭，总会有人赶的 只要我肯努力，没什么事情是我搞不砸的。 这世上没谁离不开谁，就算是一条鱼离开水，也能烤着吃。 长的丑不是我的错，只是我在落地时太匆忙了，来不急打扮。 早睡早起身体好，可是晚睡晚起真的心情好。 这一秒不放弃，下一秒，就更绝望了。 挣钱是一种能力，花钱是一种技术，我能力有限技术却很高。 长的好看的才能叫吃货，长的不好看的只能叫饭桶。 真希望有一天我的钱包，可以和我的脸皮一样厚。 长得丑怎么了？我自己又看不到，恶心的是你们！ 真正努力过的人才知道，智商上的差距是不可逾越的。 只有在，请假扣工资时，才觉得自己工资高。 只要我吃的夠快，体重绝对追不上我！ 这么多年没掉入桃色陷阱，靠的就是两个字，没钱。 所谓成长，就是在听到波涛汹涌四个字，再也联想不到大海了。 余生不想请你指教了，领教够了 只要你每天坚持学习，最终胜利肯定是属于，在考场上发挥好的人。 早晨起来照镜子，安慰自己说没事，还有比我更丑的。 这辈子这么苦，别太拼，下辈子还会更苦的。 这次期末考，我会用实力告诉你，我们年级共有多少人。 这世上如果有什么真理，那就是活该！ 这辈子最灿烂的笑容，大概都奉献给，我的手机屏幕了。 遇到喜欢的女生要勇敢表白，只有你主动了，才知道她名花有主。 真正的勇士，敢于直面银行卡上的余额，敢于正视磅秤上的数字。 在你最需要帮助的时候，只有鬼才来帮你。 愚人节，只是给说谎的人，一个说真话的机会。 这孩子不是笨，就是学习方法不对。学习方法都找不对还不是笨啊？ 这年头有些人靠脸吃饭，而有些人，靠不要脸吃饭。 这年头，哪有不分手的恋爱，只有不伤手的立白。遇事得看开一点。 仗义每从屠狗辈，负心多是读书人。 再也沒有任何事情，比晚睡更快樂了，除了晚起。 攒了一年头皮屑，只为给你下场雪。 找对象还是眼光高点好，你总得为，没有人喜欢你找个借口吧。 这个年纪会在你耳边唱歌，喜欢你的肉体还会送你包的，只剩下蚊子了。 这两天雨水多，下雨记得打伞，否则脑袋容易进水。 ","link":"http://blog.kuranado.com/post/du-ji-tang-md/"},{"title":"Java 浅拷贝和深拷贝.md","content":"最普通的引用复制： import lombok.Data; /** * @Author: Xinling Jing * @Date: 2019-07-20 12:57 */ @Data public class Student { private int no; } /** * @Author: Xinling Jing * @Date: 2019-07-20 12:58 */ public class Test { public static void main(String[] args) { Student student = new Student(); student.setNo(1); // 复制对象引用 Student student2 = student; student2.setNo(2); System.out.println(student); System.out.println(student2); } } 输出结果如下： Student(no=2) Student(no=2) 更改一个 student 的 no 值，影响到了另一个 student 的 no 浅拷贝 被拷贝的类需要实现 Cloneable 接口，并重写 clone 方法： import lombok.Data; /** * @Author: Xinling Jing * @Date: 2019-07-20 12:57 */ @Data public class Student implements Cloneable { private int no; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } /** * @Author: Xinling Jing * @Date: 2019-07-20 12:58 */ public class Test { public static void main(String[] args) throws CloneNotSupportedException { Student student = new Student(); student.setNo(1); Student student2 = (Student) student.clone(); student2.setNo(2); System.out.println(student); System.out.println(student2); } } 输出结果： Student(no=1) Student(no=2) 更改一个 student 的 no 值，不会影响另一个 student 的 no 深拷贝 import lombok.Data; /** * @Author: Xinling Jing * @Date: 2019-07-20 12:57 */ @Data public class Student implements Cloneable { private int no; private Teacher teacher; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } import lombok.Data; /** * @Author: Xinling Jing * @Date: 2019-07-20 13:03 */ @Data public class Teacher { private String name; } /** * @Author: Xinling Jing * @Date: 2019-07-20 12:58 */ public class Test { public static void main(String[] args) throws CloneNotSupportedException { Student student = new Student(); Teacher teacher = new Teacher(); teacher.setName(&quot;汪老师&quot;); student.setNo(1); student.setTeacher(teacher); Student student2 = (Student) student.clone(); student2.setNo(2); student2.getTeacher().setName(&quot;井老师&quot;); System.out.println(student); System.out.println(student2); } } 输出结果： Student(no=1, teacher=Teacher(name=井老师)) Student(no=2, teacher=Teacher(name=井老师)) 两个 student 的 no 不同，但 teacher 却一起被改变了，说明 teacher 使用的是同一个引用。这是因为 Student 类下的 super.clone() 仅能拷贝 Student 类本身及其中包含的值类型的成员变量，并不能拷贝引用类型的成员对象 修改 Teacher 类如下： import lombok.Data; /** * @Author: Xinling Jing * @Date: 2019-07-20 13:03 */ @Data public class Teacher implements Cloneable { private String name; @Override protected Object clone() throws CloneNotSupportedException { return super.clone(); } } 修改 Student 类如下： import lombok.Data; /** * @Author: Xinling Jing * @Date: 2019-07-20 12:57 */ @Data public class Student implements Cloneable { private int no; private Teacher teacher; @Override protected Object clone() throws CloneNotSupportedException { Student student = (Student) super.clone(); student.setTeacher((Teacher) teacher.clone()); return student; } } /** * @Author: Xinling Jing * @Date: 2019-07-20 12:58 */ public class Test { public static void main(String[] args) throws CloneNotSupportedException { Student student = new Student(); Teacher teacher = new Teacher(); teacher.setName(&quot;汪老师&quot;); student.setNo(1); student.setTeacher(teacher); Student student2 = (Student) student.clone(); student2.setNo(2); student2.getTeacher().setName(&quot;井老师&quot;); System.out.println(student); System.out.println(student2); } } 输出结果： Student(no=1, teacher=Teacher(name=汪老师)) Student(no=2, teacher=Teacher(name=井老师)) 一个 student 的 teacher 改变并不会影响另一个 student 的 teacher ","link":"http://blog.kuranado.com/post/java-qian-kao-bei-he-shen-kao-bei-md/"},{"title":"土味情话.md","content":" 你的笑容没有酒，我却醉的像条狗 我想你的时候阳光空气都很好。 喜欢被宠，如果哪天我过得好好的突然不小心被人宠死的话，我也一点意见都没有。 我对你的爱，就像拖拉机上山，轰轰烈烈…… 我怀疑你的本质是一本书，不然为什么让我越看越想睡。 吃糖吗？我有你就已经很甜了。 你为什么要害我？害你什么？害我那么喜欢你。 动了情的小猪也会爬树喔 “我是可爱的女孩子。”“嗯？”“你是可爱啊。” 知道你跟我在一起叫什么吗？不知道啊，那你跟我在一起不就知道了 一直以来，我总是依赖于你的温柔。因为和你相遇，我的梦想才能够实现。所以这次轮到我帮你实现梦想了。 你的嘴真好看，特别适合说我爱你。 If you are still looking for that one person who will change you life ,take a look in the mirror. 你是方便面我是白开水 今生今世我泡定你了 我想要在茅亭里看雨、假山边看蚂蚁，看蝴蝶恋爱，看蜘蛛结网，看水，看船，看云，看瀑布，看你甜甜地睡觉。 你眼瞎吗？撞在我的心口上了。 你的口红我包了，但以后记得每天还我一点点。 坏男人渣一阵子，好男人渣一辈子 长话短说，爱我。 推荐一个0卡又很甜的零食，我的嘴巴 人说红颜薄命，你做我的红颜，我愿为你薄命。 我的酒量大概就是：八瓶香槟 七瓶伏特加 六瓶野格 五瓶威士忌 四瓶杰克丹尼 三瓶朗姆 两瓶生命之水 或者 你的一声：宝贝 你们那边家乡话的我喜欢你怎么说？ 满心向你，却只字不提 ，你知道就知道 ，不知道也就算了，口里的爱不及心里的千分之一。 你知道我喜欢吃什么吗？痴痴地望着你 见什么世面，见见你就好了。 那些说星星好看的人一定没有看过你的眼睛 我很能干但有一件事不会。什么?不会离开你。 秋天该很好，你若尚在场，秋风即使带凉，亦漂亮。 虽然你没有我前女友漂亮 但我一见到你就有种想跟你定下来的感觉 最近都忙着学雷锋呢，你也做个好事帮我洗个东西吧，洗欢我 “我觉得你这个人不适合谈恋爱” “为什么?” “适合结婚。” 你是我最想和全世界炫耀却又最舍不得和别人分享的人 你这种人！我除了恋爱没什么和你好谈的 &quot;你猜我爱喝酒还是爱打王者&quot; &quot;爱打王者吧?&quot; &quot;不，爱你&quot; 这一辈子，还有没有可能，会有一个人，因为一句你想他，不远万里，不为别的，只为看看你。 请问去往你心里的路该怎么走 遇到你之前，我没有想过要结婚；遇到你之后，结婚没想过要和别人。 我不担心时光流逝，只因我坚信有你的日子将会越来越幸福，只到未来的某一天你我携手离开人世，我们的幸福将会达到巅峰。 傻逼在泰语里可是老公的意思哦 不要让别人喊我喊逗比，那是只属于你的专属。 不须耳鬓常厮伴，一笑低头意已倾 你猜我的心在哪边？左边？错了，在你那边。 我的愿望，就是希望你的愿望里，也有我。 谁会喜欢一米七的萌妹啊，还不是因为你是咖啡和奶茶的混合体。 你有打火机吗？没有啊，那你是怎么点燃我的心的？ 我从不后悔一直喜欢你，那些孤独枯燥的时光岁月，因为你而变得温柔。 “520，我爱你”，“不对，是我爱您”，“要这么庄严的吗”，“不是庄严，是像爱祖国一样爱你，绵长悠久，休戚相关”。 和你在一起，我变得随心所欲，不再战战兢兢，担心忧虑。 情不知所起，一往而深。 你的脸上有点东西，有什么？有点漂亮。 猪撞树上了，你撞我心里了。 有人说，如果你在冬天遇到喜欢的人，他可以把你的冬天变成春天。 我生在南方，活在南方，栽在你手里，总算是去过不一样的地方。 猜猜我的心在哪边?左边。错了，在你那边 你像一个人 ，我的人 你是我自罚三杯，都不肯开口的秘密； 我们来玩木头人不许动吧！好！我输了！为什么？因为我心动了 这是西服，这是迷彩服，你是我的小幸福。 三十晚上的鞭炮再响，都没有我想想你那么想。 你的脸上有点东西，有什么? 有点漂亮 “孔子、孟子、老子，你知道你最适合当什么子吗？”“不知道。”“我的妻子。” 你喜欢喝水吗？那你已经喜欢上70%的我了。 被你赞过的朋友圈，叫甜甜圈。 我手上划了一道口子你也划一条吧 这样咱俩就是两口子了 你闻到空气中有烧焦的味道吗？那是我的心在为你燃烧 终会有人把你捧在心尖上，喜欢你喜欢的像个傻子，终会有人保护好你的少女心，让你再次相信爱情。 妙语连珠是猎物，支支吾吾是喜欢。 我好香，你要不要抱一下 我觉得你特像一款游戏，我的世界。 你喜欢大海，我爱过你。 想给自己颁一个最佳进步奖，毕竟我每天都爱你比昨天多一点。 有生之年 狭路相逢 终不能幸免 人的一生会遇到许许多多的人，很幸运我遇到了你。 你今天特别讨厌，讨人喜欢和百看不厌。 想说些漂亮的话哄你，但想来想去最漂亮的只有你。 如果你不怕麻烦的话，可以麻烦喜欢我一下吗？ 我见过的最美的春天，是你穿过人群找到我的那个四月。 你忙归忙，什么时候有空娶我啊。 要不要来谈个恋爱啊，二缺一 你知道我最喜欢什么酒吗？和你的天长地久 讲真的你未对我半分好，偏巧这感情疯长似野草。 小猪佩奇，我配你。 你来时冬至，但眉上风止 我最近没有偷偷减肥哦，但是体重却下降了，因为我的心跑你那去了 刚刚地震了吗？没有啊，那为什么看到你，我心头一震。 每次你发朋友圈 我就又到了换手机桌面的时候。 “你能不能闭嘴?” “我没有说话啊” “那为什么我满脑子都是你的声音?” 我以前喜欢吃肉，但今天看到你我决定开始吃素，因为，你是我的菜。 我爱你就是这样的不讲道理 房产证写你名字，我妈会游泳，难产保大，余生多指教。 你这么完美，就是有一个缺点：什么缺点？缺点我 你是我临死前，拔掉氧气罐，想吻的人； 爱人，一定要适合的，因为那是一辈子相互扶持的柴米油盐。 我给你的备注是“一行”，因为干一行爱一行。 用铁做的门叫铁门，用木做的门叫木门，用幸福做的门叫什么门？叫我们 原谅我太贪心，陪了你情窦初开，还想陪你两鬓斑白。 生命那么短，世界那么乱，我不想争吵，不想冷战，不愿和你有一秒遗憾。 幸福是什么，幸福就是牵着一双想牵的手，一起走过繁华喧嚣，一起守候寂寞孤独；就是陪着一个想陪的人，高兴时一起笑，伤悲时一起哭；就是拥有一颗想拥有的心，重复无聊的日子不乏味，做着相同的事情不枯燥，只要我们心中有爱，我们就会幸福，幸福就在当初的承诺中，就在今后的梦想里。 不好意思，刚我对其他人动了心，因为她，很像你 你是我故事里的一往情深。 选择了你，就要坚持到死 你像夏至的分界线，是我一生里最长的那个白天。 “你会看手相吗?”“会一点，你命里缺我” 三十晚上的鞭炮再响，都没有我想你那么想。 这是弓箭，这是火箭，你是我的甜蜜饯。 你有没有看见过某个笑容，让你想倾尽所有去守护。 我的手被划了一道口子，你也划一道，这样我们就是两口子了。 你知道我的缺点是什么吗? 是缺点你。 你知不知道为什么我怕你？”“不知道”“因为我怕老婆 天空飘来五个字，爱你不是事儿。 我想以后可以先吻吻你迷迷糊糊不清醒的眼睛，再摁下闹钟的关闭按钮 我可以不为别人难过，但你不是别人，你是我的人。 你不知道在遇见你之前，我的世界天天都有雾霾，遇到你以后，他变得晴空万里 让我陪你去看匆匆人海，听平凡一生 我觉得你有点怪，怪可爱的。 这是我的手背，这是我的脚背，你是我的宝贝。 思念如白马，自别离，未停蹄 想你这件事，躲得过对酒当歌的夜，躲不过四下无人的街。 这世间的长情莫过于你和我挽手余生 土豆和洋芋，番茄和西红柿，我喜欢的人和你 我们来玩木头人不许动吧，好! 我输了，心动了。 最近体重上升了，绝对没有偷吃，只是把你偷偷放在了心里。 姑娘我想我们合二为一，尽情享受人间仙境 你可以笑一个吗？为什么呀？因为我的咖啡忘记加糖了。 从今以后我只能称呼你为您了，因为，你在我心上。 你知道你和猴子什么区别吗” “一个住在山洞，一个住在我心里” 晓看天色暮看云，行也思君，坐也思君 你猜我喜欢什么制服，被你制服。 我想问一条路 到你心里的路 要不要来谈恋爱啊，二缺一。 最近体重偷偷上升，绝对没有偷吃哦，只是偷偷把你放在了心上。 前天是小鹿，昨天是小兔，今天是你 我想去取一下东西，你等一下，我来娶你了。 你是我跑完五千米，还想拥抱的人； 做什么都十拿九稳，就差你一吻 你以后走路能不能看着点啊，都撞在我心上了。 既然你已经把我的心弄乱了，那么你准备什么时候来弄乱我的床 “三十岁是个坎？意思是过了30一切就好起来了是吧？”“意思是过了30岁，生活就结束前戏，开始狠狠操你了。” 我曾踏月而来，只因你在山中。 你知道你和星星有什么区别吗? 星星在天上，你在我心里。 东风夜放花千树，我想去你家里住 是福不是祸，是你老婆躲不过。 你猜我喜欢什么制服” “被你制服” 别让我看见你，不然我见你一次，就喜欢你一次。 在所有的道别里，还是最喜欢明天见。 做你自己，我来爱你。 我对你的喜欢就像手扶拖拉机上山，轰轰烈烈。 你就像破晓的那一束光，驱散了笼罩我的黑夜，至此，光芒万丈 我不想做你的盖世英雄，只想每天晚上帮你盖好被子。 你是属什么的？我属龙的，不，你是属于我的。 我发现昨天很喜欢你，今天也很喜欢你，而且有预感每天也会很喜欢你。 关于想你这件事，躲得过对酒当歌的夜，躲不过四下无人的街。 现在几点了？是我们幸福的起点。 天蓝蓝的云白白的都很可爱，就像捧着草莓味的冰淇淋圣代，吧唧吧唧吃着的我。 没有树的地方是沙漠，没有你的地方是寂寞。 你累不累啊？不累，可你都在我心里跑了一天了 我想你一定很忙，所以你只看前三个字就好 莫文蔚的阴天，孙燕姿的雨天，周杰伦的晴天，都不如你和我聊天。 倘若不是日有所思，哪里来的夜长梦多啊。 苦海无涯，回… 回头是我呀。 你是我不及的梦。 “我结婚你一定要来”“为什么？”“因为没有新娘会很尴尬。” 我可以许一个贪心的愿望吗?神明实现不了，只有你可以。 这是手心，这是笔芯，你是我的小甜心。 我想去个地方什么地方？去你心里！ 惊鸿只一瞥，爱到死方休。 我有个九个亿的项目想跟你单独谈谈。 你能不能别说话了。”“我没有啊。”“那为什么我满脑子都是你的声音 秋天来了，你出现了，我心动了 “你最近是不是又胖了?” “没有啊，为什么这么说?” “那为什么在我心里的分量越来越重了?” 生活很苦，眼泪很咸；生活很苦，但你很甜 入目无别人 四下皆是你 下次见面敲你一下，为什么？因为你，敲好看。 你给我的备注是什么啊？” “一行。” “为什么啊？” “因为干一行，爱一行 我想在你这里买一块地。什么地？我对你的死心塌地。 为你的千千万万遍 “你今天早上是不是很累？”“你怎么知道？”“因为你昨天晚上一直在我心里跑来跑去啊。” 想多亲亲我身边的风，说不定哪天它就吹到你脸上了。 我发现昨天很喜欢你，今天也很喜欢你，而且有预感明天也会喜欢你。 “你为什么要害我?” “害你什么?” “害我那么喜欢你!” 你猜我什么星座” “白羊?” “错，我是为你量身定做” （嗅嗅）你一来空气都变甜了呢 你近视吗? (不近视啊)那你怎么看不出我喜欢你。 孤烟无垠万里沙，幸能与你踏。 你闻到什么味道了吗？没有啊，怎么你一出来空气都是甜的了。 前世的五百次回眸换得今生的一次擦肩而过，我用一千次回眸换得今生在你面前的驻足停留。 遇见你的时候上帝在我耳边说了四个字 “在劫难逃”。 做饭做家务怕老婆，爱你的三大特征我都有 这是果冻，这是树洞，你是我的心动。 你眼瞎吗? 撞我心口上了 我发觉你今天有点怪，怪好看的。 从遇见你的那一天起，我所走的每一步都是为了更接近你。 我不是loli控，只是刚好喜欢的女孩子是loli而已 我愿将我余生燃烧，暖你未来的路。 你辛苦归辛苦，什么时候有空嫁给我。 Good night without you is just a night. 所爱隔山海，山海皆可平。 你有遇到让你哭笑不得的 事吗？哭也得不到你，笑也得不到你。 我们之间没有惊天动地的虐恋情深，但我有一颗真心，满满的全是你。 我还是爱你，就像风走了八万里，不问归期。 本是青灯不归客，却因浊酒流风尘 你是我的玫瑰你是我的花，小鸟的情话只给您夸。 莺莺燕燕，不过浮生一梦。遗世独立，不如烂醉花间。 我身体很好，可以扛米袋子，扛煤气罐，可就是扛不住想你。 你不觉得累吗？你已经在我的世界里跑了好几圈了 我愿意舍弃一切，以想念你终此一生。 我想要去看一看你下辈子的命簿，看你下辈子娶到哪家，我便投胎到那家。 “你知道我为什么感冒了吗?” “因为着凉了?” “不，因为我对你完全没有抵抗力。” 我的床不大不小，用来睡你刚刚好。 有的人说不清哪里好，但就是谁都替代不了。 你有没有闻到什么烧焦的味道？那是我的心在燃烧。 你现在不珍惜我，我告诉你，过了这个村，我在下个村等你。 刚刚地震了吗？没有啊，那为什么看到你，我心头一震。 会当凌绝顶，一… 一把搂住你。 最近有谣言说我喜欢你，我要澄清一下，那不是谣言，那是事实 想成为你这辈子，不管过了多少年，遇见了多少人，以后回想起来还会觉得妙不可言的人。 你知道五氧化二磷被氧化前是什么样子嘛，什么样子？五二磷。 面对你，我不仅善解人意，我还善解人衣。 前半生到处浪荡，后半生为你煲汤。 而对一个人纠结，就是喜欢一个人的开始。 我只愿凭这灵感的相通，带给彼此以慰藉，像流星的光辉，照耀我疲惫的梦寐，永远存一个安慰，纵然在别离时。 我玩了六年英雄联盟，后来才发现你才是我的英雄。 你是往日的情书，是日落的余情未了，是路人脚下不停生长的风，也是我喜欢的人。 “你知道世界上最冷的地方是哪吗?” “是没有你的地方”。 你是高处折不到的桃花，是跨不上的英俊白马。 我想买一块地。”“什么地”“你的死心塌地。” 现在几点了？12点，不，是我们幸福的起点。 宁不知倾城与倾国，佳人难再得 我也想遇见一个人，为他花开满城，为他明灯三千。 这一世，你是冰冷的永磁体，而我是你沟通世界的两极，纵你已粉身碎骨，我亦不离不弃…… “你知道这牛肉要怎么吃才好吃吗？我喂你吃。” 剑未佩妥，出门已是江湖；酒尚余温，入口不识乾坤；千帆过尽，愿您归来仍是少年。 为什么我的眼中常含泪水，因为我爱你爱的深沉 今天的天空是淡山茱萸粉的颜色，就像初次见你时，你的笑是我不曾见过的世外桃源 他们说这个世界上海最深邃，干净又透明，我想那是他们没见过你的眼睛。 你是我赴汤蹈火，都放不下的执着 我不喜欢喝酒，除了和你的天长地久 你这种人，我除了恋爱跟你也没什么好谈的。 我感觉你最近胖了，难怪你在我心中的分量变重了。 你猜我想吃什么?” “不知道啊。” “痴痴地望着你。” 无聊的时候多想想我，不要浪费时间，知道吗？ 你会弹吉他吗？为什么拨动了我的心弦 有些事情在遇见你的时候就决定了，比如：我喜欢你~ 哪有什么突然想起，只是一直放在心里。 愿你一生被爱 一生可爱 三月拾花酿春 六月流萤染夏 十月稻陌拾秋 腊月丛中吻雪 一年四季 四季最好都赠你 把手伸出来，这是我心房的钥匙，拿好 你知道相得益彰吗？就像你的美貌、气质和性格。 我看过很多书，但都没有你好看。 疏窗细雨，夜夜孤灯。 这辈子跟我在一起吧，不行我就等等，再不行的话，我就想想别的办法。 做腻了可爱的女孩子，我有点想做你的太太。 我看你挺笨的吹口哨都不会，要不要我嘴对嘴教你。 我的酒量大概就是一打啤酒或者半斤白酒，再或者你的四两微笑。 这是车票，这是发票，你是我最最最可爱的女票。 你知道我为什么会感冒吗？因为见到你就没有抵抗力呀，我爱你。 你是夏季限定，也是来日方长，也是秋季爆款，也只是一时之需 星光不问赶路人，岁月不负有心人 你知道你像什么人吗？什么人？我的女人。 你知道你和星星有什么区别吗？那就是星星在天上，而你在我心里 我听过最暖心的一句情话是：“你不用刻意去改变自己，我来适应你就好了。” 我可以称呼你为您吗？这样我就可以把你放在心上了 我很喜欢现在的我，和你一别两宽后的我。 寄给你全宇宙的爱和自太古至永劫的思念。 大年三十晚上的鞭炮再响，也没有我想你那么想 你是年少的欢喜，喜欢的少年是你 你可以帮我个忙么？什么忙？帮忙快点爱上我。 你今天能不能不洗澡，为什么？因为最近流行吃脏脏包。 你可以帮我个忙么? 什么忙? 帮忙快点爱上我! 我好像感冒了诶，怎么办，对你一点抵抗力都没有。 我寻了半生的春天，你一笑便是了。 猜猜我的心在哪边？左边错了，在你那边。 知道我和唐僧什么区别吗 唐僧取经我娶你 不要抱怨，抱我。 我还是喜欢你，像小时候吃辣条，不看日期。 你是不是喜欢我” 找到这句话的重复字 你来我信你不会走，你走我当你没来过——《失恋33天》 喜欢，就是知道对方最好的一面而喜欢他；爱，就是明知对方最差的一面，却仍然爱得义无反顾。 亲爱的，容我轻轻咬耳，遇见你便寻到了春天！ 你知道我喜欢喝什么吗？ 呵护你 如果一千个人从我身边走过，我也可以听出你的脚步声，因为九百九十九个人都只是踩在地上，只有你踏在我心上。 你是可爱的男孩，我是可爱。 跟我在一起吧，行就行，不行我就再想办法。 这是我的手背，这是我的脚背，你是我的宝贝 ","link":"http://blog.kuranado.com/post/tu-wei-qing-hua-md/"},{"title":"CSS 基础总结.md","content":"[TOC] CSS 引入方式 内部样式表（嵌入式），&lt;style&gt;&lt;/style&gt; 标签放在 &lt;head&gt;&lt;/head&gt; 标签内，练习、测试时使用 行内样式表，直接在标签内部使用 style 属性定义样式，使用很少 外部样式表，使用最多，&lt;head&gt;&lt;/head&gt; 标签内 &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/style.css&quot;/&gt; 优先级：内部样式表 &gt; 行内样式表 &gt; 外部样式表 属性 宽/高 width 宽度 height 高度 color 文本颜色 background-color 背景颜色 字体 font-family 字体，如宋体、Microsoft YaHei、Arial、sans-serif、Times New Roman 等，尽量使用系统自带字体，字体相关属性通常用在 body 标签上，可同时设置多个字体，以逗号分隔，浏览器优先使用前面的字体，当字体不存在时，再依次尝试后面的字体 body { font-family: 'Times New Roman', 'Microsoft YaHei'; } font-size 字体大小，一定要记得加上单位，如 px body { font-family: 'Times New Roman', 'Microsoft YaHei'; font-size: 16px; } /** 虽然 body 标签已设置了字体大小，但标题标签比较特殊，需要单独再次设置字体大小 h1: { font-size: 16px; } font-weigth 字体粗细，实际开发中更喜欢用数字而不是用单词 normal 不加粗（默认值，400） bold 加粗（700） p { font-weigth: 700; } /** 或 **/ p { font-weigth: bold; } font-style 字体样式 normal 不倾斜（默认值） italic 倾斜 font 字体复合属性，格式：font: font-style font-weigth font-size/line-height font-family /** 注意不可更改属性顺序，且 font-style 和 font-weigth 属性可以省略，font-size/line-height 和 font-family 属性不可省略 **/ p { font: italic 700 16px/26px 'Times New Roman', 'Microsoft YaHei'; } 文本 text-align 文本对齐， left 左对齐（默认值） right 右对齐 center 居中对齐 h1 { /** 让 h1 盒子里的文本居中对齐 **/ text-align: center; } p { text-align: center; } &lt;h1&gt;Hello&lt;/h1&gt; /** 图片也相当于是普通文字，要想图片在其父元素中居中对齐，需要为其父元素设置 text-align: center; 而不是为 img 标签设置该属性 &lt;p&gt; &lt;img src=&quot;./images/1.jpg&quot;/&gt; &lt;/p&gt; text-decoration 文本装饰 none 没有装饰线（默认值，最常用） underline 下划线（常用） overline 上划线（几乎不用） line-throne 删除线（不常用） text-indent 文本的第一行缩进多少距离 /** 如果字体大小设置为 16px，按照中国人的传统，段落首行缩进 2 个文字，则写法如下：**/ p { text-indet: 32px; } /** 或者直接写成 2em（推荐写法，em 是相对单位，相对当前标签 font-size 1 个文字的大小，如果当前标签没有设置 font-size，则相对父元素的 1 个文字大小） **/ p { text-index: 2em; } vertical-align 用于设置一个元素的垂直对齐方式，但它只针对于行内元素或行内块元素有效。图片、表单都是行内块元素，默认的 vertical-align 为基线对齐 baseline 默认，元素放置在父亲的基线上 top 把元素的顶端与行中最高元素的顶端对齐 middle 常用，把此元素放置在父元素的中部 bottom 把元素的顶端与行中最低的元素的底端对齐 图片底部会有空白缝隙，原因是因为 img 是行内块元素，而行内块元素会和文字的基线对齐，为了去除该空白，可使用如下两种方法： 给图片添加 vertical-align: middle|top|bottom;，即只要不是 baselien 就可以（推荐方法） 把图片转换为行块级元素 display: block; 行高 line-height 行高（行间距），控制行与行之间的距离 ![](http://image.kuranado.com/blog/1601107997.png?imageMogr2/thumbnail/!70p 行高由 3 部分组成：文本高度和上、下间距，由于文本高度有字体大小决定，所以当增加或减小行高时，实际文本高度不会变化，变化的只是上、下间距 /** 字体大小 16px，行高 26 px，所以上边距和下边距各位 5px **/ p { font: italic 700 16px/26px 'Times New Roman', 'Microsoft YaHei'; text-indent: 2em; line-height: 26px; } 背景 background-color 背景色，默认值为 transparent，表示透明的 background-image 背景图片（如果既设置了背景颜色，又设置了背景图片，则背景颜色显示在下方，背景图片显示在上方） none 没有图片，默认值 url 指定图片地址 background-repeat 背景图片平铺方式 repeat 默认值，水平方向和垂直方向上平铺 no-repeat 不平铺 repeat-x 水平方向上平铺 repeat-y 垂直方向上平铺 background-position 设置图片在背景中的位置，取值可以为方位名词，也可以为坐标，也可以方位名词和坐标混用 方位名词 top bottom left right center 单词顺序没有影响，如：background-position: center right; 和 background-position: right center; 没有任何区别 如果只指定一个方位名词，另一个方位名词省略，则另一个方位名词默认为 center，如 background-position: center; 等价于 background-position: center center; 坐标 x y 如：background-position: 20px 50px;；第一个参数为 x 表示距离盒子左边的距离，第二个参数为 y 表示距离盒子右边的距离 如果只指定一个坐标，则这个坐标一定是 x，此时 y 默认为 center。如 background-position: 20px; 等价于 background-position: 20px center; background-attachment 背景固定 scroll 默认值，背景图像随内容滚动 fixed 背景图像固定 background 背景属性复合写法，没有特定书写顺序，一般习惯约定顺序为：background: 背景颜色 背景图片地址 背景平铺方式 背景固定方式 背景图片位置，如： body { background-image: url(&quot;./images/bg.jpg&quot;); background-position: top center; background-repeat: no-repeat; background-attachment: fixed; background-color: gray; } p{Hello}*100Tab 等价于： body { background: gray url(&quot;./images/bg.jpg&quot;) no-repeat fixed top center; } p{Hello}*100Tab background rgba CSS3 新增属性，可以设置盒子背景色半透明，盒子里面的内容不受影响，如 background: rgba(0, 0, 0, 0.3) 最后一个参数为 alpha 透明度，取值范围 0 ~ 1，习惯上会把 0.3 简写为 .3 list-style: none 去除 li 的符号 border-radius 定义圆角边框（CSS3 新增），单位可以是像素，也可以是百分比 像素，如让一个正方形变成圆形，只要让 border-radius 等于宽度的一半即可： .circle { width: 200px; height: 200px; background-color: skyblue; border-radius: 100px; } &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; 百分比，同样让一个正方形变成圆形，只要让 border-radius 等于宽度的一半，也就是 50%： .circle { width: 200px; height: 200px; background-color: skyblue; border-radius: 50%; } &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; 如果要把矩形变成圆角矩形，只要把 border-radius 设置为矩形高度的一半就可以了 跟一个值，表示 4 个边框的圆角大小 跟两个值，第一个值表示左上角和右下角边框的圆角大小，第二个值表示右上角和左下角的圆角大小 跟四个值，分别表示左上角、右上角、右下角、左下角的圆角大小 border-top-left-radius 设置左上角圆角大小，注意 top 和 left 顺序不能颠倒 border-top-right-radius 设置右上角圆角大小，注意 top 和 right 顺序不能颠倒 border-bottom-right-radius 设置右下角圆角大小，注意 bottom 和 right 顺序不能颠倒 border-bottom-left-radius 设置左下角圆角大小，注意 bottom 和 left 顺序不能颠倒 box-shadow 盒子阴影，格式：box-shadow: h-shadow v-shadow blur spread color inset; h-shadow 水平方向阴影 v-shadow 垂直方向阴影 blur 表示模糊程度 spread 表示阴影尺寸 color 一般使用 rgba，以便设置阴影的透明度 inset 默认为外部阴影，inset 表示内部阴影，一般不会设置为 inset 盒子阴影是不占用盒子空间的，不会影响其它盒子排列 div { width: 200px; height: 200px; background-color: skyblue; margin: 100px auto; } div:hover { box-shadow: 10px 10px 10px 5px rgba(0, 0, 0, .2); } &lt;div&gt;&lt;/div&gt; text-shadow 文字阴影（不常用），格式：text-shadow: h-shadow v-shadow blur color; 显示/隐藏 display 常用 none 隐藏元素，隐藏后，不再占有原来的位置 block 除了转换为块级元素外，还有显示元素的意思 visibility hidden 隐藏元素，隐藏后，元素继续占有原来的位置 block 显示元素 overflow 对溢出的部分设置显示或隐藏（如果是有定位的盒子，需慎用 overflow:hidden） visible 默认值，不剪切内容，也不添加滚动条 div { /* 默认值，等于不设置 */ overflow: visible; width: 400px; height: 100px; background-color: skyblue; } &lt;div&gt;《小猪佩奇》，又名《粉红猪小妹》（台湾名为粉红猪），英文名为《Peppa Pig》，是由英国人阿斯特利（Astley）、贝克（Baker）、戴维斯（Davis）创作、导演和制作的一部英国学前电视动画片，也是历年来最具潜力的学前儿童品牌。故事围绕小猪佩奇与家人的愉快经历，幽默而有趣，藉此宣扬传统家庭观念与友情，鼓励小朋友们体验生活。&lt;/div&gt; hidden 隐藏掉超出的部分 div { /* 自动隐藏掉超出的部分 */ overflow: hidden; width: 400px; height: 100px; background-color: skyblue; } auto 当内容超出时，自动显示滚动条 div { /* 当内容超出时，自动显示滚动条 */ overflow: auto; width: 400px; height: 100px; background-color: skyblue; } scroll 不管超出与否，总是显示滚动条 鼠标 cursor default 箭头 pointer 小手 move 移动 text 文本 not-allowed 禁止 表单 outline: none; 取消表单框获取焦点时的高亮边框 resize: none; 禁用 textarea 文本域的调节大小功能 继承 行高的继承 body { /** 行高既可以指定单位像素，也可以不指定，如果不指定，则表示行高为当前字体的多少倍，所以此处 1.5 表示 body 的行高为 12px * 1.5 = 18px（Chrome 中计算会有一定误差，Safari 计算正常）**/ font: 12px/1.5 &quot;Microsoft YaHei&quot;; } div { /** 继承 body 的行高 1.5，所以 div 的行高为 14px * 1.5 = 21px **/ font-size: 14px; } p { /** 继承 body 的行高 1.5，所以 p 的行高为 16px * 1.5 = 24px **/ font-size: 16px; } &lt;body&gt; &lt;div&gt;Hello&lt;/div&gt; &lt;p&gt;Hello&lt;/p&gt; &lt;ul&gt; &lt;!-- 继承 body 的字体大小 12px 和行高 1.5，所以此处 li 的行高为 12px * 1.5 = 18px --&gt; &lt;li&gt;Hello&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; ","link":"http://blog.kuranado.com/post/css-ji-chu-zong-jie-md/"},{"title":"原地算法总结.md","content":"在做289. 生命游戏这道题时，题目的进阶描述中提到了原地算法，头一次听说这个名词，做个总结 在计算机科学中，一个原地算法（in-place algorithm）基本上不需要额外辅助的数据结构，然而，允许少量额外的辅助变量来转换数据的算法。当算法运行时，输入的数据通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。在计算复杂性理论中，原地算法包含使用O(1)空间复杂度的所有算法，DSPACE(1)类型。 一句话总结就是：原地算法不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。 综上，当我们的输入数据没有其他用处时，可以考虑将输入数据覆盖掉，将覆盖后的结果作为输出。 下面为几个典型使用原地算法解决的例题： 例题一 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 代码实现 public int removeDuplicates(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int pos = 0, count = 1; for (int i = 0; i &lt; nums.length; i++) { if (nums[pos] == nums[i]) { nums[pos] = nums[i]; } else { pos++; nums[pos] = nums[i]; count++; } } return count; } 例题二 将具有 n 项内容的数组 a 翻转过来 看到这题的常规思路是创建一个大小相等的新数组，用适当的顺序填充副本，最后的新数组记为结果，如下面的伪代码： function reverse(a[0..n-1]) allocate b[0..n-1] # 额外设定一个数组 for i from 0 to n-1 # 从 0 到 n-1 遍历数组 a b[n -1 - i] := a[i] return b 这种方法虽然简单，但是需要 O(n) 的额外空间以使数组 a 和 b 同时可用。此外，分配存储空间和释放存储空间通常是缓慢的操作 其实本题完全可以不用新建数组，而是可以直接修改原数组达到题目要求效果，也就是使用原地算法，用它自己翻转的内容来覆盖掉原先的内容。这样，无论数组有多大，它都只需要辅助变量 i 和 tmp 代码实现： function reverse_in_place(a[0..n-1]) for i from 0 to floor((n-2)/2) tmp := a[i] a[i] := a[n − 1 − i] a[n − 1 − i] := tmp 例题三 生命游戏 参考 原地算法（in-place algorithm） 算法系列之原地算法(in-place algorithm) ","link":"http://blog.kuranado.com/post/yuan-di-suan-fa-zong-jie-md/"},{"title":"Nginx 安装 SSL 证书.md","content":"安全组开启 443 端口 以腾讯云为例，入站规则和出站规则都需要添加 443 下载证书 腾讯云下载证书 安装证书 证书下载后解压，得到如下两个文件： 1_kuranado.com_bundle.crt 证书 2_kuranado.com.key 私钥 将这两份文件上传到服务器，并保存在服务器 /usr/local/nginx/conf 目录下，即 Nginx 的安装目录，然后编辑 Nginx 配置文件，先来看下原有的配置： server { listen 80; server_name kuranado.com www.kuranado.com emoji.kuranado.com; location / { root /home/jing/data/soft/emoji-web; index index.html; } } 原有的配置为 http 配置，可以不用对其做任何修改，下面增加证书配置： server { listen 443 ssl; server_name kuranado.com www.kuranado.com; ssl_certificate 1_kuranado.com_bundle.crt; ssl_certificate_key 2_kuranado.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { root /home/jing/data/soft/emoji-web; index index.html; } } 增加了一个监听 443 端口的 server，因为我这里是在腾讯云申请的亚洲诚信免费 DV 版 SSL 证书，一个证书只能用于一个域名，所以 server_name 只能配置为申请证书时的域名（www.kuranado.com 和 kuranado.com 等价），而不能配置泛域名 配置添加完成后，./sbin/nginx -s reload 重新加载 Nginx 配置文件，可正常访问 https://kuranado.com 或 https://www.kuranado.com/，说明证书生效 当然原先的 http 也可以正常使用 申请免费域名证书 正如上面所见，同一主域可以申请 20 张 DV 版免费 SSL 证书，对于一个个人小型网站来说已经足够使用了，只是稍微有些麻烦，需要为每个子域名都申请一份证书配置到 Nginx 中 如下面为访问 xxl-job 的 http 配置 http://task.kuranado.com/xxl-job-admin： upstream task { ip_hash; server 127.0.0.1:10001 max_fails=3 fail_timeout=30s; } server { listen 80; server_name task.kuranado.com; #charset koi8-r; #access_log logs/host.access.log main; location /xxl-job-admin { #root html; #index index.html index.htm; proxy_pass http://task; } } 这时我们就可以为其申请一张免费的域名证书，申请时通用名称填写 task.kuranado.com，然后按照上面的证书安装方法在 Nginx 中增加如下配置： server { listen 443 ssl; server_name task.kuranado.com; ssl_certificate 1_task.kuranado.com_bundle.crt; ssl_certificate_key 2_task.kuranado.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location /xxl-job-admin { #root html; #index index.html index.htm; proxy_pass http://task; } } 重新加载 Nginx 配置文件，即可使用 https://task.kuranado.com/xxl-job-admin 访问 xxl-job 同理，为每个域名都申请免费证书（不超过 20 个），便可以实现全站 https 了，美滋滋 参考 腾讯云文档 - Nginx 服务器证书安装 nginx使用ssl模块配置支持HTTPS访问 ","link":"http://blog.kuranado.com/post/nginx-an-zhuang-ssl-zheng-shu-md/"}]}